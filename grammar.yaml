comment: ([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
firstLineMatch: ^#!\s*/.*\b(so|somra)$\n?
foldingEndMarker: (\*/|\}|\))
foldingStartMarker: (/\*|{|\()
Information for Contributors: |-
  This file is a fork of the Babel JavaScript TextMate grammar and features many 
    customizations for Somra, whose syntax derives from JavaScript and many other 
    modern programing languages. This file is constantly regenerated with a custom 
    build pipeline.
  Somra is a programming language for developers to build reliable and efficient 
    software and apps for the web, desktop and mobile, that ain't gonna crash. It has 
    strong and honest types, compiles to efficient and boilerplate-free JavaScript and
    Python, and comes with a fast compiler that scales to any codebase size, with easy 
    access to bustling ecosystems of libraries.
  Should you want to provide a fix or improvement, or even a new feature,
    please create a pull request against this repo: https://github.com/NoxUltima/somra,
    and I will be very happy to receive them.
name: Somra
scopeName: source.nearley
Bugfixes:
  - Fix trailing semicolon issue in type declarations/imports and functions
  - All operators are colored differently based on their type.
  - Functions and methods are scoped to their initial starting letter, in the meantime.
  - Fixed modifier keyword parsing (technically). They should activate only before a declaration, say `dyn val x = 1`, or other modifiers.
  - Fixed operator parsing in JSX and regex literals. Inline regexes should wherever possible be spaced out on both sides. This is intentional.
Bugs:
  - 'Fix `let x: num in arr` scenario: still left some remaining'
Changes:
  - Block comments can be nested thanks to Swift's codes, and can now support Markdown.
  - Same thing for JSX markup.
  - Identifiers can now include `\`.
  - Added Scala `match` and `with` clauses.
  - Added tons of new keywords and operators; as well as support for space-delimited unary and binary operators.
  - Numeric literals support every possible even base except 14, as well as extended numeric notation for all bases.
fileTypes:
  - so
  - somra
  - ne
Fixes:
  - Revamp regex syntax (more syntax scopes for constructs)
  - Add TypeScript, ReScript and JavaScript to raw code blocks
patterns:
  - include: '#core'
repository:
  arrow-expression:
    begin: (?<==>)\s*$
    comment: or inside a class def on a ; or braced block } end of line or ;
    end: (?=\s*([,;}]|$))|(?<=})
    patterns:
      - include: '#core'
  arrow-function:
    patterns:
      - begin: \s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.somra
        beginCaptures:
          1: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. arg => { }
        match: \s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.arrow.somra
        captures:
          1: {name: storage.type.somra}
          2: {name: meta.function.parameters.somra}
          3: {name: variable.other.readwrite.somra}
          4: {name: storage.type.function.arrow.somra}
      - include: '#arrow-function-simple-assignments'
      - begin: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: Sound.prototype.play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.prototype.function.arrow.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: variable.language.prototype.somra}
          6: {name: keyword.operator.existential.somra}
          7: {name: keyword.operator.accessor.somra}
          8: {name: keyword.operator.private.somra}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.somra}
          11: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. Sound.prototype.play = arg => { }
        match: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(=>)
        name: meta.prototype.function.arrow.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: variable.language.prototype.somra}
          6: {name: keyword.operator.existential.somra}
          7: {name: keyword.operator.accessor.somra}
          8: {name: keyword.operator.private.somra}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.somra}
          11: {name: storage.type.somra}
          12: {name: variable.other.readwrite.somra}
          13: {name: storage.type.function.arrow.somra}
      - begin: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. Sound.play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.static.arrow.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: keyword.operator.private.somra}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.somra}
          8: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. Sound.play = arg => { }
        match: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(=>)
        name: meta.function.static.arrow.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: keyword.operator.private.somra}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.somra}
          8: {name: storage.type.somra}
          9: {name: variable.other.readwrite.somra}
          10: {name: storage.type.function.arrow.somra}
  arrow-function-labels:
    patterns:
      - include: '#async-arrow-function-labels'
      - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: 'e.g. play: async <T>(args) => { }'
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.somra
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.somra}
          3: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: 'e.g. play: arg => { }'
        match: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.json.arrow.somra
        captures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: keyword.operator.assignment.somra}
          3: {name: storage.type.somra}
          4: {name: meta.function.parameters.somra}
          5: {name: variable.other.readwrite.somra}
          6: {name: storage.type.function.arrow.somra}
      - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: 'e.g. ''play'': (args) => { }'
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.somra
        beginCaptures:
          1: {name: string.quoted.somra}
          2: {name: punctuation.definition.string.begin.somra}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.somra}
          5: {name: punctuation.separator.key-value.somra}
          6: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: 'e.g. ''play'': arg => { }'
        match: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.json.arrow.somra
        captures:
          1: {name: string.quoted.somra}
          2: {name: punctuation.definition.string.begin.somra}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.somra}
          5: {name: keyword.operator.assignment.somra}
          6: {name: storage.type.somra}
          7: {name: meta.function.parameters.somra}
          8: {name: variable.other.readwrite.somra}
          9: {name: storage.type.function.arrow.somra}
  arrow-function-simple-assignments:
    patterns:
      - include: '#async-arrow-function-simple-assignments'
      - begin: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=(\s*+<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.somra}
          4: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. play = arg => { }
        match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.arrow.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.somra}
          4: {name: storage.type.somra}
          5: {name: meta.function.parameters.somra}
          6: {name: variable.other.readwrite.somra}
          7: {name: storage.type.function.arrow.somra}
  async-arrow-function-labels:
    patterns:
      - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: 'e.g. play: async <T>('
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.somra
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.somra}
          3: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: 'e.g. ''play'': async <T>('
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.somra
        beginCaptures:
          1: {name: string.quoted.somra}
          2: {name: punctuation.definition.string.begin.somra}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.somra}
          5: {name: punctuation.separator.key-value.somra}
          6: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
  async-arrow-function-simple-assignments:
    patterns:
      - begin: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(?:(\basync)\s+)(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g. play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.somra}
          4: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
  backreferences:
    patterns:
      - match: \$\d+|\$[+-]
        name: keyword.other.back-reference.somra
      - match: \$\$
        name: constant.character.escape.somra
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.somra
        beginCaptures:
          1: {name: keyword.other.back-reference.somra}
        endCaptures:
          1: {name: keyword.other.back-reference.somra}
        patterns:
          - include: '#regex-group-name'
      - include: '#string-content'
  blocks:
    patterns:
      - include: '#raw'
      - include: '#schema'
      - include: '#style'
      - include: '#class'
      - include: '#enum'
      - include: '#interface'
      - include: '#trait'
      - include: '#fragment'
      - include: '#module'
      - include: '#namespace'
      - include: '#object'
      - include: '#constraint'
      - include: '#extension'
    repository:
      class:
        begin: (?<![\#\.])\s*+\b(class)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.class.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for class names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.class.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      constraint:
        begin: (?<![\#\.])\s*+\b(given|constr)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.constraint.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for constraint names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.constraint.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      enum:
        begin: (?<![\#\.])\s*+\b(enum)\s+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        name: meta.enum.declaration.somra
        beginCaptures:
          1: {name: storage.type.enum.somra}
          2: {name: entity.name.enum.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#comments'
              - begin: ([_$[:alpha:]][_$[:alnum:]]*)(?:\s*(=(?!=|>)))?\s*
                end: (?=([,;}])|$)
                beginCaptures:
                  1: {name: variable.other.enummember.somra}
                  2: {name: keyword.operator.assignment.somra}
                endCaptures:
                  1: {patterns: [{include: '#core'}]}
                patterns:
                  - include: '#core'
          - include: '#of-clause'
          - include: '#comments'
          - include: '#typed-polymorphs'
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - include: '#core'
        repository:
          of-clause:
            begin: \s*+(?<![\#\.])(of)
            end: \s*(=(?!=|>))|\s*(?<=})
            beginCaptures:
              1: {name: meta.enum.of.somra}
            endCaptures:
              1: {name: keyword.operator.assignment.somra}
            patterns:
              - include: '#typed-parse-types'
      extension:
        begin: (?<![\#\.])\s*+\b(extend|extn)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.extension.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for extension names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.extension.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      fragment:
        begin: (?<![\#\.])\s*+\b(frag)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.fragment.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for fragment names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.fragment.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      interface:
        begin: (?<![\#\.])\s*+\b(inter|struct)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.interface.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for interface names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.interface.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      module:
        begin: (?<![\#\.])\s*+\b(module)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.module.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for module names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.module.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      namespace:
        begin: (?<![\#\.])\s*+\b(nspace)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.namespace.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for namespace names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.namespace.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      object:
        begin: (?<![\#\.])\s*+\b(object|record)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.object.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for object names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.object.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      raw:
        begin: (?<![\#\.])\s*+\b(raw)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.raw.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for raw names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.raw.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#quasi-embedded'
              - include: source.ts
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      schema:
        begin: (?<![\#\.])\s*+\b(data|schema)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.schema.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for schema names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.schema.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#quasi-embedded'
              - include: '#graphql'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      style:
        begin: (?<![\#\.])\s*+\b(style)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.style.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for style names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.style.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#quasi-embedded'
              - include: source.css.scss
              - include: source.css.styled
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
      trait:
        begin: (?<![\#\.])\s*+\b(trait)(\s+|$)
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: storage.type.trait.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#operator'
          - include: '#operators'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
              3: {name: storage.type.implements.somra}
              4: {name: keyword.operator.expression.only.somra}
          - comment: look for trait names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.trait.somra
          - include: '#types'
          - begin: \s*+({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
          - include: '#core'
  brackets:
    patterns:
      - include: '#round-brackets'
      - include: '#square-brackets'
      - include: '#curly-brackets'
  cast-expression:
    match: (?x)(\()\s*(.*)\s*(\))(?=\s*[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*?[_\\\p{L}\p{M}\p{N}\p{Ps}\p{Pe}])
    captures:
      1: {name: punctuation.definition.cast.begin.somra}
      2: {patterns: [{include: '#typed-parse-types'}]}
      3: {name: punctuation.definition.cast.end.somra}
  class-body:
    patterns:
      - include: '#core'
      - include: '#attributes'
      - include: '#modifiers'
      - include: '#typed-keywords'
      - include: '#arrow-expression'
      - include: '#arrow-function-simple-assignments'
      - include: '#arrow-function'
      - include: '#brackets'
      - include: '#es7-decorators'
      - include: '#comments'
      - comment: handle class fields with no flow types like var =
        match: (?<!:)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?==)(?!=>|==)
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.readwrite.somra}
      - begin: \s*+(?==[^=>])
        comment: a line starts with a static, [, name(, name:, name=, } or a semi-colon anywhere
        end: ((?=^\s*(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+\??\s*+(:|=(?!^==|=>))|\[|((?:(\#?)[_\\p{L}\p{Nl}])(?:[(\#?)_\\p{L}\p{M}\p{N}])*+)\s*+\(|\b(static|async)\b)|}))|\s*(;)
        endCaptures:
          9: {name: punctuation.terminator.statement.somra}
        patterns:
          - include: '#method'
          - include: '#core'
      - match: (?<![\#\.])\s*+\b(static)\b(?!\.)
        captures:
          1: {name: storage.modifier.somra}
      - include: '#typed-variable'
      - include: '#semi-colon'
  clauses:
    patterns:
      - include: '#for-block'
      - include: '#if-block'
      - include: '#switch-block'
      - include: '#match-block'
      - include: '#catch-block'
      - include: '#with-block'
      - include: '#parallel-block'
      - include: '#do-block'
    repository:
      catch-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(try|catch|rescue|finally)\b\s*(await)?\b
            end: \s*((?<=[});])|(?=\b(try|catch|rescue|finally|then|para|seq)\b))
            name: meta.catch.somra
            beginCaptures:
              1: {name: keyword.control.trycatch.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - begin: \s*+(\()
                end: \s*(\))
                beginCaptures:
                  1: {name: meta.brace.round.somra}
                endCaptures:
                  1: {name: meta.brace.round.somra}
                patterns:
                  - match: (?<![\#\.])\s*+\b(as)\b
                    name: keyword.control.trycatch.somra
                  - include: '#core'
              - include: '#curly-brackets'
              - match: (?<![\#\.])\s*+\b(as)\b
                name: keyword.control.trycatch.somra
              - include: $self
      do-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(do)\b\s*(await)?\b
            end: \s*(?<=[})])
            name: meta.do.somra
            beginCaptures:
              1: {name: keyword.control.do.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - include: '#round-brackets'
              - include: '#curly-brackets'
              - include: $self
      for-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(for|foreach|each|while|until)\b\s*(await)?\b
            end: \s*(?<=[})])
            name: meta.for.somra
            beginCaptures:
              1: {name: keyword.control.loop.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - match: (?<![\#\.])\s*+\b(in|of|by|to|til)\b
                name: keyword.control.loop.somra
              - include: '#let-clause'
              - begin: \s*+(\()
                end: \s*(\))
                beginCaptures:
                  1: {name: meta.brace.round.somra}
                endCaptures:
                  1: {name: meta.brace.round.somra}
                patterns:
                  - match: (?<![\#\.])\s*+\b(in|of|by|to|til)\b
                    name: keyword.control.loop.somra
                  - include: '#let-clause'
                  - include: '#core'
              - include: '#curly-brackets'
              - include: $self
        repository:
          let-clause:
            comment: override let keyword
            match: (?<![\#\.])\s*+\b(const|con|let|var|val)\b\s*
            name: storage.type.somra
      if-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(if|els?if|ell?ess?|unless?|guard)\b\s*(await)?\b
            end: \s*(?<=[})])
            name: meta.if.somra
            beginCaptures:
              1: {name: keyword.control.conditional.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - include: '#curly-brackets'
              - include: '#round-brackets'
              - include: $self
      match-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(match)\b
            end: \s*(\})
            name: meta.match.somra
            beginCaptures:
              1: {name: keyword.control.match.somra}
            endCaptures:
              1: {name: meta.brace.curly.matchEnd.somra}
            patterns:
              - include: '#round-brackets'
              - begin: \s*+({)
                end: \s*(?=})
                beginCaptures:
                  1: {name: meta.brace.curly.matchStart.somra}
                patterns:
                  - begin: (?<![\#\.])\s*+\b(if|unless?|els?if|ell?ess?|else\s+if|else\s+unless?)\b
                    end: \s*->
                    beginCaptures:
                      1: {name: keyword.control.match.somra}
                    endCaptures:
                      0: {patterns: [{include: '#core'}]}
                    patterns:
                      - include: $self
                  - begin: (?<![\#\.])\s*+\b(else|def)\b
                    end: \s*->
                    beginCaptures:
                      1: {name: keyword.control.match.somra}
                    endCaptures:
                      0: {patterns: [{include: '#core'}]}
                    patterns:
                      - include: $self
                  - begin: (?<![\#\.])\s*+\b(when|case)\b
                    end: \s*->
                    beginCaptures:
                      1: {name: keyword.control.match.somra}
                    endCaptures:
                      0: {patterns: [{include: '#core'}]}
                    patterns:
                      - include: '#match-clause'
                      - include: '#as-clause'
                      - include: '#case-separator'
                      - include: '#core'
                  - include: $self
              - include: $self
        repository:
          as-clause:
            begin: (?<![\#\.])\s*\b(as|with)\b\s*
            end: (?<![\#\.])\s*\b(?=as|with)|\s*(?=->)
            beginCaptures:
              1: {name: keyword.control.match.somra}
            endCaptures:
              1: {patterns: [{include: '#core'}]}
            patterns:
              - include: '#match-clause'
              - include: '#as-clause'
              - include: '#case-separator'
              - include: '#typed-parse-types'
          case-separator:
            begin: ([,;])
            end: (?<![\#\.])\s*\b(?=as|with|if|unless|where)|\s*(?=->)
            beginCaptures:
              1: {patterns: [{include: '#core'}]}
            endCaptures:
              1: {patterns: [{include: '#core'}]}
            patterns:
              - include: '#match-clause'
              - include: '#as-clause'
              - include: '#case-separator'
              - include: '#core'
          match-clause:
            begin: (?<![\#\.])\s*\b(if|unless|where)\b\s*
            end: (?<![\#\.])\s*\b(?=if|unless|where)|\s*(?=->)
            beginCaptures:
              1: {name: keyword.control.match.somra}
            endCaptures:
              1: {patterns: [{include: '#core'}]}
            patterns:
              - include: '#match-clause'
              - include: '#as-clause'
              - include: '#case-separator'
              - include: '#core'
      parallel-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(para|seq)\b\s*(await)?\b
            end: \s*((?<=[});])|(?=\b(try|catch|rescue|finally|then|para|seq)\b))
            name: meta.parallel.somra
            beginCaptures:
              1: {name: keyword.control.parallel.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - begin: \s*+(\()
                end: \s*(\))
                beginCaptures:
                  1: {name: meta.brace.round.somra}
                endCaptures:
                  1: {name: meta.brace.round.somra}
                patterns:
                  - match: (?<![\#\.])\s*+\b(as)\b
                    name: keyword.control.parallel.somra
                  - include: '#core'
              - include: '#curly-brackets'
              - match: (?<![\#\.])\s*+\b(as)\b
                name: keyword.control.parallel.somra
              - include: $self
      switch-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(switch)\b
            end: \s*(\})
            name: meta.switch.somra
            beginCaptures:
              1: {name: keyword.control.switch.somra}
            endCaptures:
              1: {name: meta.brace.curly.switchEnd.somra}
            patterns:
              - include: '#round-brackets'
              - begin: \s*+({)
                end: \s*(?=})
                beginCaptures:
                  1: {name: meta.brace.curly.switchStart.somra}
                patterns:
                  - begin: (?<![\#\.])\s*+\b(case|def)\b
                    end: \s*(:)((?=::)|(?![:<=>]))
                    beginCaptures:
                      1: {name: keyword.control.switch.somra}
                    endCaptures:
                      1: {name: keyword.operator.somra}
                    patterns:
                      - include: '#core'
                  - include: $self
              - include: $self
      with-block:
        patterns:
          - begin: (?<![\#\.])\s*+\b(with)\b\s*(await)?\b
            end: \s*(?<=[})])
            name: meta.with.somra
            beginCaptures:
              1: {name: keyword.control.with.somra}
              2: {name: keyword.control.flow.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - include: '#curly-brackets'
              - begin: \s*
                end: \s*(?=[{,])
                patterns:
                  - match: (?<![\#\.])\s*+\b(as)\b
                    name: keyword.control.with.somra
                  - include: '#core'
              - begin: \s*+(\()
                end: \s*(\))
                beginCaptures:
                  1: {name: meta.brace.round.somra}
                endCaptures:
                  1: {name: meta.brace.round.somra}
                patterns:
                  - match: (?<![\#\.])\s*+\b(as)\b
                    name: keyword.control.with.somra
                  - include: '#core'
              - include: $self
  comma:
    patterns:
      - match: \s*+(,)
        captures:
          1: {name: meta.delimiter.comma.somra}
  comments:
    patterns:
      - include: '#typed-comments'
      - include: '#special-comments-conditional-compilation'
      - begin: \s*+((/\*\*))(?!/|\*)
        contentName: comment.block.documentation.somra
        end: (\s*(\*/))
        captures:
          1: {name: comment.block.documentation.somra}
          2: {name: punctuation.definition.comment.somra}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested'
      - begin: \s*+((/\*))
        contentName: comment.block.somra
        end: (\s*(\*/))
        captures:
          1: {name: comment.block.somra}
          2: {name: punctuation.definition.comment.somra}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested'
      - begin: \s*+(<!--)
        contentName: comment.block.html.somra
        end: \s*+(-->)
        beginCaptures:
          1: {name: punctuation.definition.comment.somra}
        endCaptures:
          1: {name: punctuation.definition.comment.somra}
      - begin: ((^\s*)|\s*)((///))
        comment: leading whitespace on a new line comment is scoped so Atom reflow works
        contentName: comment.line.triple-slash.somra
        end: \s*$
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.somra}
          3: {name: comment.line.triple-slash.somra}
          4: {name: punctuation.definition.comment.somra}
        endCaptures:
          0: {name: comment.line.triple-slash.somra}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//))
        comment: leading whitespace on a new line comment is scoped so Atom reflow works
        contentName: comment.line.double-slash.somra
        end: \s*$
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.somra}
          3: {name: comment.line.double-slash.somra}
          4: {name: punctuation.definition.comment.somra}
        endCaptures:
          0: {name: comment.line.double-slash.somra}
      - match: ^(\#!).*$\n?
        name: comment.line.shebang.somra
        captures:
          1: {name: punctuation.definition.comment.somra}
    repository:
      nested:
        begin: /\*\*?
        end: \*/
        beginCaptures:
          0: {name: punctuation.definition.comment.somra}
        endCaptures:
          0: {name: punctuation.definition.comment.somra}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested'
  core:
    patterns:
      - include: '#operator'
      - include: '#sigils'
      - include: '#clauses'
      - comment: before module as it traps default {
        include: '#object'
      - include: '#new'
      - include: '#query'
      - include: '#module'
      - include: '#function'
      - include: '#arrow-function'
      - comment: after function, which includes some prototype strings
        include: '#prototype'
      - include: '#blocks'
      - include: '#modifiers'
      - include: '#keyword-storage'
      - include: '#typed-keywords'
      - include: '#typed-trap'
      - include: '#keywords'
      - include: '#method-call'
      - include: '#function-call'
      - include: '#multiline-arrow-function-generics'
      - include: '#jsx'
      - include: '#es7-decorators'
      - include: '#js-label'
      - include: '#regexp-multiline'
      - comment: before operators to avoid ambiguities
        include: '#regexp'
      - include: '#number'
      - include: '#quasi'
      - include: '#string'
      - include: '#language-constant'
      - include: '#language-variable'
      - include: '#support'
      - include: '#implicit-call'
      - include: '#support-properties'
      - include: '#variable'
      - include: '#brackets'
      - include: '#operators'
      - include: '#punctuation'
      - include: '#comments'
      - include: '#fat-arrow'
  curly-brackets:
    patterns:
      - begin: \s*+(#{)
        end: \s*(\})
        beginCaptures:
          1: {name: meta.brace.curly.litobj.somra}
        endCaptures:
          1: {name: meta.brace.curly.litobj.somra}
        patterns:
          - include: '#object-body'
          - include: '#labels'
          - include: '#core'
      - begin: \s*+({)
        end: \s*(\})
        beginCaptures:
          1: {name: meta.brace.curly.somra}
        endCaptures:
          1: {name: meta.brace.curly.somra}
        patterns:
          - include: '#js-label'
          - include: '#labels'
          - include: '#core'
  es7-decorators:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<!@)\s*+(?:(@)(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)))
        comment: Look for a @identifier start If unicode start uppercase e.g. @A class it as a class
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.decorator.somra}
          2: {name: keyword.operator.private.somra}
          3: {name: entity.name.class.decorator.somra}
          4: {name: variable.other.readwrite.decorator.somra}
        patterns:
          - begin: \s*(?:(\?\.)|(\.))
            commnent: decorator .property or .method which may be on a different line
            end: \s*(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+))
            beginCaptures:
              1: {name: keyword.operator.existential.somra}
              2: {name: keyword.operator.accessor.somra}
            endCaptures:
              1: {name: keyword.operator.private.somra}
              2: {name: entity.name.class.decorator.somra}
              3: {name: variable.other.property.decorator.somra}
            patterns:
              - include: '#comments'
          - comment: arguments for decorators
            include: '#round-brackets'
          - begin: (?:(?<=^|;)|(?=\s))\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(\#?)((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
            comment: 'method that always follow decorators such as play<T,T>(arg1, arg2): Type<T> { }'
            end: (?<=:|})|(?=;|}|,)
            name: meta.function.method.somra
            beginCaptures:
              1: {name: storage.modifier.somra}
              2: {name: storage.type.somra}
              3: {name: keyword.generator.asterisk.somra}
              4: {name: keyword.operator.private.somra}
              5: {name: entity.name.function.method.somra}
            patterns:
              - include: '#types'
              - include: '#curly-brackets'
              - include: '#core'
              - include: $self
          - include: '#comments'
          - match: \s*
  es7-function-bind:
    patterns:
      - comment: https://github.com/zenparsing/es-function-bind#examples
        match: \s*(::)
        captures:
          1: {name: keyword.operator.accessor.somra}
  esnext-pipeline:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(\+>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.pipeline.somra}
        patterns:
          - match: (?<=\+>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: meta.function-call.without-arguments.somra}
              4: {patterns: [{include: '#function-name'}]}
          - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: meta.method-call.without-arguments.somra}
              4: {patterns: [{include: '#method-name'}]}
          - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: variable.other.object.somra}
              4: {name: keyword.operator.existential.somra}
              5: {name: keyword.operator.accessor.somra}
          - include: '#comments'
      - applyEndPatternLast: 1
        begin: \s*(\|>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.pipeline.somra}
        patterns:
          - match: (?<=\|>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: meta.function-call.without-arguments.somra}
              4: {patterns: [{include: '#function-name'}]}
          - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: meta.method-call.without-arguments.somra}
              4: {patterns: [{include: '#method-name'}]}
          - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
            captures:
              2: {name: keyword.operator.private.somra}
              3: {name: variable.other.object.somra}
              4: {name: keyword.operator.existential.somra}
              5: {name: keyword.operator.accessor.somra}
          - include: '#comments'
      - match: \s*(\|>|\+>)
        captures:
          1: {name: keyword.operator.pipeline.somra}
  fat-arrow:
    comment: trap fat-arrow
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(=>)
        comment: match arrow func symbol
        end: (?=.)
        beginCaptures:
          1: {name: storage.type.function.arrow.somra}
        patterns:
          - include: $self
  fat-arrow-braced-body:
    begin: \s*(=>)\s*({)
    comment: ' => {'
    end: \s*(})
    beginCaptures:
      1: {name: storage.type.function.arrow.somra}
      2: {name: meta.brace.curly.somra}
    endCaptures:
      1: {name: meta.brace.curly.somra}
    patterns:
      - include: $self
  function:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*+(?:\b(async)\b\s+)?\s*+(?:(?<=\.\.\.)|(?<![\#\.]))(\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. function play<T>(arg1, arg2) { }
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=})|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.somra}
          2: {name: storage.type.function.somra}
          3: {name: keyword.generator.asterisk.somra}
          4: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. play = function(arg1, arg2) { }
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=})|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.somra}
          4: {name: storage.type.somra}
          5: {name: storage.type.function.somra}
          6: {name: keyword.generator.asterisk.somra}
          7: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\p{Lu}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. Sound.prototype.play = function(arg1, arg2) { }
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=})|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: variable.language.prototype.somra}
          6: {name: keyword.operator.existential.somra}
          7: {name: keyword.operator.accessor.somra}
          8: {name: keyword.operator.private.somra}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.somra}
          11: {name: storage.type.somra}
          12: {name: storage.type.function.somra}
          13: {name: keyword.generator.asterisk.somra}
          14: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\p{Lu}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. Sound.play = function(arg1, arg2) { }
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=})|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        name: meta.function.static.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: keyword.operator.private.somra}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.somra}
          8: {name: storage.type.somra}
          9: {name: storage.type.function.somra}
          10: {name: keyword.generator.asterisk.somra}
          11: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
  function-call:
    patterns:
      - include: '#comments'
      - comment: A new expression with no type params or arguments, like new Foo()
        match: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\)))
        name: meta.new-class.without-arguments.somra
        captures:
          1: {name: keyword.operator.new.somra}
          2: {name: meta.function-call.without-arguments.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: entity.name.type.instance.somra}
          5: {name: keyword.operator.existential.somra}
          6: {name: keyword.operator.cascade.somra}
          7: {name: keyword.operator.assertion.somra}
          8: {name: keyword.operator.accessor.somra}
          9: {name: meta.brace.round.somra}
          10: {name: meta.brace.round.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
        comment: A new expression with type params and no arguments, like new Foo<string>()
        end: (?=.)
        name: meta.new-class.without-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.new.somra}
          2: {name: meta.function-call.without-arguments.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: entity.name.type.instance.somra}
          5: {name: keyword.operator.existential.somra}
          6: {name: keyword.operator.cascade.somra}
          7: {name: keyword.operator.assertion.somra}
          8: {name: keyword.operator.accessor.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
        comment: A new expression with arguments and maybe type params, like new Foo<string>(123)
        end: (?=.)
        name: meta.new-class.with-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.new.somra}
          2: {name: meta.function-call.with-arguments.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: entity.name.type.instance.somra}
          5: {name: keyword.operator.existential.somra}
          6: {name: keyword.operator.cascade.somra}
          7: {name: keyword.operator.assertion.somra}
          8: {name: keyword.operator.accessor.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - include: '#operators'
      - comment: A call expression with no type params or arguments, like foo()
        match: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\))
        name: meta.function-call.without-arguments.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.cascade.somra}
          5: {name: keyword.operator.assertion.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {name: meta.brace.round.somra}
          8: {name: meta.brace.round.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\)))
        comment: A call expression with type params and no arguments, like foo<string>()
        end: (?=.)
        name: meta.function-call.without-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.cascade.somra}
          5: {name: keyword.operator.assertion.somra}
          6: {name: keyword.operator.accessor.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\(\s*+\))
        comment: maybe in array form e.g. foo[bar]() or foo[bar]<string>()
        end: (?=.)
        name: meta.function-call.without-arguments.somra
        beginCaptures:
          2: {name: keyword.operator.new.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: variable.other.object.somra}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: A call expression with arguments and maybe type params, like foo(123) or foo<string>(123)
        end: (?=.)
        name: meta.function-call.with-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.cascade.somra}
          5: {name: keyword.operator.assertion.somra}
          6: {name: keyword.operator.accessor.somra}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: maybe in array form e.g. foo[bar](123)
        end: (?=.)
        name: meta.function-call.with-arguments.somra
        beginCaptures:
          2: {name: keyword.operator.new.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: variable.other.object.somra}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - include: '#keywords'
  function-labels:
    patterns:
      - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(?:(\*)\s*)?(?=\s*(\(|<))
        comment: 'e.g. play: function(arg1, arg2) { }'
        end: \s*(=)|\s*(?<=})
        name: meta.function.json.somra
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.somra}
          3: {name: storage.type.somra}
          4: {name: storage.type.function.somra, patterns: [{include: '#string-content'}]}
          5: {name: keyword.generator.asterisk.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
      - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(async)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*(\*\s*)?(?=\s*(\(|<))
        comment: 'e.g. ''play'': function(arg1, arg2) { }'
        end: \s*(=)|\s*(?<=})
        name: meta.function.json.somra
        beginCaptures:
          1: {name: string.quoted.somra}
          2: {name: punctuation.definition.string.begin.somra}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.somra}
          5: {name: punctuation.separator.key-value.somra}
          6: {name: storage.type.somra}
          7: {name: storage.type.function.somra}
          8: {name: keyword.generator.asterisk.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#core'
          - include: '#curly-brackets'
  function-name:
    patterns:
      - include: '#support-functions'
      - include: '#support-methods'
      - comment: primitive types
        match: (?i)\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func))\b
        name: support.type.builtin.primitive.somra
      - comment: primitive types
        match: (?i)\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|unit|buff))\b
        name: support.type.builtin.somra
      - match: \b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        name: support.type.builtin.class.somra
      - match: (([a-zA-Z])[_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.$2.somra
      - match: '[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
        name: support.type.class.somra
      - match: '[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
        name: entity.name.function.somra
  graphql:
    patterns:
      - include: '#graphql-fragment-definition'
      - include: '#graphql-type-interface'
      - include: '#graphql-enum'
      - include: '#graphql-scalar'
      - include: '#graphql-union'
      - include: '#graphql-schema'
      - include: '#graphql-operation-def'
      - include: '#graphql-comment'
      - include: '#quasi-embedded'
    repository:
      graphql-arguments:
        begin: \s*(\()
        end: \s*(\))
        name: meta.arguments.graphql
        beginCaptures:
          1: {name: meta.brace.round.directive.graphql}
        endCaptures:
          1: {name: meta.brace.round.directive.graphql}
        patterns:
          - include: '#graphql-comment'
          - begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?:\s*(:))?
            end: (?=\s*(?:(?:([_A-Za-z][_\\dA-Za-z]*)\s*(:))|\)))|\s*(,)
            beginCaptures:
              1: {name: variable.arguments.graphql}
              2: {name: punctuation.colon.graphql}
            endCaptures:
              3: {name: punctuation.comma.graphql}
            patterns:
              - include: '#graphql-value'
              - include: '#graphql-comment'
              - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-boolean-value:
        match: \s*\b(true|false)\b
        captures:
          1: {name: constant.boolean.graphql}
      graphql-colon:
        match: \s*(:)
        captures:
          1: {name: punctuation.colon.graphql}
      graphql-comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.comma.graphql}
      graphql-comment:
        patterns:
          - begin: \s*+"""
            end: \s*"""
            name: comment.block.graphql.somra
          - match: (\s*)((\#.*)|(".*"))
            name: comment.line.graphql.somra
            captures:
              1: {name: punctuation.whitespace.comment.leading.graphql}
      graphql-directive:
        applyEndPatternLast: 1
        begin: \s*((@)\s*([_A-Za-z][_\\dA-Za-z]*))
        end: (?=.)
        beginCaptures:
          1: {name: entity.name.function.directive.graphql}
        patterns:
          - include: '#graphql-arguments'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-enum:
        begin: \s*+\b(enum)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        end: (?<=})
        name: meta.enum.graphql
        beginCaptures:
          1: {name: keyword.enum.graphql}
          2: {name: support.type.enum.graphql}
        patterns:
          - begin: \s*({)
            end: \s*(})
            name: meta.type.object.graphql
            beginCaptures:
              1: {name: punctuation.operation.graphql}
            endCaptures:
              1: {name: punctuation.operation.graphql}
            patterns:
              - include: '#graphql-object-type'
              - include: '#graphql-comment'
              - include: '#graphql-enum-value'
              - include: '#quasi-embedded'
      graphql-enum-value:
        match: \s*(?!=\b(true|false|null)\b)([_A-Za-z][_\\dA-Za-z]*)
        name: constant.character.enum.graphql
      graphql-field:
        patterns:
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)\s*(:)
            captures:
              1: {name: string.unquoted.alias.graphql}
              2: {name: punctuation.colon.graphql}
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)
            captures:
              1: {name: variable.graphql}
          - include: '#graphql-arguments'
          - include: '#graphql-directive'
          - include: '#graphql-selection-set'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-float-value:
        match: \s*((-)?(0|([1-9]\d*)(\.\d*)?((e|E)(\+|-)?\d*)?))
        captures:
          1: {name: constant.float.graphql}
      graphql-fragment-definition:
        begin: \s*(?:(\bfragment\b)\s*(?!\bon\b)([_A-Za-z][_\\dA-Za-z]*)\s*(?:(\bon\b)\s*([_A-Za-z][_\\dA-Za-z]*)))
        end: (?<=})
        name: meta.fragment.graphql
        captures:
          1: {name: keyword.fragment.graphql}
          2: {name: entity.name.fragment.graphql}
          3: {name: keyword.on.graphql}
          4: {name: support.type.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-fragment-spread:
        applyEndPatternLast: 1
        begin: \s*(\.\.\.)\s*(?!\bon\b)([_A-Za-z][_\\dA-Za-z]*)
        end: (?=.)
        captures:
          1: {name: keyword.operator.spread.graphql}
          2: {name: variable.fragment.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-ignore-spaces:
        match: \s*
      graphql-inline-fragment:
        applyEndPatternLast: 1
        begin: \s*(\.\.\.)\s*(?:(\bon\b)\s*([_A-Za-z][_\\dA-Za-z]*))?
        end: (?=.)
        captures:
          1: {name: keyword.operator.spread.graphql}
          2: {name: keyword.on.graphql}
          3: {name: support.type.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-input-types:
        patterns:
          - include: '#graphql-scalar-type'
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)(?:\s*(!))?
            captures:
              1: {name: support.type.graphql}
              2: {name: keyword.operator.nulltype.graphql}
          - begin: \s*(\[)
            end: \s*(\])(?:\s*(!))?
            name: meta.type.list.graphql
            captures:
              1: {name: meta.brace.squart.graphql}
              2: {name: keyword.operator.nulltype.graphql}
            patterns:
              - include: '#graphql-input-types'
              - include: '#graphql-comment'
              - include: '#graphql-comma'
              - include: '#quasi-embedded'
      graphql-int-value:
        match: \s*((-)?(0|[1-9][\d]*))
        captures:
          1: {name: constant.int.graphql}
      graphql-list-value:
        patterns:
          - begin: \s*+(\[)
            end: \s*(\])
            name: meta.listvalues.graphql
            beginCaptures:
              1: {name: meta.brace.square.graphql}
            endCaptures:
              1: {name: meta.brace.square.graphql}
            patterns:
              - include: '#graphql-value'
      graphql-name:
        match: \s*([_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: entity.name.function.graphql}
      graphql-object-field:
        match: \s*(([_A-Za-z][_\\dA-Za-z]*))\s*(:)
        captures:
          1: {name: constant.object.key.graphql}
          2: {name: string.unquoted.graphql}
          3: {name: punctuation.graphql}
      graphql-object-value:
        patterns:
          - begin: \s*+({)
            end: \s*(})
            name: meta.objectvalues.graphql
            beginCaptures:
              1: {name: meta.brace.curly.graphql}
            endCaptures:
              1: {name: meta.brace.curly.graphql}
            patterns:
              - include: '#graphql-object-field'
              - include: '#graphql-value'
      graphql-operation-def:
        patterns:
          - include: '#graphql-query-mutation'
          - include: '#graphql-name'
          - include: '#graphql-variable-definitions'
          - include: '#graphql-directive'
          - include: '#graphql-selection-set'
      graphql-query-mutation:
        match: \s*\b(query|mutation)\b
        captures:
          1: {name: keyword.operation.graphql}
      graphql-scalar:
        match: \s*\b(scalar)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: keyword.scalar.graphql}
          2: {name: entity.scalar.graphql}
      graphql-scalar-type:
        match: \s*\b(Int|Float|String|Boolean|ID)\b(?:\s*(!))?
        captures:
          1: {name: support.type.builtin.graphql}
          2: {name: keyword.operator.nulltype.graphql}
      graphql-schema:
        begin: \s*\b(schema)\b
        end: (?<=})
        beginCaptures:
          1: {name: keyword.schema.graphql}
        patterns:
          - begin: \s*({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.operation.graphql}
            endCaptures:
              1: {name: punctuation.operation.graphql}
            patterns:
              - begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
                end: (?=\s*(([_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(})))|\s*(,)
                beginCaptures:
                  1: {name: variable.arguments.graphql}
                endCaptures:
                  5: {name: punctuation.comma.graphql}
                patterns:
                  - match: \s*([_A-Za-z][_\\dA-Za-z]*)
                    captures:
                      1: {name: support.type.graphql}
                  - include: '#graphql-colon'
                  - include: '#graphql-comment'
                  - include: '#graphql-skip-newlines'
              - include: '#graphql-comment'
              - include: '#graphql-skip-newlines'
          - include: '#graphql-comment'
          - include: '#graphql-skip-newlines'
      graphql-selection-set:
        begin: \s*({)
        end: \s*(})
        name: meta.selectionset.graphql
        beginCaptures:
          1: {name: punctuation.operation.graphql}
        endCaptures:
          1: {name: punctuation.operation.graphql}
        patterns:
          - include: '#graphql-field'
          - include: '#graphql-fragment-spread'
          - include: '#graphql-inline-fragment'
          - include: '#graphql-comma'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-skip-newlines:
        match: \s*
      graphql-string-content:
        patterns:
          - match: \\[/'"\\nrtbf]
            name: constant.character.escape.graphql
          - match: \\u(\h{4})
            name: constant.character.escape.graphql
      graphql-string-value:
        begin: \s*+(("))
        contentName: string.quoted.double.graphql
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.double.graphql}
          2: {name: punctuation.definition.string.begin.graphql}
        endCaptures:
          1: {name: string.quoted.double.graphql}
          2: {name: punctuation.definition.string.end.graphql}
          3: {name: invalid.illegal.newline.graphql}
        patterns:
          - include: '#graphql-string-content'
          - include: '#quasi-embedded'
      graphql-type-definition:
        begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
        comment: 'key (optionalArgs): Type'
        end: (?=\s*(([_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(})))|\s*(,)
        beginCaptures:
          1: {name: variable.graphql}
        endCaptures:
          5: {name: punctuation.comma.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-variable-definitions'
          - include: '#graphql-type-object'
          - include: '#graphql-colon'
          - include: '#graphql-input-types'
          - include: '#quasi-embedded'
      graphql-type-interface:
        applyEndPatternLast: 1
        begin: \s*\b(?:(extends?)?\b\s*\b(type)|(interface)|(input))\b\s*([_A-Za-z][_\\dA-Za-z]*)?
        end: (?=.)
        name: meta.type.interface.graphql
        beginCaptures:
          1: {name: keyword.type.graphql}
          2: {name: keyword.type.graphql}
          3: {name: keyword.interface.graphql}
          4: {name: keyword.input.graphql}
          5: {name: support.type.graphql}
        patterns:
          - match: \s*\b(implements)\b\s*([_A-Za-z][_\\dA-Za-z]*)
            captures:
              1: {name: keyword.implements.graphql}
              2: {name: support.type.graphql}
          - include: '#graphql-comment'
          - include: '#graphql-type-object'
          - include: '#quasi-embedded'
          - include: '#graphql-ignore-spaces'
      graphql-type-object:
        begin: \s*({)
        end: \s*(})
        name: meta.type.object.graphql
        beginCaptures:
          1: {name: punctuation.operation.graphql}
        endCaptures:
          1: {name: punctuation.operation.graphql}
        patterns:
          - include: '#graphql-object-type'
          - include: '#graphql-comment'
          - include: '#graphql-type-definition'
          - include: '#quasi-embedded'
      graphql-union:
        applyEndPatternLast: 1
        begin: \s*\b(union)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        end: (?=.)
        captures:
          1: {name: keyword.union.graphql}
          2: {name: support.type.graphql}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*(=(?!=|>))\s*([_A-Za-z][_\\dA-Za-z]*)
            end: (?=.)
            captures:
              1: {name: punctuation.assignment.graphql}
              2: {name: support.type.graphql}
            patterns:
              - include: '#graphql-skip-newlines'
              - include: '#graphql-comment'
              - include: '#quasi-embedded'
              - match: \s*(\|)\s*([_A-Za-z][_\\dA-Za-z]*)
                captures:
                  1: {name: punctuation.or.graphql}
                  2: {name: support.type.graphql}
          - include: '#graphql-skip-newlines'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-union-mark:
        match: \s*(\|)
        captures:
          1: {name: punctuation.union.graphql}
      graphql-value:
        patterns:
          - include: '#graphql-variable-name'
          - include: '#graphql-float-value'
          - include: '#graphql-int-value'
          - include: '#graphql-string-value'
          - include: '#graphql-boolean-value'
          - include: '#graphql-enum-value'
          - include: '#graphql-list-value'
          - include: '#graphql-object-value'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-variable-assignment:
        applyEndPatternLast: 1
        begin: \s(=)
        end: (?=.)
        beginCaptures:
          1: {name: punctuation.assignment.graphql}
        patterns:
          - include: '#graphql-value'
      graphql-variable-definition:
        begin: \s*(\$?[_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
        comment: 'variable: type = value,.... which may be a list'
        end: (?=\s*((\$?[_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(}|\))))|\s*(,)
        name: meta.variables.graphql
        beginCaptures:
          1: {name: variable.graphql}
        endCaptures:
          5: {name: punctuation.comma.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-colon'
          - include: '#graphql-input-types'
          - include: '#graphql-variable-assignment'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-variable-definitions:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: meta.brace.round.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-variable-definition'
          - include: '#quasi-embedded'
      graphql-variable-name:
        match: \s*(\$[_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: variable.graphql}
  heregexp:
    patterns:
      - include: '#comments'
      - include: '#regexp-patterns'
  html-template:
    begin: (?:(?:^|(?<=,|{))\s*\b((template))\b\s*(:)\s*(`))
    comment: 'Assume object properties of template: `some html` contain html'
    end: \s*(`)
    beginCaptures:
      1: {name: constant.other.object.key.somra}
      2: {name: string.unquoted.somra}
      3: {name: punctuation.separator.key-value.somra}
      4: {name: punctuation.definition.quasi.begin.somra}
    endCaptures:
      1: {name: punctuation.definition.quasi.end.somra}
    patterns:
      - begin: (?<!\\)\${
        end: \s*}
        name: entity.quasi.element.somra
        beginCaptures:
          0: {name: punctuation.quasi.element.begin.somra}
        endCaptures:
          0: {name: punctuation.quasi.element.end.somra}
        patterns:
          - include: '#core'
      - include: text.html.mustache
  ignore-long-lines:
    comment: so set at arbitary 1000 chars to avoid parsing minified files
    patterns:
      - match: ^.{1000,}
  implicit-call:
    patterns:
      - comment: Avoid all language keywords as much as possible
        match: (?x)(?<=\.)\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?=['"`(]|::|<[-+|])
        captures:
          1: {patterns: [{include: '#method-name'}]}
      - comment: Avoid all language keywords as much as possible
        match: (?x)\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?=['"`(]|::|<[-+|])
        captures:
          1: {patterns: [{include: '#function-name'}]}
  js-label:
    comment: 'jslabel: $|for|while|do'
    match: (?:^|(?<=;))\s*([_\\p{L}\p{Nl}][-_\\p{L}\p{M}\p{N}]*+)(:)\s*(?=(/\*.*?\*/\s*$|//|$|;|\b(for|while|do|if|switch|match|repeat)\b))
    captures:
      1: {name: constant.other.label.somra}
      2: {name: punctuation.separator.label.somra}
  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-namepath'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-namepath'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-noname'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|select|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|singleton|template|uses|xtype)\b
        name: storage.type.class.jsdoc
    repository:
      jsdoc-access:
        comment: '@tag protected....'
        match: (?:^[\s*]*|(?<=/\*\*)\s*)(@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-as-namepath:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        comment: to terminate the block
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-namepath-scopes'
      jsdoc-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.jsdoc
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.jsdoc}
              3: {name: string.jsdoc}
      jsdoc-module:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        comment: '@tag {optional type} module:file'
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - match: (?:(module)(:))?(((?!\*/)\S)+)
            captures:
              1: {name: keyword.module.jsdoc}
              2: {name: punctuation.jsdoc}
              3: {name: string.modulename.jsdoc}
      jsdoc-name-scopes:
        patterns:
          - match: ((?!\*/)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.jsdoc}
          - begin: \[
            end: \]|^
            name: variable.other.jsdoc
            patterns:
              - include: '#jsdoc-string'
              - include: '#jsdoc-name-scopes'
      jsdoc-namepath-scopes:
        patterns:
          - match: \s*\b(as)\b\s*(?=[$_A-Za-z])
            captures:
              1: {name: keyword.as.jsdoc}
          - match: \s*(?:([A-Z][$_A-Za-z\d]*)|([$_A-Za-z][$_A-Za-z\d]*))(?=[\s\-~.#]|$)
            captures:
              1: {name: entity.name.class.jsdoc}
              2: {name: entity.name.function.jsdoc}
          - match: (\.)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.static.jsdoc}
          - match: (\#)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.instance.jsdoc}
          - match: (~|-)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.inner.jsdoc}
          - match: (\#)(event)(:)
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: keyword.event.jsdoc}
              3: {name: keyword.operator.jsdoc}
          - applyEndPatternLast: 1
            begin: \.(?="|')
            end: (?=.)
            name: string.method.jsdoc
            patterns:
              - include: '#jsdoc-string'
      jsdoc-simple:
        comment: '@tag'
        match: (?:^[\s*]*|(?<=/\*\*)\s*)(@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-namepath:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - include: '#jsdoc-namepath-scopes'
      jsdoc-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.jsdoc
      jsdoc-type-name:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(arg|argument|class|constant|constructor|constructs|const|con|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        comment: '@tag {optional type} name'
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - include: '#jsdoc-name-scopes'
      jsdoc-type-noname:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        comment: '@tag {types}'
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
      jsdoc-typedef-obj:
        begin: '{'
        comment: typedef object
        end: '}|^'
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-primitives'
          - match: \b([$_A-Za-z][$_A-Za-z\d]*)\s*(:)
            captures:
              1: {name: variable.other.readwrite.jsdoc}
          - include: '#jsdoc-namepath-scopes'
          - include: '#jsdoc-typedef-obj'
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-scopes:
        begin: '{'
        end: '}|^'
        name: entity.name.type.instance.jsdoc
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-primitives'
          - include: '#jsdoc-namepath-scopes'
          - include: '#jsdoc-typedef-obj'
  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=^|[\p{S}\p{Po}\p{Pd}\p{Ps}]|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)\s*+(?=<[_\\\p{L}\p{Nl}]|<\s*>)
        end: (?=.)
        patterns:
          - include: '#jsx-tag-element-name'
    repository:
      jsx-assignment:
        patterns:
          - comment: look for attribute assignment
            match: '=(?=\s*(?:''|"|{|/\*|<|//|\n))'
            name: keyword.operator.assignment.jsx
      jsx-attribute-name:
        patterns:
          - comment: look for attribute name
            match: (?<!\S)([_\\\p{L}](?:[_\\\p{L}\p{M}\p{N}](?<!\.\.))*+)(?<!\.)(?=//|/\*|=|\s|>|/>)
            captures:
              0: {name: entity.other.attribute-name.jsx}
      jsx-entities:
        patterns:
          - comment: Embeded HTML entities &blah
            match: (&)([a-zA-Z\d]+|#[\d]+|#x\h+)(;)
            captures:
              0: {name: constant.character.entity.jsx}
              1: {name: punctuation.definition.entity.jsx}
              2: {name: entity.name.tag.html.jsx}
              3: {name: punctuation.definition.entity.jsx}
          - comment: Entity with & and invalid name
            match: '&\s*+;'
            name: invalid.illegal.bad-ampersand.jsx
      jsx-evaluated-code:
        patterns:
          - begin: '{'
            contentName: source.somra
            end: '}'
            name: meta.embedded.expression.somra
            beginCaptures:
              0: {name: punctuation.section.embedded.begin.jsx}
            endCaptures:
              0: {name: punctuation.section.embedded.end.jsx}
            patterns:
              - include: '#string'
              - include: '#jsx-spread-attribute'
              - include: '#core'
      jsx-spread-attribute:
        patterns:
          - comment: Spread attribute { ... AssignmentExpression }
            match: (?<![\#\.])\.\.\.
            name: keyword.operator.spread.jsx
      jsx-string-double-quoted:
        begin: '"'
        end: '"(?<!\\")'
        name: string.quoted.double.somra
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
          - include: '#jsx-entities'
      jsx-string-single-quoted:
        begin: ''''
        end: '''(?<!\\'')'
        name: string.quoted.single.somra
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
          - include: '#jsx-entities'
      jsx-tag-attributes:
        patterns:
          - include: '#jsx-attribute-name'
          - include: '#jsx-assignment'
          - include: '#jsx-string-double-quoted'
          - include: '#jsx-string-single-quoted'
          - include: '#jsx-evaluated-code'
          - include: '#jsx-tag-element-name'
          - include: '#comments'
      jsx-tag-element-name:
        patterns:
          - begin: \s*+(<)\s*(?=>)
            comment: JSX Fragment
            contentName: JSXAttrs
            end: (?<=</)(>)
            name: meta.tag.jsx
            beginCaptures:
              1: {name: punctuation.definition.tag.jsx}
            endCaptures:
              1: {name: punctuation.definition.tag.jsx}
            patterns:
              - include: '#jsx-tag-termination'
          - begin: \s*+(<)((\p{Ll}[\p{Ll}\p{N}]*)|((?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*?:)?+(?:[_\\\p{L}\p{Nl}](?:[_\\\p{L}\p{M}\p{N}.:](?<!\.\.))*+)+))(?=[/>\s])(?![:])(?<!\.|:)
            comment: 'Tags that end > are trapped in #jsx-tag-termination'
            contentName: JSXAttrs
            end: \s*(?<=</)((\4)|\2)(>)|(/>)|((?<=</)[\S ]*?)>
            name: meta.tag.jsx
            beginCaptures:
              1: {name: punctuation.definition.tag.jsx}
              2: {name: entity.name.tag.open.jsx}
              4: {name: support.class.component.open.jsx}
            endCaptures:
              1: {name: entity.name.tag.close.jsx}
              2: {name: support.class.component.close.jsx}
              3: {name: punctuation.definition.tag.jsx}
              4: {name: punctuation.definition.tag.jsx}
              5: {name: invalid.illegal.termination.jsx}
            patterns:
              - include: '#jsx-tag-termination'
              - include: '#jsx-tag-attributes'
      jsx-tag-termination:
        patterns:
          - begin: (>)
            comment: uses non consuming search for </ in </tag>
            contentName: JSXNested
            end: (</)
            beginCaptures:
              0: {name: punctuation.definition.tag.jsx}
              1: {name: JSXStartTagEnd}
            endCaptures:
              0: {name: punctuation.definition.tag.jsx}
              1: {name: JSXEndTagStart}
            patterns:
              - include: text.html.markdown#inline
              - include: '#jsx-evaluated-code'
              - include: '#jsx-entities'
              - include: '#jsx-tag-element-name'
  keyword-storage:
    patterns:
      - begin: (?<![\#\.])\s*+\b(const|con|let|var|val)\b
        end: (?=\s*[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*:\s*($|\b(do|for|while)\b))|\s*(?=;|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.somra}
        patterns:
          - include: '#typed-variable'
  keywords:
    patterns:
      - include: '#new'
      - include: '#query'
      - begin: (?<![\#\.])\s*+\b(halt|skip|break|continue|goto|label)\b
        end: ^\s*|\s*(?=,|;|:|//|$|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)
        beginCaptures:
          1: {name: keyword.control.loop.somra}
        patterns:
          - include: '#comments'
          - include: '#keywords'
          - include: '#modifiers'
          - match: \s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*
            captures:
              1: {name: constant.other.label.somra}
      - comment: Keyword operators
        match: |-
          (?x)(?<![\#\.])\s*+\b(?:
            (in|of|as|void|new|(?:type|name|key|size)of|infer) #1
            |(size)|(len)|(del)|(is)|(to|til|by)|(then) #2-7
            # |(n?and|x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|
            # not(of|in)?|(is)no?t)#8-11
          )\b
        captures:
          1: {name: keyword.operator.expression.$1.somra}
          2: {name: keyword.operator.expression.sizeof.somra}
          3: {name: keyword.operator.expression.length.somra}
          4: {name: keyword.operator.expression.delete.somra}
          5: {name: keyword.operator.expression.instanceof.somra}
          6: {name: keyword.operator.expression.range.somra}
          7: {name: keyword.control.then.somra}
          8: {name: keyword.other.logical.somra}
          9: {name: keyword.operator.$9.somra}
          10: {name: keyword.operator.instanceof.somra}
      - comment: Control flow keywords
        match: |-
          (?x)(?<![\#\.])\s*+\b(?:
            (if|else|els?if|ell?ess?|unless?|guard)|(for|while|until|repeat)| #1,2
            (switch|case|def)|(match|when|pass)| #3,4
            (try|throw|raise|catch|rescue|finally)|(with|as)| #5,6
            (defn?|func?|fn|macro|proc)|(let|va[rl]|con|const)| #7,8
            (ref|out|begin|end|show|hide)| #9
            (do|goto|label|await|return|fallthru|yield|halt|skip)| #10
            (from|where|join|equals|[io]nto|order|take|drop|fold|scan|group)| #11
            ((?:im|ex)port|use|using|open|close|show|hide)| #12
            (debug|check|assert) #13
          )\b
        captures:
          1: {name: keyword.control.conditional.somra}
          2: {name: keyword.control.loop.somra}
          3: {name: keyword.control.switch.somra}
          4: {name: keyword.control.match.somra}
          5: {name: keyword.control.trycatch.somra}
          6: {name: keyword.control.with.somra}
          7: {name: storage.type.function.somra}
          8: {name: storage.type.somra}
          9: {name: keyword.control.somra}
          10: {name: keyword.control.flow.somra}
          11: {name: keyword.query.somra}
          12: {name: keyword.control.module.somra}
          13: {name: keyword.other.$13.somra}
  labels:
    patterns:
      - comment: string as a property name
        match: (?<!\.|\?)\s*+(((")(\\.|[^\\"])*("))|((')(\\.|[^\\'])*(')))\s*+(:)((?=::)|(?![:<=>]))
        name: meta.object.member.somra meta.object-literal.key.somra
        captures:
          1: {name: constant.other.object.key.somra}
          2: {name: string.quoted.double.somra, patterns: [{include: '#string-content'}]}
          3: {name: punctuation.definition.string.begin.somra}
          5: {name: punctuation.definition.string.end.somra}
          6: {name: string.quoted.single.somra, patterns: [{include: '#string-content'}]}
          7: {name: punctuation.definition.string.begin.somra}
          9: {name: punctuation.definition.string.end.somra}
          10: {name: punctuation.separator.key-value.somra}
      - begin: (?<!\.|\?)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+:\s*+[\S&&[^:]])
        comment: '[some expression] : as  property name'
        end: \s*(:)((?=::)|(?![:<=>]))
        name: meta.object.member.somra meta.object-literal.key.somra
        endCaptures:
          1: {name: punctuation.separator.key-value.somra}
        patterns:
          - include: '#core'
      - include: '#js-label'
      - match: (?<!\.|\?)\s*+(([_\\\p{L}\p{M}\p{N}]*))\s*+(:)((?=::)|(?![:<=>]))
        name: meta.object.member.somra meta.object-literal.key.somra
        captures:
          1: {name: constant.other.object.key.somra, patterns: [{include: '#number'}]}
          2: {name: string.unquoted.somra}
          3: {name: punctuation.separator.key-value.somra}
  language-constant:
    patterns:
      - match: (?i)(?<![\#\.])\s*+\b((true|yes|on)|(false|no|off)|(null|nil|none)|(undefined|undef)|(nan)|(inf|infin|infinity))\b
        captures:
          2: {name: constant.language.boolean.true.somra}
          3: {name: constant.language.boolean.false.somra}
          4: {name: constant.language.null.somra}
          5: {name: constant.language.undefined.somra}
          6: {name: constant.language.nan.somra}
          7: {name: constant.language.infinity.somra}
  language-variable:
    patterns:
      - match: (?<!(?<!\.\.)\.)\s*+\b(params|args)\b
        captures:
          1: {name: variable.language.arguments.somra}
      - match: (?<!(?<!\.\.)\.)\s*+\b(super)\b\s*+(?!\()
        captures:
          1: {name: variable.language.super.somra}
      - match: (?<!(?<!\.\.)\.)\s*+\b(this)\b
        captures:
          1: {name: variable.language.this.somra}
      - match: (?<!(?<!\.\.)\.)\s*+\b(self)\b\s*+(?!\()
        captures:
          1: {name: variable.language.self.somra}
      - match: (?<=\.)\s*+\b(\\proto)\b
        captures:
          1: {name: variable.language.proto.somra}
      - match: (?<=\.)\s*+\b(ctor)\b\s*+(?!\()
        captures:
          1: {name: variable.language.constructor.somra}
      - match: (?<=\.)\s*+\b(proto)\b
        captures:
          1: {name: variable.language.prototype.somra}
      - match: |-
          (?x)(?<![\#\.])\s*+\b(?:
            (params|args)|(super|this|self|proto)|(\\proto|main)|(ctor)|(targ)|(len|size)
          )\b
        captures:
          1: {name: variable.language.arguments.somra}
          2: {name: variable.language.$2.somra}
          3: {name: variable.language.prototype.somra}
          4: {name: variable.language.constructor.somra}
          5: {name: variable.language.target.somra}
          6: {name: variable.language.length.somra}
  method:
    patterns:
      - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(\#?)(?!\bstatic\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\())
        comment: 'e.g. play<T,T>(arg1, arg2): Type<T> { }'
        end: (?={|;|}|,|=)
        beginCaptures:
          1: {name: storage.modifier.somra}
          2: {name: storage.type.somra}
          3: {name: keyword.generator.asterisk.somra}
          4: {name: keyword.operator.private.somra}
          5: {name: entity.name.function.method.somra, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#curly-brackets'
          - include: '#core'
          - include: $self
      - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(('|")([^"']*)(\k<-3>))(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
        comment: 'e.g. ''play''<T,T>(arg1, arg2): Type<T> { }'
        end: (?={|;|}|,|=)
        beginCaptures:
          1: {name: storage.modifier.somra}
          2: {name: storage.type.somra}
          3: {name: keyword.generator.asterisk.somra}
          4: {name: entity.name.function.method.somra, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#curly-brackets'
          - include: '#core'
          - include: $self
      - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\]))\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\())
        comment: 'e.g. [expression]<T,T>(arg1, arg2): Type<T> { } or ''text''<T,T>(arg1, arg2)'
        end: (?={|;|}|,|=)
        beginCaptures:
          1: {name: storage.modifier.somra}
          2: {name: storage.type.somra}
          3: {name: keyword.generator.asterisk.somra}
          4: {name: entity.name.function.method.somra, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#square-brackets'
          - include: '#curly-brackets'
          - include: '#core'
          - include: $self
      - begin: (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s++(\#?)(?!\bstatic\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*+\()
        comment: getter/setter
        end: (?={|;|}|,|=)
        beginCaptures:
          1: {name: storage.modifier.somra}
          2: {name: storage.type.accessor.somra}
          3: {name: keyword.operator.private.somra}
          4: {name: entity.name.function.accessor.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#types'
          - include: '#curly-brackets'
          - include: '#core'
          - include: $self
      - begin: (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(((')((?:[^']|\\')*)('))|\s*+((")((?:[^"]|\\")*)("))))\s*+(\())
        comment: getter/setter set [expression]() or get 'text'()
        end: (?={|;|}|,|=)
        beginCaptures:
          1: {name: storage.modifier.somra}
          2: {name: storage.type.accessor.somra}
          3: {name: entity.name.function.accessor.somra}
        endCaptures:
          1: {name: keyword.operator.assignment.somra}
        patterns:
          - include: '#typed-parse-array'
          - include: '#string'
          - include: '#types'
          - include: '#square-brackets'
          - include: '#core'
          - include: $self
  method-call:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g CONSTNAME.method() or CONST.method[p]()
        end: (?=.)
        name: meta.method-call.without-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.constant.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: keyword.operator.assertion.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {name: keyword.operator.private.somra}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g Abc.aaa()
        end: (?=.)
        name: meta.method-call.without-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.assertion.somra}
          5: {name: keyword.operator.cascade.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {name: keyword.operator.private.somra}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g CONSTNAME.method()
        end: (?=.)
        name: meta.method-call.with-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.constant.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.assertion.somra}
          5: {name: keyword.operator.cascade.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {name: keyword.operator.private.somra}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g Abc.aaa()
        end: (?=.)
        name: meta.method-call.with-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.assertion.somra}
          5: {name: keyword.operator.cascade.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {name: keyword.operator.private.somra}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#round-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g .aaa()
        end: (?=.)
        name: meta.method-call.without-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#method-name'}]}
          3: {name: meta.group.braces.round.function.arguments.somra}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g .aaa()
        end: (?=.)
        name: meta.method-call.with-arguments.somra
        beginCaptures:
          1: {name: keyword.operator.private.somra}
          2: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
  method-name:
    patterns:
      - include: '#support-methods'
      - match: (([a-zA-Z])[_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.method.$2.somra
      - match: ([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.method.somra
  modifiers:
    patterns:
      - comment: Modifier keywords - activated when only next to each other
        match: |-
          (?x)(?<![\#\.])\s*+\b(?:
            (pub|prot|pvt|ronly|(?:in|ex)tl)| #1
            (over|abs|stat|dyn|vol|a?sync|(?:im)?mut|part|seal|final|dele|[dr]ef|
            trans|(?:im|ex)pl|ext|(?:un)?(?:sign|safe|check|size))| #2
            (rec|gen|inline|(?:pre|in|suf|)fix|(?:u|bi|ter|)nary|[gs]et|
            prev|next|lock|fixed|lazy|eager|greedy|unique|handle)| #3
            (n?and|x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|
            not(of|in)?|(is)no?t) #4
          )\s*+(?=\b
            (\s*\b(pub|prot|pvt|ronly|(?:in|ex)tl|over|abs|stat|dyn|vol|a?sync|(?:im)?mut|part|seal|final|dele|[dr]ef|trans|(?:im|ex)pl|ext|(?:un)?(?:sign|safe|check|size)|rec|gen|inline|(?:pre|in|suf|)fix|(?:u|bi|ter|)nary|[gs]et|prev|next|lock|fixed|lazy|eager|greedy|unique|handle|n?and|x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|
            not(of|in)?|(is)no?t)\b\s*)*\s*\b
            (ext|impl|only|class|given|constr|enum|extn|extend|frag|inter|
            struct|data|schema|module|nspace|object|record|raw|style|trait|
            defn?|func?|fn|proc|macro|con|va[rl]|let|const)\b
          )
        captures:
          1: {name: storage.modifier.somra}
          2: {name: keyword.modifier.somra}
          3: {name: storage.type.accessor.somra}
          4: {name: keyword.other.logical.somra}
          5: {name: keyword.operator.$5.somra}
          6: {name: keyword.operator.instanceof.somra}
      - comment: Type alias keywords
        match: |-
          (?x)(?<![\#\.])\s*+\b(?:
            (class|enum|module|object|raw|style)
            |(given|constr)
            |(enum)
            |(extend|extn)
            |(frag)
            |(inter|struct)
            |(module)
            |(nspace)
            |(object|record)
            |(raw)
            |(data|schema)
            |(style)
            |(trait)
            #|(opaque|type)
          )\b
        captures:
          1: {name: storage.type.$1.somra}
          2: {name: storage.type.constraint.somra}
          3: {name: storage.type.enum.somra}
          4: {name: storage.type.extension.somra}
          5: {name: storage.type.fragment.somra}
          6: {name: storage.type.interface.somra}
          7: {name: storage.type.module.somra}
          8: {name: storage.type.namespace.somra}
          9: {name: storage.type.object.somra}
          10: {name: storage.type.raw.somra}
          11: {name: storage.type.schema.somra}
          12: {name: storage.type.style.somra}
          13: {name: storage.type.trait.somra}
          14: {name: keyword.other.typedef.somra}
  module:
    begin: (?<![\#\.])\s*+\b(from|import|export|open|close|use|using)\b\s*
    comment: from ... import
    end: (?=;|\p{Pe}|$)
    beginCaptures:
      1: {name: keyword.control.module.somra}
    patterns:
      - match: (?<![\#\.])\s*+\b(from|import|export|open|close|as|def|use|using|show|hide)\b\s*
        name: keyword.control.module.somra
      - match: \s*\*
        name: keyword.operator.module.all.somra
      - begin: \s*+(('))
        contentName: string.quoted.module.somra
        end: |-
          \s*+(?:(('))|(
          ))
        beginCaptures:
          1: {name: string.quoted.module.somra}
          2: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: string.quoted.module.somra}
          2: {name: punctuation.definition.string.end.somra}
          3: {name: invalid.illegal.newline.somra}
        patterns:
          - include: '#string-content'
      - begin: \s*+(("))
        contentName: string.quoted.module.somra
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.module.somra}
          2: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: string.quoted.module.somra}
          2: {name: punctuation.definition.string.end.somra}
          3: {name: invalid.illegal.newline.somra}
        patterns:
          - include: '#string-content'
      - include: '#keyword-storage'
      - include: '#typed-keywords'
      - include: '#typed-parse-types'
      - include: '#operator'
      - include: '#operators'
      - include: '#punctuation'
  module-as:
    match: \s*+(?:(\*)|(\bdef\b))?\s*+(\bas\b)\s*+(?:(\*)|(\bdef\b))?
    captures:
      1: {name: keyword.operator.module.all.somra}
      2: {name: keyword.control.module.somra}
      3: {name: keyword.control.module.reference.somra}
      4: {name: keyword.operator.module.all.somra}
      5: {name: keyword.control.module.somra}
  module-brackets:
    patterns:
      - begin: \s*+(?:({)|(\[))
        end: \s*(?:(\})|(\]))
        beginCaptures:
          1: {name: meta.brace.curly.somra}
          2: {name: meta.brace.square.somra}
        endCaptures:
          1: {name: meta.brace.curly.somra}
          2: {name: meta.brace.square.somra}
        patterns:
          - match: \*
            name: keyword.operator.module.all.somra
          - include: '#module-typeof'
          - include: '#module-as'
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#string'
          - include: '#comments'
          - include: '#comma'
  module-export:
    patterns:
      - comment: e.g. export let variable =, export type a=
        match: (?<![\#\.])\s*+\b(export)(?!\s*:)\b(?=\s++(const|con|let|opaque|va[rl]|type|typeof)\s++(?:[_\\p{L}\p{Nl}]))
        captures:
          1: {name: keyword.control.module.somra}
      - begin: (?<![\#\.])\s*+\b(export)\b\s*(\btype\b)?(?=\s++({|\*|((?:[_\\p{L}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(\s++from\b|\s*,)))
        comment: export {  or  export * or export var or export type {} from module
        end: \s*(?:(?:(\bfrom\b)?+\s++(('|")([^"']*)(\k<-3>)))|(?=;|^\s*\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|}))
        beginCaptures:
          1: {name: keyword.control.module.somra}
          2: {name: keyword.control.module.somra}
        endCaptures:
          1: {name: keyword.control.module.somra}
          2: {name: string.quoted.module.somra}
          3: {name: punctuation.definition.string.begin.somra}
          5: {name: punctuation.definition.string.end.somra}
        patterns:
          - include: '#module-as'
          - match: \s*\*
            name: keyword.operator.module.all.somra
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#comments'
          - include: '#comma'
      - comment: trap expressions among - export function* () {}
        match: (?<![\#\.])\s*+\b(export|default)(?!\s*:)\b
        captures:
          1: {name: keyword.control.module.somra}
  module-import:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(import)(?=\()
        end: (?=.)
        name: meta.function-call.with-arguments.somra
        beginCaptures:
          1: {name: keyword.control.module.somra}
        patterns:
          - include: '#round-brackets'
      - begin: (?<![\#\.])\s*+\b(import)(?!\s*:)\b
        end: \s*(?:(?:(\bfrom\b)?+\s++(('|")([^"']*)(\k<-3>)))|(?=;|^\s*\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|}))
        beginCaptures:
          1: {name: keyword.control.module.somra}
        endCaptures:
          1: {name: keyword.control.module.somra}
          2: {name: string.quoted.module.somra}
          3: {name: punctuation.definition.string.begin.somra}
          5: {name: punctuation.definition.string.end.somra}
        patterns:
          - match: \s*\b(default)\b
            captures:
              1: {name: keyword.control.module.somra}
          - include: '#module-typeof'
          - include: '#module-as'
          - match: \s*\*
            name: keyword.operator.module.all.somra
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#comments'
          - include: '#comma'
  module-typeof:
    match: \s*\b(typeof|type)\b\s++(?={|\*|(?:[_\\p{L}\p{Nl}]))(?!\b(i[sn]|as)\b|,)
    captures:
      1: {name: keyword.other.typedef.somra}
  multiline-arrow-function-generics:
    patterns:
      - begin: \s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?+\s*+\(\s*$)
        comment: e.g. export default async <T>(
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.somra
        beginCaptures:
          1: {name: storage.type.somra}
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
      - begin: \s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*+>)\()
        comment: e.g. export default <T>(
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.somra
        endCaptures:
          2: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#types'
          - include: '#fat-arrow-braced-body'
  new:
    - comment: A new expression with no type params or arguments, like new Foo()
      match: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?(\()\s*+(\)))
      name: meta.new-class.without-arguments.somra
      captures:
        1: {name: keyword.operator.new.somra}
        2: {name: meta.function-call.without-arguments.somra}
        3: {name: keyword.operator.private.somra}
        4: {name: entity.name.type.instance.somra}
        5: {name: keyword.operator.existential.somra}
        6: {name: meta.brace.round.somra}
        7: {name: meta.brace.round.somra}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
      comment: A new expression with type params and no arguments, like new Foo<string>()
      end: (?=.)
      name: meta.new-class.without-arguments.somra
      beginCaptures:
        1: {name: keyword.operator.new.somra}
        2: {name: meta.function-call.without-arguments.somra}
        3: {name: keyword.operator.private.somra}
        4: {name: entity.name.type.instance.somra}
        5: {name: keyword.operator.existential.somra}
      patterns:
        - include: '#type-argument-brackets'
        - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
      comment: A new expression with arguments and maybe type params, like new Foo<string>(123)
      end: (?=.)
      name: meta.new-class.with-arguments.somra
      beginCaptures:
        1: {name: keyword.operator.new.somra}
        2: {name: meta.function-call.with-arguments.somra}
        3: {name: keyword.operator.private.somra}
        4: {name: entity.name.type.instance.somra}
        5: {name: keyword.operator.existential.somra}
      patterns:
        - include: '#type-argument-brackets'
        - include: '#round-brackets'
  number:
    comments: Generated numeric literals
    patterns:
      - match: (?<=[\htx])\.
        name: meta.delimiter.decimal.period
      - match: \.(?=\d)
        name: meta.delimiter.decimal.period
      - match: |-
          (?xi)\s*\b
          0b
          (?:[01] [01_]* [01]?)?
          (?:(\.) [01] [01_]* [01]?)
          (?:(r) [01] [01_]* [01]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.binary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0b
          [01] [01_]* [01]?
          (?:(\.) [01] [01_]* [01]?)?
          (?:(r) [01] [01_]* [01]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.binary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0q
          (?:[0-3] [0-3_]* [0-3]?)?
          (?:(\.) [0-3] [0-3_]* [0-3]?)
          (?:(r) [0-3] [0-3_]* [0-3]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.quaternary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0q
          [0-3] [0-3_]* [0-3]?
          (?:(\.) [0-3] [0-3_]* [0-3]?)?
          (?:(r) [0-3] [0-3_]* [0-3]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.quaternary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0s
          (?:[0-5] [0-5_]* [0-5]?)?
          (?:(\.) [0-5] [0-5_]* [0-5]?)
          (?:(r) [0-5] [0-5_]* [0-5]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.senary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0s
          [0-5] [0-5_]* [0-5]?
          (?:(\.) [0-5] [0-5_]* [0-5]?)?
          (?:(r) [0-5] [0-5_]* [0-5]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.senary.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0o
          (?:[0-7] [0-7_]* [0-7]?)?
          (?:(\.) [0-7] [0-7_]* [0-7]?)
          (?:(r) [0-7] [0-7_]* [0-7]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.octal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0o
          [0-7] [0-7_]* [0-7]?
          (?:(\.) [0-7] [0-7_]* [0-7]?)?
          (?:(r) [0-7] [0-7_]* [0-7]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.octal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0z
          (?:[\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)
          (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.duodecimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0z
          [\dabetxz] [\dabetxz_]* [\dabetxz]?
          (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.duodecimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0x
          (?:\h [\h_]* \h?)?
          (?:(\.) \h [\h_]* \h?)
          (?:(r) \h [\h_]* \h?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.hexadecimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          0x
          \h [\h_]* \h?
          (?:(\.) \h [\h_]* \h?)?
          (?:(r) \h [\h_]* \h?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.hexadecimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          (?:\d [\d_]* \d?)?
          (?:(\.) \d [\d_]* \d?)
          (?:(r) \d [\d_]* \d?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.decimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          \d [\d_]* \d?
          (?:(\.) \d [\d_]* \d?)?
          (?:(r) \d [\d_]* \d?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.decimal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          \d\w
          (?:\w [\w_]* \w?)?
          (?:(\.) \w [\w_]* \w?)
          (?:(r) \w [\w_]* \w?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.illegal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
      - match: |-
          (?xi)\s*\b
          \d\w
          \w [\w_]* \w?
          (?:(\.) \w [\w_]* \w?)?
          (?:(r) \w [\w_]* \w?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
          \b
        captures:
          0: {name: constant.numeric.illegal.somra}
          1: {name: meta.delimiter.decimal.period.somra}
          2: {name: storage.type.numeric.bigint.somra}
          3: {name: storage.type.numeric.bigint.somra}
          4: {name: storage.type.numeric.bigint.somra}
          5: {name: storage.type.numeric.bigint.somra}
  object:
    begin: (?:(?<=\(|\[|,)|(?:\s*(?:(=)|\b(default)\b|\b(return)\b|(,))))\s*({)
    comment: obj lteral ({ or ,{ or [{ or ={ or return { or default {
    end: \s*+(})
    beginCaptures:
      1: {name: keyword.operator.assignment.somra}
      2: {name: keyword.control.module.somra}
      3: {name: keyword.control.flow.somra}
      4: {name: meta.delimiter.comma.somra}
      5: {name: meta.brace.curly.litobj.somra}
    endCaptures:
      1: {name: meta.brace.curly.litobj.somra}
    patterns:
      - include: '#object-body'
  object-body:
    patterns:
      - include: '#typed-keywords'
      - include: languagebabel.ttlextension
      - include: '#html-template'
      - include: '#object-brace-property'
      - include: '#function-labels'
      - include: '#arrow-function-labels'
      - include: '#arrow-function'
      - include: '#method'
      - include: '#arrow-expression'
      - include: '#object-prop-shorthand'
      - include: '#labels'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#core'
      - include: '#punctuation'
  object-brace:
    begin: \s*({)
    comment: nested obj literal found inside other objects like arrays
    end: \s*+(})
    beginCaptures:
      1: {name: meta.brace.curly.litobj.somra}
    endCaptures:
      1: {name: meta.brace.curly.litobj.somra}
    patterns:
      - include: '#object-body'
  object-brace-property:
    begin: (?<=:)\s*({)
    comment: 'nested obj literal key: {object}'
    end: \s*+(})
    beginCaptures:
      1: {name: meta.brace.curly.litobj.somra}
    endCaptures:
      1: {name: meta.brace.curly.litobj.somra}
    patterns:
      - include: '#object-body'
  object-prop-shorthand:
    comment: give an alternate scope name to shorthand object literals
    patterns:
      - match: (?<=^|,|{)(?<!:|\.)\s*+(((?:[_\\p{Lu}\p{Nl}])(?:[_\\p{Lu}\p{Nl}])*+))\s*+(?=$|,|})
        captures:
          1: {name: constant.other.object.key.somra}
          2: {name: variable.other.constant.shorthandpropertyname.somra}
      - match: (?<=^|,|{)(?<!:|\.)\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*+(?=$|,|})
        captures:
          1: {name: variable.other.readwrite.shorthandpropertyname.somra}
  operator:
    repository: 
      - begin: \s*(:\?[<=>]?|:(?![:<=>]))\s*
        comment: Type assertion/conversion/coercion/casting operator
        end: |-
          (?x)(?==(?![=>])|[\p{Pe}\p{Po}\p{Pd}\p{S}&&[^<=>&|^~!?]]|\s*\b
          (in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|
          to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|
          until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|
          rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|
          do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|
          from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|
          select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|
          hide|debug|check|assert)\b|$)
        beginCaptures:
          1: {name: keyword.operator.type.somra}
        patterns:
          - include: '#typed-parse-types'
      - match: \s*(\.=|::?=)(?![<~>=])\s*
        name: keyword.operator.assignment.somra
    patterns:
      - match: \s*(\.\.[.=]?|[.=]\.[.=])\s*
        name: keyword.operator.range.somra
      - match: \s*(/\\)|(\\/)\s*
        name: keyword.operator.logical.somra
      - match: \s*(?:(::+)|([<>][:!]+|[:!]+[<>]|[<>][:!]+[<>]))\s*
        captures:
          1: {name: keyword.operator.accessor.somra}
          2: {name: keyword.operator.class.somra}
          3: {name: keyword.operator.accessor.somra}
      - match: \s*\\\s*($|(?=/[/*]))
        name: constant.character.escape.newline.somra
      - match: \s*(<-+|-+>)\s*
        name: keyword.operator.then.somra
  operators:
    patterns:
      - include: '#unary-ops'
      - include: '#binary-ops'
      - include: '#special-operators'
    repository:
      binary-ops:
        patterns:
          - comment: built-in operators need to be surrounded with spaces
            match: |-
              (?x)(?<=^|\p{Ps}|\p{Z})(?:
                ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![!~<=>])=) #1
                |(\+\++|--+) #2
                |(\+|-(?!>)|\*{1,3}|(?<!<)/(?!>)|\#|~/(?!>)|%%?|\*>|<\*) #3
                |(&&|\|\||\^\^|\\/|/\\) #4
                |([&^]|\|(?!>)|~(?![!=<>])) #5
                |(=\.\.|\.\.=|=\.=|\.\.(?!\.)) #6
                |(<[|+]|[|+]>)|(<<+|>>+) #7-8
                |([<>]:|:[<>]|[<>]:[<>]) #9
                |([!=~]+~|~[!=~]+|[<~>]+~|~[<~>]+) #10
                |(->|<-)|(<=>|[<>]=?)|(=[!:]=|[!=]==?) #11-13
                |(!\?|\?!|!!)|(\?\??)|(\?:)|(!:)|(\.\.\.) #14-18
                |(\?\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}?])\?(?![.:])(?=\B)) #19
                |(!\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}!])\!(?![.:])(?=\B)) #20
                |(~\.)|((?<!(?<!\.\.)\.)\.(?!=)|:::?)|((?:\.|::?)?=) #21-23
                |(=<|<[/*+]?>) #24
              )(?=$|\p{Pe}|\p{Z})
            name: keyword.operator.builtin.somra
            captures:
              1: {name: keyword.operator.assignment.augmented.somra}
              2: {name: keyword.operator.crement.somra}
              3: {name: keyword.operator.arithmetic.somra}
              4: {name: keyword.operator.logical.somra}
              5: {name: keyword.operator.bitwise.somra}
              6: {name: keyword.operator.range.somra}
              7: {name: keyword.operator.pipeline.somra}
              8: {name: keyword.operator.bitwise.shift.somra}
              9: {name: keyword.operator.class.somra}
              10: {name: keyword.operator.similarity.somra}
              11: {name: keyword.operator.then.somra}
              12: {name: keyword.operator.relational.somra}
              13: {name: keyword.operator.comparison.somra}
              14: {name: keyword.operator.nonnull.somra}
              15: {name: keyword.operator.nullcoalesce.somra}
              16: {name: keyword.operator.ternary.somra}
              17: {name: keyword.operator.quasiternary.somra}
              18: {name: keyword.operator.spread.somra}
              19: {name: keyword.operator.existential.somra}
              20: {name: keyword.operator.assertion.somra}
              21: {name: keyword.operator.cascade.somra}
              22: {name: keyword.operator.accessor.somra}
              23: {name: keyword.operator.assignment.somra}
              24: {name: keyword.operator.regexp.somra}
          - comment: |-
              custom operators
              (#7) /(<//+>|<//+|//+>|<{2,}|(?<!</)>{2,}|/+)(?!=)/ does not work
              so we will leave it here for now (please help)
            match: |-
              (?x)
              ([&|^~][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #1
              ([-+*%/\#][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #2
              ([:.][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #3
              ([<>][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #4
              ([!=][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #5
              (\?[\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #6
              (\s+[\p{Sm}&&[\x{80}-\x{10FFFF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*\s+)| #7
              ([\p{Sc}&&[^$]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #8
              ([\p{S}\p{Po}\p{Pd}&&[\x{80}-\x{FF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #9
              ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>])) #10
            name: keyword.operator.infix.somra
            captures:
              1: {name: keyword.operator.logical.somra}
              2: {name: keyword.operator.arithmetic.somra}
              3: {name: keyword.operator.accessor.somra}
              4: {name: keyword.operator.relational.somra}
              5: {name: keyword.operator.comparison.somra}
              6: {name: keyword.operator.existential.somra}
              7: {name: keyword.operator.math.somra}
              8: {name: keyword.operator.currency.somra}
              9: {name: keyword.operator.ascii.somra}
              10: {name: keyword.operator.infix.somra}
      special-operators:
        patterns:
          - include: '#esnext-pipeline'
          - begin: \s*((:\?[<=>]?))\s*
            comment: Type assertion/conversion/coercion/casting operator
            end: (?=[^&|^~<>!?\p{L}\p{N}\p{Sc}\[\]{}_])
            beginCaptures:
              1: {name: keyword.operator.type.somra}
            endCaptures:
              1: {patterns: [{include: '#core'}]}
            patterns:
              - include: '#typed-parse-types'
          - begin: \s*+(\?)(?!\.[^\d]|[?=])(?=\s)
            comment: 'ternary operator - make sure end : is consumed to avoid mistake as flow type'
            end: \s*(:)((?=::)|(?!:|=))
            beginCaptures:
              1: {name: keyword.operator.ternary.somra}
            endCaptures:
              1: {name: keyword.operator.ternary.somra}
            patterns:
              - begin: \s*+(?=([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*:)
                end: \s*(?=:)
                patterns:
                  - include: '#language-constant'
                  - include: '#variable'
              - include: '#core'
          - begin: \s*+(\!)(?!\.[^\d]|[?=])(?=\s)
            comment: 'ternary operator - make sure end : is consumed to avoid mistake as flow type'
            end: \s*(:)((?=::)|(?!:|=))
            beginCaptures:
              1: {name: keyword.operator.quasiternary.somra}
            endCaptures:
              1: {name: keyword.operator.quasiternary.somra}
            patterns:
              - begin: \s*+(?=([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*:)
                end: \s*(?=:)
                patterns:
                  - include: '#language-constant'
                  - include: '#variable'
              - include: '#core'
          - begin: (\$)\s*
            end: \s*(\$)
            name: keyword.operator.function.somra
            beginCaptures:
              1: {name: keyword.operator.function.somra}
            endCaptures:
              1: {name: keyword.operator.function.somra}
            patterns:
              - include: '#function-name'
              - include: '#method-name'
              - include: '#core'
      unary-ops:
        patterns:
          - match: (?:(\?\.)|(~\.)|(!\.)|(\.))
            captures:
              1: {name: keyword.operator.existential.somra}
              2: {name: keyword.operator.cascade.somra}
              3: {name: keyword.operator.assertion.somra}
              4: {name: keyword.operator.accessor.somra}
          - comment: Unary prefix operators
            match: |-
              (?x)
              (?:(\*) #1
              |(\+) #2
              |(\-) #3
              |(\&) #4
              |(\|) #5
              |(\^) #6
              |(\!) #7
              |(\#) #8
              |(\@) #9
              |(\~) #10
              |(\?) #11
              |[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]) #12
              (?=[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*
              [\p{L}\p{M}\p{N}\p{Ps}\p{Pe}'"`])
            name: keyword.operator.prefix.somra
            captures:
              1: {name: keyword.operator.module.all.somra}
              2: {name: keyword.operator.increment.somra}
              3: {name: keyword.operator.decrement.somra}
              4: {name: keyword.operator.intersection.somra}
              5: {name: keyword.operator.union.somra}
              6: {name: keyword.operator.symdiff.somra}
              7: {name: keyword.operator.logical.somra}
              8: {name: keyword.operator.private.somra}
              9: {name: keyword.operator.decorator.somra}
              10: {name: keyword.operator.bitwise.somra}
              11: {name: keyword.operator.existential.somra}
              12: {name: keyword.operator.prefix.somra}
          - comment: Unary suffix operators
            match: |-
              (?x)
              (?<=[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*
              [\p{L}\p{M}\p{N}\p{Ps}\p{Pe}'"`])
              (?:(\*) #1
              |(\+) #2
              |(\-) #3
              |(\&) #4
              |(\|) #5
              |(\^) #6
              |(\!) #7
              |(\#) #8
              |(\@) #9
              |(\~) #10
              |(\?) #11
              |[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]) #12
            name: keyword.operator.suffix.somra
            captures:
              1: {name: keyword.operator.module.all.somra}
              2: {name: keyword.operator.increment.somra}
              3: {name: keyword.operator.decrement.somra}
              4: {name: keyword.operator.intersection.somra}
              5: {name: keyword.operator.union.somra}
              6: {name: keyword.operator.symdiff.somra}
              7: {name: keyword.operator.assertion.somra}
              8: {name: keyword.operator.private.somra}
              9: {name: keyword.operator.decorator.somra}
              10: {name: keyword.operator.cascade.somra}
              11: {name: keyword.operator.existential.somra}
              12: {name: keyword.operator.suffix.somra}
  preprocessor:
    begin: ^\s*(\#)\s*
    end: (?<=$)
    name: meta.preprocessor.somra
    beginCaptures:
      1: {name: punctuation.separator.hash.somra}
    patterns:
      - include: '#comment'
      - include: '#preprocessor-define-or-undef'
      - include: '#preprocessor-if-or-elif'
      - include: '#preprocessor-else-or-endif'
      - include: '#preprocessor-warning-or-error'
      - include: '#preprocessor-region'
      - include: '#preprocessor-endregion'
      - include: '#preprocessor-load'
      - include: '#preprocessor-r'
      - include: '#preprocessor-line'
      - include: '#preprocessor-pragma-warning'
      - include: '#preprocessor-pragma-checksum'
  preprocessor-define-or-undef:
    match: \b(?:(define)|(undef))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b
    captures:
      1: {name: keyword.preprocessor.define.somra}
      2: {name: keyword.preprocessor.undef.somra}
      3: {name: entity.name.variable.preprocessor.symbol.somra}
  preprocessor-else-or-endif:
    match: \b(?:(else)|(endif))\b
    captures:
      1: {name: keyword.preprocessor.else.somra}
      2: {name: keyword.preprocessor.endif.somra}
  preprocessor-endregion:
    match: \b(endregion)\b
    captures:
      1: {name: keyword.preprocessor.endregion.somra}
  preprocessor-expression:
    patterns:
      - include: '#core'
  preprocessor-if-or-elif:
    begin: \b(?:(if)|(elif))\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.if.somra}
      2: {name: keyword.preprocessor.elif.somra}
    patterns:
      - include: '#comment'
      - include: '#preprocessor-expression'
  preprocessor-line:
    begin: \b(line)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.line.somra}
    patterns:
      - match: \b(?:(default|hidden))
        captures:
          1: {name: keyword.preprocessor.default.somra}
          2: {name: keyword.preprocessor.hidden.somra}
      - match: '[0-9]+'
        captures:
          0: {name: constant.numeric.decimal.somra}
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.somra}
  preprocessor-load:
    begin: \b(load)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.load.somra}
    patterns:
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.somra}
  preprocessor-pragma-checksum:
    match: \b(pragma)\b\s*\b(checksum)\b\s*(\"[^"]*\")\s*(\"[^"]*\")\s*(\"[^"]*\")
    captures:
      1: {name: keyword.preprocessor.pragma.somra}
      2: {name: keyword.preprocessor.checksum.somra}
      3: {name: string.quoted.double.somra}
      4: {name: string.quoted.double.somra}
      5: {name: string.quoted.double.somra}
  preprocessor-pragma-warning:
    match: \b(pragma)\b\s*\b(warning)\b\s*\b(?:(disable)|(restore))\b(\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
    captures:
      1: {name: keyword.preprocessor.pragma.somra}
      2: {name: keyword.preprocessor.warning.somra}
      3: {name: keyword.preprocessor.disable.somra}
      4: {name: keyword.preprocessor.restore.somra}
      5: {patterns: [{match: '[0-9]+', captures: {0: {name: constant.numeric.decimal.somra}}}, {include: '#punctuation-comma'}]}
  preprocessor-r:
    begin: \b(r)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.r.somra}
    patterns:
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.somra}
  preprocessor-region:
    match: \b(region)\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.region.somra}
      2: {name: string.unquoted.preprocessor.message.somra}
  preprocessor-warning-or-error:
    match: \b(?:(warning)|(error))\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.warning.somra}
      2: {name: keyword.preprocessor.error.somra}
      3: {name: string.unquoted.preprocessor.message.somra}
  prototype:
    patterns:
      - comment: e.g. Sound.prototype
        match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\b
        name: meta.prototype.access.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: variable.language.prototype.somra}
      - comment: e.g. Sound.prototype = { }
        match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\s*+=\s*+
        name: meta.prototype.declaration.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: entity.name.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: variable.language.prototype.somra}
  punctuation:
    patterns:
      - include: '#semi-colon'
      - include: '#comma'
  punctuation-semicolon:
    match: ;
    name: punctuation.terminator.statement.somra
  quasi:
    patterns:
      - include: languagebabel.ttlextension
      - begin: \s*+(?:(?:\b(css|injectGlobal|keyframes|createGlobalStyle|stylesheet)\b)|(?:(\bstyled)(?:(?:(\?\.)|(\.))\s*(\w+)))|(/\* CSS \*/))\s*((`))
        comment: Styled CSS tags
        contentName: source.inside-js.css.styled
        end: \s*((`))
        beginCaptures:
          1: {name: entity.name.tag.styledcss.somra}
          2: {name: entity.name.tag.styledcss.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: entity.name.tag.styledcss.somra}
          6: {name: string.quoted.template.styled.start.somra}
          7: {name: punctuation.definition.quasi.begin.somra}
        endCaptures:
          1: {name: string.quoted.template.styled.end.somra}
          2: {name: punctuation.definition.quasi.end.somra}
        patterns:
          - include: source.css.styled
      - begin: (?<![\#\.])\s*+(?:([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(extend))\s*((`))
        comment: Styled CSS tags
        contentName: source.inside-js.css.styled
        end: \s*((`))
        beginCaptures:
          1: {name: variable.other.class.somra}
          2: {name: keyword.operator.existential.somra}
          3: {name: keyword.operator.accessor.somra}
          4: {name: entity.name.tag.styledcss.somra}
          5: {name: string.quoted.template.styled.start.somra}
          6: {name: punctuation.definition.quasi.begin.somra}
        endCaptures:
          1: {name: string.quoted.template.styled.end.somra}
          2: {name: punctuation.definition.quasi.end.somra}
        patterns:
          - include: source.css.styled
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(?:(\bstyled)|([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(withComponent))(?=\s*((\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))*\s*(`|\.extend`|$)))
        comment: Styled CSS tag functions
        end: (?=.)
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: variable.other.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.somra}
              2: {name: punctuation.definition.quasi.begin.somra}
            endCaptures:
              1: {name: string.quoted.template.styled.end.somra}
              2: {name: punctuation.definition.quasi.end.somra}
            patterns:
              - include: source.css.styled
          - comment: Styled CSS tags
            match: \s*(\.)\s*(extend)(?=\s*`)
            captures:
              1: {name: keyword.operator.accessor.somra}
              2: {name: entity.name.tag.styledcss.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(?:(\bstyled))(?=\s*((\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))*\s*\??\.\s*attrs\s*\())
        comment: Styled CSS tag functions
        end: (?=.)
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - match: \s*(?:(\?\.)|(\.))\s*(attrs)
            captures:
              1: {name: keyword.operator.existential.somra}
              2: {name: keyword.operator.accessor.somra}
              3: {patterns: [{include: '#function-name'}]}
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.somra}
              2: {name: punctuation.definition.quasi.begin.somra}
            endCaptures:
              1: {name: string.quoted.template.styled.end.somra}
              2: {name: punctuation.definition.quasi.end.somra}
            patterns:
              - include: source.css.styled
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(?:(\bstyled)\s*(?:(\?\.)|(\.))\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(attrs|withConfig))(?=\s*\()
        comment: Styled CSS tag functions
        end: (?=.|\n)
        beginCaptures:
          1: {name: entity.name.tag.styledcss.somra}
          2: {name: keyword.operator.existential.somra}
          3: {name: keyword.operator.accessor.somra}
          4: {name: entity.name.tag.styledcss.somra}
          5: {name: keyword.operator.existential.somra}
          6: {name: keyword.operator.accessor.somra}
          7: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.somra}
              2: {name: punctuation.definition.quasi.begin.somra}
            endCaptures:
              1: {name: string.quoted.template.styled.end.somra}
              2: {name: punctuation.definition.quasi.end.somra}
            patterns:
              - include: source.css.styled
      - begin: \s*+(?:((Relay)(?:(\?\.)|(\.))(QL))|(gql|graphql|graphql\.experimental)|(/\* GraphQL \*/))\s*((`))
        comment: GraphQL ( Relay.QL ) supprt. Use two forms of scopes! fixes some themes
        end: \s*((`))
        beginCaptures:
          2: {name: variable.other.class.somra}
          3: {name: keyword.operator.existential.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: entity.name.tag.graphql.somra}
          6: {name: entity.name.tag.graphql.somra}
          7: {name: entity.name.tag.graphql.somra}
          8: {name: string.quoted.template.somra}
          9: {name: punctuation.definition.quasi.begin.somra}
        endCaptures:
          1: {name: string.quoted.template.graphql.somra}
          2: {name: punctuation.definition.quasi.end.somra}
        patterns:
          - include: '#graphql'
      - begin: \s*+(?!\b(?:return|void)\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*((`))
        comment: Use two forms of scopes! fixes some themes
        contentName: string.quoted.template.somra
        end: \s*((`))
        name: string.quasi.somra
        beginCaptures:
          1: {name: entity.name.tag.somra}
          2: {name: string.quoted.template.somra}
          3: {name: punctuation.definition.quasi.begin.somra}
        endCaptures:
          1: {name: string.quoted.template.somra}
          2: {name: punctuation.definition.quasi.end.somra}
        patterns:
          - include: '#quasi-embedded'
          - include: '#string-content'
  quasi-embedded:
    patterns:
      - comment: Accepts arbitrary expressions
        match: |-
          (?xi)
          (?<!\\) # no backslash
          (\$) # prefix
          ([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*) # variable
          (?:(%)(
            \(.+?\)|
            \\?.[<=>^]?[+-]?\#?0?
            (?:\d*[-.,/_]?\.?\d*\w*%?)*
          ))? # printf modifier
        captures:
          1: {name: punctuation.quasi.element.somra}
          2: {patterns: [{include: '#variable'}]}
          3: {name: punctuation.separator.label.somra}
          4: {name: storage.type.format.somra}
      - begin: (?<!\\)(\$\{)\s*
        end: |-
          (?xi)\s*
          (\}) # closing brace
          (?:(%)(
            \(.+?\)|
            \\?.[<=>^]?[+-]?\#?0?
            (?:\d*[-.,/_]?\.?\d*\w*%?)*
          ))? # printf modifier
        name: entity.quasi.element.somra
        beginCaptures:
          1: {name: punctuation.quasi.element.begin.somra}
        endCaptures:
          1: {name: punctuation.quasi.element.end.somra}
          2: {name: punctuation.separator.label.somra}
          3: {name: storage.type.format.somra}
        patterns:
          - include: '#core'
  query:
    patterns:
      - begin: (?<![\#\.])\s*+\b(query)\b\s*
        comment: query ... in
        end: \s*(in|of)\b
        beginCaptures:
          1: {name: keyword.query.somra}
        endCaptures:
          1: {name: keyword.query.somra}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#join-keywords'
      - include: '#order-direction'
      - include: '#order-clause'
      - include: '#group-clause'
      - include: '#select-clause'
      - include: '#order-clause'
      - include: '#fold-clause'
      - include: '#take-clause'
    repository:
      fold-clause:
        match: (?<![\#\.])\s*+\b((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
        name: keyword.query.somra
      group-clause:
        begin: (?<![\#\.])\s*+\b(group)\b\s*
        comment: group ... by
        end: \s*(by)\b
        beginCaptures:
          1: {name: keyword.query.somra}
        endCaptures:
          1: {name: keyword.query.somra}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      join-clause:
        begin: (?<![\#\.])\s*+\b(join)\b\s*
        comment: group ... by
        end: \s*(in|of)\b
        beginCaptures:
          1: {name: keyword.query.somra}
        endCaptures:
          1: {name: keyword.query.somra}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      join-keywords:
        match: (?<![\#\.])\s*+\b(equals?|[io]nto)\b\s*
        name: keyword.query.somra
      let-clause:
        comment: override let keyword
        match: (?<![\#\.])\s*+\b(const|con|let|var|val)\b\s*
        name: storage.type.somra
      order-clause:
        match: (?<![\#\.])\s*+\b((\b(order)\b)\s*(\b(by)\b)?\s*(\b((a|de)sc)\b)?)\b\s*
        name: keyword.query.somra
      order-direction:
        match: (?<![\#\.])\s*+\b((a|de)sc)\b\s*
        name: keyword.query.somra
      select-clause:
        match: (?<![\#\.])\s*+\b(select)\b\s*
        name: keyword.query.somra
      take-clause:
        match: (?<![\#\.])\s*+\b((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
        name: keyword.query.somra
      where-clause:
        match: (?<![\#\.])\s*+\b(where)\b\s*
        name: keyword.query.somra
  regex-group-name:
    patterns:
      - include: '#jsx-tag-attributes'
      - include: '#support'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#method-name'
      - include: '#function-name'
      - include: '#operator'
      - include: '#operators'
  regexp:
    begin: (?<=^|[\p{Ps}\p{Po}\p{Pd}\p{S}]|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)\s*+([[:alnum:]]*)(/)(?![*/])(?=.*/[[:alnum:]]*\s*($|[,;\p{Pe}]|\.[_\\\p{L}\p{M}\p{N}]))
    comment: Updated to support Perl regex syntax
    end: (/)(?:((?:\\.|.)*)(/))?([[:alnum:]]*)
    name: string.somra.somra
    beginCaptures:
      1: {name: keyword.modifier.somra}
      2: {name: punctuation.definition.string.begin.somra}
    endCaptures:
      1: {name: punctuation.definition.string.end.somra}
      2: {name: string.quoted.somra, patterns: [{include: '#backreferences'}]}
      3: {name: punctuation.definition.string.end.somra}
      4: {name: keyword.other.flag.somra}
    patterns:
      - include: '#regexp-patterns'
  regexp-multiline:
    comment: Updated to support Perl regex syntax
    patterns:
      - begin: ([[:alpha:]]*)(/>)\s*\n?
        end: \s*(\n?</)([[:alnum:]]*)
        name: string.somra.multiline.somra
        beginCaptures:
          1: {name: keyword.modifier.somra}
          2: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: punctuation.definition.string.end.somra}
          2: {name: keyword.other.flag.somra}
        patterns:
          - include: '#heregexp'
      - begin: (?!\\)(?<=</)(>)\s*\n?
        contentName: string.quoted.somra
        end: \s*\n?(</)([[:alnum:]]*)
        name: string.somra.somra
        beginCaptures:
          1: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: punctuation.definition.string.end.somra}
          2: {name: keyword.other.flag.somra}
        patterns:
          - include: '#backreferences'
  regexp-patterns:
    patterns:
      - include: '#quasi-embedded'
      - include: '#comments'
      - match: (?<!\\)(\//).*$\n?
        name: comment.line.shebang.somra
        captures:
          1: {name: punctuation.definition.comment.somra}
      - match: \|
        name: keyword.operator.or.somra
      - match: (?i)\\[abyz]({.*?})?
        name: keyword.control.anchor.somra
      - match: \^
        name: keyword.control.begin.somra
      - match: \$
        name: keyword.control.end.somra
      - match: \.
        name: constant.character.all.somra
      - comment: Suppress ? in (? sequence
        match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.somra}
          2: {name: keyword.operator.quantifier.lazy.somra}
          3: {name: keyword.operator.quantifier.eager.somra}
          4: {name: keyword.operator.quantifier.greedy.somra}
      - begin: (?<=\()(\?\{)
        comment: Embedded code callouts
        end: \s*(\})([<*>])?(?:(\[)(.*)(\]))?
        name: keyword.operator.callout.somra
        beginCaptures:
          1: {name: keyword.operator.callout.somra}
          2: {name: keyword.operator.callout.somra}
        endCaptures:
          1: {name: keyword.operator.callout.somra}
          2: {name: keyword.operator.range.somra}
          3: {name: punctuation.definition.tag.somra}
          4: {patterns: [{include: $self}]}
          5: {name: punctuation.definition.tag.somra}
        patterns:
          - include: $self
      - begin: (?<=\()(\?<)
        comment: Named groups
        end: \s*(>)
        name: punctuation.definition.group.named.somra
        beginCaptures:
          1: {name: punctuation.definition.group.named.somra}
        endCaptures:
          1: {name: punctuation.definition.group.named.somra}
        patterns:
          - include: '#regex-group-name'
      - match: (?<=\()(\?(?:([+-]?\d+?)|([A-Z\d]+(?:-[A-Z\d]+)?)|([a-z\d]+(?:-[a-z\d]+)?)))\s*(:)?
        name: keyword.control.back-reference.somra
        captures:
          1: {name: keyword.other.back-reference.somra}
          2: {name: entity.name.function.method.somra}
          3: {name: keyword.control.recursion.somra}
          4: {name: storage.type.somra}
          5: {name: punctuation.separator.label.somra}
      - match: (?<=\?\()(?:([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|([+-]?\d*))(?=\))
        name: keyword.control.conditional.group.somra
        captures:
          1: {name: variable.other.somra}
          2: {name: keyword.other.back-reference.somra}
      - match: \\[1-9]\d*
        name: keyword.other.back-reference.somra
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}\??
        name: keyword.operator.quantifier.somra
      - begin: (\\Q)
        contentName: string.quoted.double.somra
        end: (\\E)
        name: string.quoted.raw.somra
        beginCaptures:
          1: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: punctuation.definition.string.end.somra}
      - begin: (\\q)
        contentName: string.quoted.single.somra
        end: (\\e)
        name: string.quoted.somra
        beginCaptures:
          1: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: punctuation.definition.string.end.somra}
        patterns:
          - include: '#string-content'
      - begin: \((\?(?:&|P(=))(?:([+-]?\d+)|([_\\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
        end: \s*(\))
        name: meta.group.somra
        beginCaptures:
          0: {name: punctuation.definition.group.somra}
          1: {name: keyword.other.back-reference.somra}
          2: {name: keyword.operator.assignment.somra}
          3: {name: entity.name.function.method.somra}
          4: {name: variable.other.somra}
          5: {name: punctuation.separator.label.somra}
        endCaptures:
          1: {name: punctuation.definition.group.somra}
        patterns:
          - include: '#regexp-patterns'
      - begin: \(([*+])
        end: \s*(\))
        name: constant.other.pcre.somra
        beginCaptures:
          0: {name: punctuation.definition.group.somra}
          1: {name: keyword.generator.somra}
        endCaptures:
          1: {name: punctuation.definition.group.somra}
        patterns:
          - include: '#mini-expression'
      - begin: (\()(\?#)
        contentName: comment.line.number-sign.somra
        end: \s*(\))
        name: comment.line.number-sign.somra
        beginCaptures:
          1: {name: punctuation.definition.group.somra}
          2: {name: punctuation.definition.comment.somra}
        endCaptures:
          1: {name: punctuation.definition.group.somra}
        patterns:
          - match: \\.
            name: comment.line.number-sign.somra
      - begin: (\()((\?=)|(\?!)|(\?<=)|(\?<!)|(\?>)|(?:(\?))(?=[(|])|(\?~))
        end: \s*(\))
        name: meta.group.somra
        beginCaptures:
          1: {name: punctuation.definition.group.somra}
          2: {name: punctuation.definition.group.assertion.somra}
          3: {name: meta.assertion.look-ahead.somra}
          4: {name: meta.assertion.negative-look-ahead.somra}
          5: {name: meta.assertion.look-behind.somra}
          6: {name: meta.assertion.negative-look-behind.somra}
          7: {name: meta.group.atomic.somra}
          8: {name: meta.group.branch.somra}
          9: {name: meta.group.absent.somra}
        endCaptures:
          1: {name: punctuation.definition.group.somra}
        patterns:
          - include: '#regexp-patterns'
      - begin: \((?:(\?:)|(?:\?<(.*?)>))?
        end: \s*(\))
        name: meta.group.somra
        beginCaptures:
          0: {name: punctuation.definition.group.somra}
          1: {name: punctuation.definition.group.no-capture.somra}
          2: {patterns: [{include: '#regex-group-name'}]}
        endCaptures:
          0: {name: punctuation.definition.group.somra}
        patterns:
          - include: '#regexp-patterns'
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.somra
        beginCaptures:
          1: {name: keyword.other.back-reference.somra}
        endCaptures:
          1: {name: keyword.other.back-reference.somra}
        patterns:
          - include: '#jsx-tag-attributes'
          - include: '#support'
          - include: '#keywords'
          - include: '#modifiers'
          - include: '#method-name'
          - include: '#function-name'
          - include: '#operators'
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.somra
        beginCaptures:
          1: {name: keyword.other.subroutine.somra}
        endCaptures:
          1: {name: keyword.other.subroutine.somra}
        patterns:
          - include: '#jsx-tag-attributes'
          - include: '#support'
          - include: '#keywords'
          - include: '#modifiers'
          - include: '#method-name'
          - include: '#function-name'
          - include: '#operators'
      - begin: (\[)(\^)?
        end: \s*(\])
        name: constant.other.character-class.set.somra
        beginCaptures:
          1: {name: punctuation.definition.character-class.somra}
          2: {name: keyword.operator.negation.somra}
        endCaptures:
          1: {name: punctuation.definition.character-class.somra}
        patterns:
          - include: '#comments'
          - match: '--'
            name: keyword.operator.optional.somra
          - include: '#regex-character-class'
          - include: '#regex-character-range'
          - include: '#regex-character-set'
      - begin: (\{)
        end: \s*(\})
        name: meta.brace.curly.litobj.somra
        patterns:
          - include: '#regexp-patterns'
      - include: '#regex-character-class'
      - comment: Remaining backslash tokens
        match: (?i)\\(?:(M)|(K)|(G)|(X))
        captures:
          1: {name: keyword.control.anchor.somra}
          2: {name: keyword.control.keepout.somra}
          3: {name: keyword.control.search.somra}
          4: {name: constant.character.unicode.somra}
      - match: \\.
        name: constant.character.escape.other.somra
      - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.somra}
          2: {name: keyword.operator.modifier.eager.somra}
          3: {name: keyword.operator.modifier.greedy.somra}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.somra}
          2: {name: keyword.operator.quantifier.eager.somra}
          3: {name: keyword.operator.quantifier.greedy.somra}
    repository:
      regex-character-class:
        patterns:
          - match: (\\)(?=\s*$)
            name: constant.character.escape.newline.somra
          - begin: (?i)(\\p{)
            end: \s*(})
            name: constant.other.character-class.unicode.somra
            beginCaptures:
              1: {name: constant.other.character-class.unicode.somra}
            endCaptures:
              1: {name: constant.other.character-class.unicode.somra}
            patterns:
              - include: '#keywords'
              - include: '#implicit-call'
              - include: '#operators'
          - match: \\x\h{2}|\\U\h{8}
            name: constant.character.escape.hex.somra
          - match: \\[cCmM][[:alpha:]]|\R
            name: constant.character.control.somra
          - match: \\[pP][[:alpha:]]|\\O
            name: constant.other.character-class.unicode.somra
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.somra
          - match: \\[ux](({[\h\s]+\})|\h{4})
            name: constant.character.escape.unicode.somra
          - begin: (?i)\\j{
            end: \s*}
            name: constant.character.entity.named.somra
            beginCaptures:
              1: {name: constant.character.entity.named.somra}
            endCaptures:
              1: {name: constant.character.entity.named.somra}
            patterns:
              - include: '#implicit-call'
              - include: '#regexp-patterns'
          - match: \.|\\[wsdvntluh]
            name: constant.other.character-class.somra
          - match: \\[WSDVNTLUH]
            name: constant.other.character-class.negated.somra
          - match: \\N{[\w\s]+}
            name: constant.character.escape.unicode.name.somra
          - match: \\o{[0-7]+}
            name: constant.character.escape.octal.somra
          - match: \\['"\\nrtfve0`]
            name: constant.character.escape.somra
      regex-character-range:
        patterns:
          - match: (?:.|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))
            name: constant.other.character-class.range.somra
            captures:
              1: {name: constant.character.numeric.somra}
              2: {name: constant.character.control.somra}
              3: {name: constant.character.escape.backslash.somra}
              4: {name: constant.character.numeric.somra}
              5: {name: constant.character.control.somra}
              6: {name: constant.character.escape.backslash.somra}
      regex-character-set:
        patterns:
          - match: '[|]{2}'
            name: keyword.operator.union.somra
          - match: '&{2}'
            name: keyword.operator.intersection.somra
          - match: \^{2}
            name: keyword.operator.only.somra
          - match: ~{2}
            name: keyword.operator.maybe.somra
          - match: \.
            name: constant.other.character-class.set.somra
          - begin: (\[=)
            end: \s*(=\])
            name: constant.other.character-class.posix.somra
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[\.)
            end: \s*(\.\])
            name: constant.other.character-class.posix.somra
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[:)
            end: \s*(:\])
            name: constant.other.character-class.posix.somra
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.somra}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[)(\^)?
            end: \s*(\])
            name: constant.other.character-class.set.somra
            beginCaptures:
              1: {name: punctuation.definition.character-class.somra}
              2: {name: keyword.operator.negation.somra}
            endCaptures:
              1: {name: punctuation.definition.character-class.somra}
            patterns:
              - include: '#comments'
              - match: '--'
                name: keyword.operator.optional.somra
              - include: '#regex-character-range'
              - include: '#regex-character-class'
              - include: '#regex-character-set'
              - match: \\.
                name: constant.character.escape.other.somra
          - match: \\.
            name: constant.character.escape.other.somra
  round-brackets:
    patterns:
      - begin: \s*+(#\()
        end: \s*(\))
        beginCaptures:
          1: {name: meta.brace.round.somra}
        endCaptures:
          1: {name: meta.brace.round.somra}
        patterns:
          - include: '#core'
      - begin: \s*+(\()
        end: \s*(\))
        beginCaptures:
          1: {name: meta.brace.round.somra}
        endCaptures:
          1: {name: meta.brace.round.somra}
        patterns:
          - include: '#core'
  semi-colon:
    patterns:
      - match: \s*+(;)
        captures:
          1: {name: punctuation.terminator.statement.somra}
  sigils:
    patterns:
      - match: \^[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
        name: constant.other.symbol.somra
      - match: '&[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
        name: constant.other.label.somra
      - match: '%[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
        name: constant.other.global.somra
      - match: \*[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
        name: constant.other.rest.somra
  special-comments-conditional-compilation:
    patterns:
      - begin: \s*+((/\*))(?=@)
        contentName: comment.block.conditional.somra
        end: \s*\*/
        captures:
          1: {name: comment.block.conditional.somra}
          2: {name: punctuation.definition.comment.somra}
        endCaptures:
          1: {name: keyword.control.conditional.somra}
          2: {name: punctuation.definition.keyword.somra}
        patterns:
          - match: \s*+/\*
            name: punctuation.definition.comment.somra
          - include: $self
      - match: \s*+(?!@)(@)(if|elif|else|end|ifdef|endif|cc_on|set)\b
        name: keyword.control.conditional.somra
        captures:
          1: {name: punctuation.definition.keyword.somra}
      - match: \s*+(?!@)(@)(_win32|_win16|_mac|_alpha|_x86|_mc680x0|_PowerPC|_jscript|_jscript_build|_jscript_version|_debug|_fast|[a-zA-Z]\w+)
        name: variable.other.conditional.somra
        captures:
          1: {name: punctuation.definition.variable.somra}
  square-brackets:
    patterns:
      - begin: \s*+(#\[)
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.somra}
        endCaptures:
          1: {name: meta.brace.square.somra}
        patterns:
          - match: \s*:(?![:<=>])\s*
            name: keyword.operator.slice.somra
          - include: '#object'
          - include: '#core'
      - begin: \s*+(\[)
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.somra}
        endCaptures:
          1: {name: meta.brace.square.somra}
        patterns:
          - match: \s*:(?![:<=>])\s*
            name: keyword.operator.slice.somra
          - include: '#object'
          - include: '#core'
  string:
    patterns:
      - begin: \s*+(('))
        contentName: string.quoted.single.somra
        end: |-
          \s*+(?:(('))|(
          ))
        beginCaptures:
          1: {name: string.quoted.single.somra}
          2: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: string.quoted.single.somra}
          2: {name: punctuation.definition.string.end.somra}
          3: {name: invalid.illegal.newline.somra}
        patterns:
          - include: '#string-content'
      - begin: \s*+(("))
        contentName: string.quoted.double.somra
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.double.somra}
          2: {name: punctuation.definition.string.begin.somra}
        endCaptures:
          1: {name: string.quoted.double.somra}
          2: {name: punctuation.definition.string.end.somra}
          3: {name: invalid.illegal.newline.somra}
        patterns:
          - include: '#string-content'
  string-content:
    patterns:
      - match: (\\)(?=\s*$)
        name: constant.character.escape.newline.somra
      - match: |-
          (?xi)
          (\\b(?:[01]{1,21}|{[01\s]+?})) # base 2
          |(\\q(?:[0-3]{1,11}|{[0-3\s]+?})) # base 4
          |(\\s(?:[0-5]{1,8}|{[0-5\s]+?})) # base 6
          |(\\o(?:[0-7]{1,7}|{[0-7\s]+?})) # base 8 
          |(\\d?\d{1,7}|\\d{[\d\s]+?}) # base 10
          |(\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})) # base 12
          |(\\x(?:\h{1,6}|{[\h\s]+?})) # base 14 
          |(\\u(?:\h{1,6}|{[\h\s]+?})) # base 16
        captures:
          1: {name: constant.character.escape.binary.somra}
          2: {name: constant.character.escape.quaternary.somra}
          3: {name: constant.character.escape.senary.somra}
          4: {name: constant.character.escape.octal.somra}
          5: {name: constant.character.escape.decimal.somra}
          6: {name: constant.character.escape.duodecimal.somra}
          7: {name: constant.character.escape.hexadecimal.somra}
          8: {name: constant.character.escape.unicode.somra}
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.somra
        beginCaptures:
          1: {name: constant.character.entity.named.somra}
        endCaptures:
          1: {name: constant.character.entity.named.somra}
        patterns:
          - include: '#implicit-call'
          - include: '#regexp-patterns'
      - match: (?i)\\[anrtbfveclzp]
        name: constant.character.escape.somra
      - match: \\[\P{L}&&[\P{N}]]
        name: constant.character.escape.symbol.somra
      - match: \\[\p{L}\p{N}]
        name: constant.character.escape.illegal.somra
      - include: '#quasi-embedded'
  support:
    patterns:
      - match: |-
          (?x) (?<![\#\.]) \s*+ \b(
            (
              Arithmetic | Assertion | Attribute | Buffer | BlockingIO
              | BrokenPipe | ChildProcess
              | (Connection (Aborted | Refused | Reset)?)
              | EOF | Environment | FileExists | FileNotFound
              | FloatingPoint | IO | Import | Indentation | Index | Interrupted
              | IsADirectory | NotADirectory | Permission | ProcessLookup
              | Timeout
              | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow
              | Reference | Runtime | Recursion | Syntax | System
              | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?
              | Value | Windows | ZeroDivision | ModuleNotFound
            ) Error
          |
            ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import
              | Unicode | Bytes | Resource
            )? Warning
          |
            SystemExit | Stop(Async)?Iteration
            | KeyboardInterrupt
            | GeneratorExit | (Base)?Error
          )\b
        name: support.class.error.somra
      - applyEndPatternLast: 1
        begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.builtin.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        beginCaptures:
          2: {name: support.class.builtin.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: support.class.builtin.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        beginCaptures:
          2: {name: support.class.builtin.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: support.class.builtin.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.error.somra}
        patterns:
          - include: '#round-brackets'
      - match: (?<![\#\.])\s*+\b(debug|assert|check)\b
        captures:
          1: {name: keyword.other.somra}
      - match: (?<![\#\.])\s*+\b(doc|event|navi|perf|scrn|win)\b
        captures:
          1: {name: support.type.object.dom.somra}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        beginCaptures:
          1: {name: support.type.object.console.somra}
          2: {name: keyword.operator.accessor.somra}
          3: {name: support.function.console.somra}
        patterns:
          - include: '#round-brackets'
      - match: (?<![\#\.])\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.somra}
          2: {name: keyword.operator.accessor.somra}
          3: {name: support.type.object.process.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        beginCaptures:
          1: {name: support.type.object.process.somra}
          2: {name: keyword.operator.accessor.somra}
          3: {name: support.function.process.somra}
        patterns:
          - include: '#round-brackets'
      - match: (((?<![\#\.])\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.somra}
          2: {name: keyword.operator.accessor.somra}
          3: {name: support.type.object.module.somra}
      - match: (?<![\#\.])\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.somra}
      - applyEndPatternLast: 1
        begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.node.somra}
        patterns:
          - include: '#round-brackets'
      - begin: \s*+({{)
        contentName: meta.tag.mustache.somra
        end: (\s*}})
        captures:
          1: {name: meta.tag.mustache.somra}
      - include: '#support-objects'
  support-functions:
    patterns:
      - include: '#support-python'
  support-methods:
    patterns:
      - include: '#support-python'
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.mutator.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(add|append|at|average|chunk|clone|compact|concat|construct|copyWithin|count|create|difference|differenceBy|differenceWith|drop|dropRight|dropRightWhile|dropWhile|entries|every|exclude|fill|filter|find|findIndex|findLastIndex|first|flat|flatMap|flatten|flattenDeep|flattenDepth|fnFromIndex|forEach|from|fromPairs|groupBy|head|includes|indexOf|inGroups|inGroupsOf|initial|insert|intersect|intersection|intersectionBy|intersectionWith|isArray|isEmpty|isEqual|join|keys|last|lastIndexOf|least|map|max|median|min|most|none|nth|object|of|pop|pull|pullAll|pullAllBy|pullAllWith|pullAt|push|range|reduce|reduceRight|remove|removeAt|rest|reverse|sample|shift|shuffle|slice|some|sort|sortBy|sortedIndex|sortedIndexBy|sortedIndexOf|sortedLastIndex|sortedLastIndexBy|sortedLastIndexOf|sortedUniq|sortedUniqBy|splice|subtract|sum|tail|take|takeRight|takeRightWhile|takeWhile|to|toLocaleString|toSource|toString|union|unionBy|unionWith|uniq|uniqBy|unique|uniqWith|unshift|unzip|unzipWith|values|without|xor|xorBy|xorWith|zip|zipObject|zipObjectDeep|zipWith)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.array.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(add|and|clamp|clone|compareExchange|contains|dateUnit|every|exchange|intersect|isLockFree|isValid|load|notify|or|span|store|sub|toArray|toString|union|wait|xor)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.atomics.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(asIntN|asUintN|toLocaleString|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.bigint.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(toSource|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.boolean.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(contains|countBy|each|eachRight|every|filter|find|findLast|findWhere|flatMap|flatMapDeep|flatMapDepth|forEach|forEachRight|groupBy|includes|indexBy|invoke|invokeMap|keyBy|map|max|min|orderBy|partition|pluck|reduce|reduceRight|reject|sample|sampleSize|shuffle|size|some|sortBy|toArray|where)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.collection.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(getBigInt64|getBigUint64|getFloat32|getFloat64|getInt16|getInt32|getInt8|getUint16|getUint32|getUint8|setBigInt64|setBigUint64|setFloat32|setFloat64|setInt16|setInt32|setInt8|setUint16|setUint32|setUint8)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.dataview.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(addLocale|addUnits|advance|beginningOfISOWeek|beginningOfUnit|clone|create|daysInMonth|endOfISOWeek|endOfUnit|format|full|get|getAllLocaleCodes|getAllLocales|getDate|getDay|getFullYear|getHours|getISOWeek|getLocale|getMilliseconds|getMinutes|getMonth|getOption|getSeconds|getTime|getTimezoneOffset|getUTCDate|getUTCDay|getUTCFullYear|getUTCHours|getUTCMilliseconds|getUTCMinutes|getUTCMonth|getUTCOffset|getUTCSeconds|getUTCWeekday|getWeekday|getYear|is|isAfter|isBefore|isBetween|isDay|isFuture|isLastUnit|isLeapYear|isNextUnit|iso|isPast|isThisUnit|isUTC|isValid|long|medium|now|parse|range|relative|relativeTo|removeLocale|reset|rewind|set|setDate|setFullYear|setHours|setISOWeek|setLocale|setMilliseconds|setMinutes|setMonth|setOption|setSeconds|setTime|setUTC|setUTCDate|setUTCFullYear|setUTCHours|setUTCMilliseconds|setUTCMinutes|setUTCMonth|setUTCSeconds|setWeekday|setYear|short|toDateString|toGMTString|toISOString|toJSON|toLocaleDateString|toLocaleString|toLocaleTimeString|toSource|toString|toTimeString|toUTCString|unitsAgo|unitsFromNow|unitsSince|unitsUntil|UTC|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.date.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(__|add|addIndex|adjust|after|all|allPass|always|and|andThen|any|anyPass|ap|aperture|append|apply|applySpec|applyTo|ary|ascend|assoc|assocPath|before|binary|bind|bindAll|bindKey|both|call|cancel|chain|clamp|clone|comparator|complement|compose|composeK|composeP|composeWith|concat|cond|construct|constructN|contains|converge|countBy|curry|curryN|curryRight|debounce|dec|defaultTo|defer|delay|descend|difference|differenceWith|dissoc|dissocPath|divide|drop|dropLast|dropLastWhile|dropRepeats|dropRepeatsWith|dropWhile|either|empty|endsWith|eqBy|eqProps|equals|every|evolve|F|filter|find|findIndex|findLast|findLastIndex|flatten|flip|forEach|forEachObjIndexed|fromPairs|groupBy|groupWith|gt|gte|has|hasIn|hasPath|head|identical|identity|ifElse|inc|includes|indexBy|indexOf|init|innerJoin|insert|insertAll|intersection|intersperse|into|invert|invertObj|invoker|is|isEmpty|isNil|join|juxt|keys|keysIn|last|lastIndexOf|lazy|length|lens|lensIndex|lensPath|lensProp|lift|liftN|lock|lt|lte|map|mapAccum|mapAccumRight|mapObjIndexed|match|mathMod|max|maxBy|mean|median|memoize|memoizeWith|merge|mergeAll|mergeDeepLeft|mergeDeepRight|mergeDeepWith|mergeDeepWithKey|mergeLeft|mergeRight|mergeWith|mergeWithKey|min|minBy|modulo|move|multiply|nAry|negate|none|not|nth|nthArg|o|objOf|of|omit|once|or|otherwise|over|overArgs|pair|partial|partialRight|partition|path|pathEq|pathOr|paths|pathSatisfies|pick|pickAll|pickBy|pipe|pipeK|pipeP|pipeWith|pluck|prepend|product|project|prop|propEq|propIs|propOr|props|propSatisfies|range|rearg|reduce|reduceBy|reduced|reduceRight|reduceWhile|reject|remove|repeat|replace|rest|restArguments|reverse|scan|sequence|set|slice|sort|sortBy|sortWith|split|splitAt|splitEvery|splitWhen|spread|startsWith|subtract|sum|symmetricDifference|symmetricDifferenceWith|T|tail|take|takeLast|takeLastWhile|takeWhile|tap|test|throttle|thunkify|times|toLower|toPairs|toPairsIn|toSource|toString|toUpper|transduce|transpose|traverse|trim|tryCatch|type|unapply|unary|uncurryN|unfold|union|unionWith|uniq|uniqBy|uniqWith|unless|unnest|until|update|useWith|values|valuesIn|view|when|where|whereEq|without|wrap|xor|xprod|zip|zipObj|zipWith)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.function.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(next|return|throw)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.generator.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(chain|parse|stringify|value)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.json.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(castArray|clone|cloneDeep|cloneDeepWith|cloneWith|conformsTo|eq|gt|gte|isArguments|isArray|isArrayBuffer|isArrayLike|isArrayLikeObject|isBoolean|isBuffer|isDate|isElement|isEmpty|isError|iSetual|iSetualWith|isFinite|isFunction|isInteger|isLength|isMap|isMatch|isMatchWith|isNaN|isNative|isNil|isNull|isNumber|isObject|isObjectLike|isPlainObject|isProxy|isRegExp|isSafeInteger|isSet|isString|isSymbol|isUndefined|isWeakMap|isWeakSet|lt|lte|toArray|toFinite|toInteger|toLength|toNumber|toPlainObject|toSafeInteger|toString)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.lang.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(clear|delete|entries|forEach|get|has|keys|set|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.map.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(abs|acos|acosh|acot|acoth|acsc|acsch|add|and|apply|arg|asec|asech|asin|asinh|atan|atan2|atanh|bellNumbers|bin|bitAnd|bitNot|bitOr|bitXor|catalan|cbrt|ceil|clone|clz32|column|combinations|combinationsWithRep|compare|compareNatural|compareText|compile|composition|concat|conj|cos|cosh|cot|coth|count|cross|csc|csch|ctranspose|cube|deepEqual|derivative|det|diag|diff|distance|divide|dot|dotDivide|dotMultiply|dotPow|eigs|equal|equalText|erf|evaluate|exp|expm|expm1|factorial|filter|fix|flatten|floor|forEach|format|fround|gamma|gcd|getMatrixDataType|hasNumericValue|help|hex|hypot|identity|im|imul|intersect|inv|isInteger|isNaN|isNegative|isNumeric|isPositive|isPrime|isZero|kldivergence|kron|larger|largerEq|lcm|leftShift|log|log10|log1p|log2|lsolve|lup|lusolve|mad|map|max|maxBy|mean|meanBy|median|min|minBy|mod|mode|multinomial|multiply|norm|not|nthRoot|nthRoots|numeric|oct|ones|or|parser|partitionSelect|permutations|pickRandom|pow|print|prod|qr|quantileSeq|random|randomInt|range|rationalize|re|reshape|resize|rightArithShift|rightLogShift|rotate|rotationMatrix|round|row|sec|sech|setCartesian|setDifference|setDistinct|setIntersect|setIsSubset|setMultiplicity|setPowerset|setSize|setSymDifference|setUnion|sign|simplify|sin|sinh|size|slu|smaller|smallerEq|sort|sqrt|sqrtm|square|squeeze|std|stirlingS2|subset|subtract|sum|sumBy|tan|tanh|to|trace|transpose|trunc|typeOf|unaryMinus|unaryPlus|unequal|usolve|variance|xgcd|xor|zeros)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.math.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(abbr|bytes|cap|ceil|chr|clamp|dateUnit|dateUnitAfter|dateUnitAgo|dateUnitBefore|dateUnitFromNow|downto|duration|floor|format|hex|inRange|isEven|isFinite|isInteger|isMultipleOf|isNaN|isOdd|isSafeInteger|log|math|metric|ordinalize|pad|parseFloat|parseInt|random|range|round|times|toExponential|toFixed|toLocaleString|toNumber|toPrecision|toSource|toString|upto|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.number.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(__defineGetter__|__defineSetter__|__lookupGetter__|__lookupSetter__|add|addAll|allKeys|assign|assignIn|assignInWith|assignWith|at|average|clone|count|create|defaults|defaultsDeep|defineProperties|defineProperty|entries|entriesIn|every|exclude|extend|extendOwn|extendWith|filter|find|findKey|findLastKey|forEach|forIn|forInRight|forOwn|forOwnRight|freeze|fromEntries|fromQueryString|functions|functionsIn|get|getOwnPropertyDescriptor|getOwnPropertyDescriptors|getOwnPropertyNames|getOwnPropertySymbols|getPrototypeOf|has|hasIn|hasOwnProperty|intersect|invert|invertBy|invoke|is|isArguments|isArray|isArrayBuffer|isBoolean|isDataView|isDate|isElement|isEmpty|isEqual|isError|isExtensible|isFinite|isFrozen|isFunction|isMap|isMatch|isNaN|isNull|isNumber|isObject|isPrototypeOf|isRegExp|isSealed|isSet|isString|isSymbol|isType|isTypedArray|isUndefined|isWeakMap|isWeakSet|keys|keysIn|least|map|mapKeys|mapObject|mapValues|matcher|max|median|merge|mergeAll|mergeWith|min|most|none|omit|omitBy|pairs|pick|pickBy|preventExtensions|property|propertyIsEnumerable|propertyOf|reduce|reject|remove|result|seal|select|set|setPrototypeOf|setWith|size|some|subtract|sum|tap|toLocaleString|toPairs|toPairsIn|toPath|toQueryString|toSource|toString|transform|unset|update|updateWith|valueOf|values|valuesIn)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.object.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(all|allSettled|any|catch|finally|race|reject|resolve|then)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.promise.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(apply|construct|defineProperty|deleteProperty|get|getOwnPropertyDescriptor|getPrototypeOf|has|isExtensible|ownKeys|preventExtensions|register|set|setPrototypeOf|unregister)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.proxy.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(address|age|altitude|ampm|android_id|animal|apple_token|areacode|avatar|bb_pin|birthday|bool|capitalize|cc|cc_type|cf|character|city|coin|color|company|coordinates|country|cpf|currency|currency_pair|date|depth|dice|dollar|domain|email|euro|exp|exp_month|exp_year|falsy|fbid|first|floating|gender|geohash|google_analytics|guid|hammertime|hash|hashtag|hidden|hour|integer|ip|ipv6|klout|last|latitude|letter|locale|longitude|millisecond|minute|mixin|month|n|name|natural|normal|pad|paragraph|phone|pick|pickone|pickset|postal|postcode|prefix|prime|profession|province|radio|rpg|second|sentence|set|shuffle|ssn|state|street|string|suffix|syllable|timestamp|timezone|tld|tv|twitter|unique|url|weekday|weighted|word|wp7_anid|wp8_anid2|year|zip)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.random.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(addFlags|compile|escape|exec|getFlags|removeFlags|setFlags|test|toSource|toString)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.somra.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(at|chain|commit|next|plant|prototype|reverse|tap|thru|toJSON|value|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.seq.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(add|clear|delete|entries|forEach|has|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.set.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(addAcronym|addHuman|addPlural|anchor|at|big|blink|bold|camelCase|camelize|capitalize|chain|charAt|charCodeAt|chars|codePointAt|codePoints|codes|compact|concat|count|countGraphemes|countSubstrings|countWhere|countWords|dasherize|deburr|decapitalize|decodeBase64|encodeBase64|endsWith|escape|escapeHtml|escapeHTML|escapeRegExp|escapeURL|first|fixed|fontcolor|fontsize|forEach|format|from|fromCharCode|fromCodePoint|graphemeAt|graphemes|hankaku|hasScript|hiragana|humanize|includes|indexOf|insert|isAlpha|isAlphaDigit|isBlank|isDigit|isEmpty|isLowerCase|isNumeric|isScript|isString|isUpperCase|italics|katakana|kebabCase|last|lastIndexOf|latinise|lines|link|localeCompare|lowerCase|lowerFirst|match|matchAll|matches|normalize|pad|padEnd|padLeft|padRight|padStart|parameterize|parseInt|pluralize|prune|range|raw|remove|removeAll|removeTags|repeat|replace|replaceAll|reverse|reverseGrapheme|search|shift|singularize|slice|slugify|small|snakeCase|spacify|splice|split|sprintf|startCase|startsWith|strike|stripBom|stripTags|sub|substr|substring|sup|swapCase|template|thru|titleCase|titleize|to|toLocaleLowerCase|toLocaleUpperCase|toLower|toLowerCase|toNumber|toSource|toString|toUpper|toUpperCase|tr|trim|trimEnd|trimLeft|trimRight|trimStart|truncate|truncateOnWord|underscore|unescape|unescapeHtml|unescapeHTML|unescapeURL|upperCase|upperFirst|value|valueOf|vprintf|words|wordWrap|zenkaku)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.string.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(for|keyFor|toSource|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.symbol.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(at|copyWithin|entries|every|fill|filter|find|findIndex|forEach|from|includes|indexOf|join|keys|lastIndexOf|map|of|reduce|reduceRight|reverse|set|slice|some|sort|subarray|toLocaleString|toString|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.typedarray.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(attempt|bindAll|cond|conforms|constant|defaultTo|escape|flow|flowRight|identity|iteratee|matches|matchesProperty|method|methodOf|mixin|noConflict|noop|now|nthArg|over|overEvery|overSome|property|propertyOf|random|range|rangeRight|result|runInContext|stubArray|stubFalse|stubObject|stubString|stubTrue|template|times|toPath|unescape|uniqueId)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.util.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(compile|compileStreaming|instantiate|instantiateStreaming|validate)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.webassembly.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(on(?:Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|Before(?:cut|deactivate|unload|update|paste|print|editfocus|activate)|Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort))\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.event-handler.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.somra}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|appendChild|appendData|before|blur|canPlayType|captureStream|caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|cloneContents|cloneNode|cloneRange|close|closest|collapse|compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|createAttributeNS|createCaption|createCDATASection|createComment|createContextualFragment|createDocument|createDocumentFragment|createDocumentType|createElement|createElementNS|createEntityReference|createEvent|createExpression|createHTMLDocument|createNodeIterator|createNSResolver|createProcessingInstruction|createRange|createShadowRoot|createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|getClientRects|getContext|getDestinationInsertionPoints|getElementById|getElementsByClassName|getElementsByName|getElementsByTagName|getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|previousSibling|probablySupportsContext|queryCommandEnabled|queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|querySelector|querySelectorAll|registerContentHandler|registerElement|registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|toDataURL|toggle|toString|values|write|writeln)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.dom.somra}
        patterns:
          - include: '#round-brackets'
  support-objects:
    patterns:
      - match: (?<![\#\.])\s*\b(global|GLOBAL|root|__dirname|__filename)\b\s*
        name: support.variable.object.node.somra
      - match: (?<![\#\.])\s*\b(exports|process)\s*\b
        name: support.variable.$1.somra
      - match: (?<![\#\.])\s*\b(JSON)\s*\b
        name: support.constant.json.somra
      - match: (?<![\#\.])\s*\b(Math)\s*\b
        name: support.constant.math.somra
      - match: (?<![\#\.])\s*\b(console)\s*\b
        name: support.constant.console.somra
      - match: (?<![\#\.])\s*+\b(document|event|navigator|performance|screen|window)\s*+\b
        name: support.variable.dom.somra
      - match: |-
          (?x) (?<![\#\.]) \s*+ \b
            (Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream 
          |Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip) \b
        name: support.class.node.somra
      - applyEndPatternLast: 1
        begin: |-
          (?x) (?<![\#\.]) \s*+ \b
            (AnalyserNode|ArrayBufferView|Attr|AudioBuffer|AudioBufferSourceNode|AudioContext|AudioDestinationNode|AudioListener
            |AudioNode|AudioParam|BatteryManager|BeforeUnloadEvent|BiquadFilterNode|Blob|BufferSource|ByteString|CSS|CSSConditionRule
            |CSSCounterStyleRule|CSSGroupingRule|CSSMatrix|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration
            |CSSStyleRule|CSSStyleSheet|CSSSupportsRule|CSSValue|CSSValueList|CanvasGradient|CanvasImageSource|CanvasPattern
            |CanvasRenderingContext2D|ChannelMergerNode|ChannelSplitterNode|CharacterData|ChromeWorker|CloseEvent|Comment|CompositionEvent
            |Console|ConvolverNode|Coordinates|Credential|CredentialsContainer|Crypto|CryptoKey|CustomEvent|DOMError|DOMException
            |DOMHighResTimeStamp|DOMImplementation|DOMString|DOMStringList|DOMStringMap|DOMTimeStamp|DOMTokenList|DataTransfer
            |DataTransferItem|DataTransferItemList|DedicatedWorkerGlobalScope|DelayNode|DeviceProximityEvent|DirectoryEntry
            |DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|Document|DocumentFragment|DocumentTouch|DocumentType|DragEvent
            |DynamicsCompressorNode|Element|Entry|EntrySync|ErrorEvent|Event|EventListener|EventSource|EventTarget|FederatedCredential
            |FetchEvent|File|FileEntry|FileEntrySync|FileException|FileList|FileReader|FileReaderSync|FileSystem|FileSystemSync
            |FontFace|FormData|GainNode|Gamepad|GamepadButton|GamepadEvent|Geolocation|GlobalEventHandlers|HTMLAnchorElement
            |HTMLAreaElement|HTMLAudioElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLButtonElement|HTMLCanvasElement
            |HTMLCollection|HTMLContentElement|HTMLDListElement|HTMLDataElement|HTMLDataListElement|HTMLDialogElement|HTMLDivElement
            |HTMLDocument|HTMLElement|HTMLEmbedElement|HTMLFieldSetElement|HTMLFontElement|HTMLFormControlsCollection|HTMLFormElement
            |HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLIFrameElement|HTMLImageElement|HTMLInputElement
            |HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMediaElement
            |HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLObjectElement|HTMLOptGroupElement|HTMLOptionElement
            |HTMLOptionsCollection|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPreElement|HTMLProgressElement
            |HTMLQuoteElement|HTMLScriptElement|HTMLSelectElement|HTMLShadowElement|HTMLSourceElement|HTMLSpanElement|HTMLStyleElement
            |HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement
            |HTMLTableRowElement|HTMLTableSectionElement|HTMLTextAreaElement|HTMLTimeElement|HTMLTitleElement|HTMLTrackElement
            |HTMLUListElement|HTMLUnknownElement|HTMLVideoElement|HashChangeEvent|History|IDBCursor|IDBCursorWithValue|IDBDatabase
            |IDBEnvironment|IDBFactory|IDBIndex|IDBKeyRange|IDBMutableFile|IDBObjectStore|IDBOpenDBRequest|IDBRequest|IDBTransaction
            |IDBVersionChangeEvent|IIRFilterNode|IdentityManager|ImageBitmap|ImageBitmapFactories|ImageData|Index|InputDeviceCapabilities
            |InputEvent|InstallEvent|InstallTrigger|KeyboardEvent|LinkStyle|LocalFileSystem|LocalFileSystemSync|Location|MIDIAccess
            |MIDIConnectionEvent|MIDIInput|MIDIInputMap|MIDIOutputMap|MediaElementAudioSourceNode|MediaError|MediaKeyMessageEvent
            |MediaKeySession|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeySystemConfiguration|MediaKeys|MediaRecorder|MediaStream
            |MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessageChannel|MessageEvent|MessagePort|MouseEvent
            |MutationObserver|MutationRecord|NamedNodeMap|Navigator|NavigatorConcurrentHardware|NavigatorGeolocation|NavigatorID
            |NavigatorLanguage|NavigatorOnLine|Node|NodeFilter|NodeIterator|NodeList|NonDocumentTypeChildNode|Notification
            |OfflineAudioCompletionEvent|OfflineAudioContext|OscillatorNode|PageTransitionEvent|PannerNode|ParentNode|PasswordCredential
            |Path2D|PaymentAddress|PaymentRequest|PaymentResponse|Performance|PerformanceEntry|PerformanceFrameTiming|PerformanceMark
            |PerformanceMeasure|PerformanceNavigation|PerformanceNavigationTiming|PerformanceObserver|PerformanceObserverEntryList
            |PerformanceResourceTiming|PerformanceTiming|PeriodicSyncEvent|PeriodicWave|Plugin|Point|PointerEvent|PopStateEvent
            |PortCollection|Position|PositionError|PositionOptions|PresentationConnectionClosedEvent|PresentationConnectionList
            |PresentationReceiver|ProcessingInstruction|ProgressEvent|PromiseRejectionEvent|PushEvent|PushRegistrationManager
            |RTCCertificate|RTCConfiguration|RTCPeerConnection|RTCSessionDescriptionCallback|RTCStatsReport|RadioNodeList|RandomSource
            |Range|ReadableByteStream|RenderingContext|SVGAElement|SVGAngle|SVGAnimateColorElement|SVGAnimateElement|SVGAnimateMotionElement
            |SVGAnimateTransformElement|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength
            |SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPoints|SVGAnimatedPreserveAspectRatio
            |SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGAnimationElement|SVGCircleElement|SVGClipPathElement
            |SVGCursorElement|SVGDefsElement|SVGDescElement|SVGElement|SVGEllipseElement|SVGEvent|SVGFilterElement|SVGFontElement
            |SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement
            |SVGForeignObjectElement|SVGGElement|SVGGlyphElement|SVGGradientElement|SVGHKernElement|SVGImageElement|SVGLength
            |SVGLengthList|SVGLineElement|SVGLinearGradientElement|SVGMPathElement|SVGMaskElement|SVGMatrix|SVGMissingGlyphElement
            |SVGNumber|SVGNumberList|SVGPathElement|SVGPatternElement|SVGPoint|SVGPolygonElement|SVGPolylineElement|SVGPreserveAspectRatio
            |SVGRadialGradientElement|SVGRect|SVGRectElement|SVGSVGElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStringList
            |SVGStylable|SVGStyleElement|SVGSwitchElement|SVGSymbolElement|SVGTRefElement|SVGTSpanElement|SVGTests|SVGTextElement
            |SVGTextPositioningElement|SVGTitleElement|SVGTransform|SVGTransformList|SVGTransformable|SVGUseElement|SVGVKernElement
            |SVGViewElement|ServiceWorker|ServiceWorkerContainer|ServiceWorkerGlobalScope|ServiceWorkerRegistration|ServiceWorkerState
            |ShadowRoot|SharedWorker|SharedWorkerGlobalScope|SourceBufferList|StereoPannerNode|Storage|StorageEvent|StyleSheet
            |StyleSheetList|SubtleCrypto|SyncEvent|Text|TextMetrics|TimeEvent|TimeRanges|Touch|TouchEvent|TouchList|Transferable
            |TreeWalker|UIEvent|USVString|VRDisplayCapabilities|ValidityState|WaveShaperNode|WebGL|WebGLActiveInfo|WebGLBuffer
            |WebGLContextEvent|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLRenderingContext|WebGLShader|WebGLShaderPrecisionFormat
            |WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLUniformLocation|WebGLVertexArrayObject|WebGLVertexArrayObjectOES
            |WebSocket|WebSockets|WebVTT|WheelEvent|Window|WindowBase64|WindowEventHandlers|WindowTimers|Worker|WorkerGlobalScope
            |WorkerLocation|WorkerNavigator|XMLHttpRequest|XMLHttpRequestEventTarget|XMLSerializer|XPathExpression|XPathResult
            |XSLTProcessor)
          \b
        end: (?=.)
        name: support.class.dom.somra
        beginCaptures:
          1: {name: support.class.dom.somra}
  support-properties:
    patterns:
      - match: |-
          (?<=\.)\s*\b
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          \b\s*
        name: support.variable.property.dom.somra
      - match: |-
          (?x)(?<=\.)\s*\b (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName    |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop    |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor    |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption    |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear    |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete    |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset    |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
              |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
              |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
              |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
              |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
              |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
              |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
              |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
              |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
              |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
              |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
              |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
              |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
              |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
              |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
              |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
              |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
              |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
              |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
          \b\s*
        name: support.variable.property.dom.somra
      - match: (?x)(?<=\.)\s*\b (module|exports|id|filename|loaded|parent|children) \b\s*
        name: support.type.object.module.somra
  support-python:
    patterns:
      - match: |-
          (?x)
            (?<![\#\.]) \s*+ \b(
              __import__ | abs | all | any | ascii | bin | breakpoint | callable
              | chr | compile | copyright | credits | delattr | dir | divmod
              | enumerate | eval | exec | exit | filter | format | getattr
              | globals | hasattr | hash | help | hex | id | input
              | isinstance | issubclass | iter | len | license | locals | map
              | max | memoryview | min | next | oct | open | ord | pow | print
              | quit | range | reload | repr | reversed | round
              | setattr | sorted | sum | vars | zip
            )\b
        name: support.function.builtin.somra
      - match: |-
          (?x)
            (?<![\#\.]) \s*+ \b(
              file | reduce | intern | raw_input | unicode | cmp | basestring
              | execfile | long | xrange
            )\b
        name: variable.legacy.builtin.somra
      - match: |-
          (?x)
            (?<![\#\.]) \s*+ \b(
              bool | bytearray | bytes | classmethod | complex | dict
              | float | frozenset | int | list | object | property
             | slice | staticmethod | str | tuple | type
              (?# Although 'super' is not a type, it's related to types,
                  and is special enough to be highlighted differently from
                  other built-ins)
              | super
            )\b
        name: support.type.primitive.somra
      - comment: |-
          these methods have magic interpretation by python and are generally called
          indirectly through syntactic constructs
        match: |-
          (?x)
           \s*+ \b(
              _*(?:
                abs | add | aenter | aexit | aiter | and | anext | await
                | bool | call | ceil | cmp | coerce | complex | contains
                | copy | deepcopy | del | delattr | delete | delitem
                | delslice | dir | div | divmod | enter | eq | exit | float
                | floor | floordiv | format | ge | get | getattr
                | getattribute | getinitargs | getitem | getnewargs
                | getslice | getstate | gt | hash | hex | iadd | iand | idiv
                | ifloordiv | ilshift | imod | imul | index | init
                | instancecheck | int | invert | ior | ipow | irshift | isub
                | iter | itruediv | ixor | le | len | long | lshift | lt
                | missing | mod | mul | ne | neg | new | next | nonzero | oct | or
                | pos | pow | radd | rand | rdiv | rdivmod | reduce
                | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod
                | rmul | ror | round | rpow | rrshift | rshift | rsub
                | rtruediv | rxor | setattr | setitem | setslice
                | setstate | sizeof | str | sub | subclasscheck | truediv
                | trunc | unicode | xor | matmul | rmatmul | imatmul
                | init_subclass | set_name | fspath | bytes | prepare
              )_*
            )\b
        captures:
          1: {name: support.function.magic.somra}
      - comment: magic variables which a class/module may have.
        match: |-
          (?x)
           \s*+ \b(
              __(?:
                all | bases | builtins | class | class_getitem | code | debug
                | defaults | dict | doc | file | func | kwdefaults | members
                | metaclass | methods | module | mro | mro_entries | name
                | qualname | post_init | self | signature | slots | subclasses
                | version | weakref | wrapped | annotations | classcell
                | spec | path | package | future | traceback
              )__
            )\b
        captures:
          1: {name: support.variable.magic.somra}
  type-argument-brackets:
    patterns:
      - begin: \s*+(<)(?=((?:(?>[^<>]+)|<\g<-1>>)*)>)
        comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        end: \s*(>)
        name: meta.type-arguments.somra
        beginCaptures:
          1: {name: punctuation.somra}
        endCaptures:
          1: {name: punctuation.somra}
        patterns:
          - include: '#typed-parse-types'
          - include: '#comma'
  typed-bracketed-args:
    patterns:
      - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
        comment: Get parameters within a function/method call
        contentName: meta.function.parameters.somra
        end: \s*((\)))
        beginCaptures:
          1: {name: punctuation.definition.parameters.begin.somra}
          2: {name: meta.brace.round.somra}
        endCaptures:
          1: {name: punctuation.definition.parameters.end.somra}
          2: {name: meta.brace.round.somra}
        patterns:
          - include: '#modifiers'
          - include: '#typed-polymorphs'
          - include: '#typed-variable'
  typed-bracketed-parameters:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*+(?=(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(?!\.|:|=>|{|/\*\s*:))
        comment: 'trap balanced parens which are NOT followed by . : => { or /*:'
        end: (?=.)
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.somra}
            endCaptures:
              1: {name: meta.brace.round.somra}
            patterns:
              - include: '#typed-parse-types'
      - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
        comment: Get parameters within a function/method call
        contentName: meta.function.parameters.somra
        end: \s*((\)))
        beginCaptures:
          1: {name: punctuation.definition.parameters.begin.somra}
          2: {name: meta.brace.round.somra}
        endCaptures:
          1: {name: punctuation.definition.parameters.end.somra}
          2: {name: meta.brace.round.somra}
        patterns:
          - include: '#typed-polymorphs'
          - include: '#typed-variable'
  typed-comments:
    patterns:
      - begin: \s*+(/\*)\s*(::)
        end: \s*(\*/)
        name: meta.comments.somra
        beginCaptures:
          1: {name: punctuation.definition.comment.somra}
          2: {name: punctuation.type.somra}
        endCaptures:
          1: {name: punctuation.definition.comment.somra}
        patterns:
          - include: '#typed-comments-optional-parameter'
          - include: '#module'
          - include: '#typed-keywords'
          - include: '#typed-predicate'
          - include: '#typed-parse-types'
          - include: '#function'
          - include: '#keyword-storage'
      - begin: \s*+(/\*)\s*(flow-include)\b
        end: \s*(\*/)
        name: meta.comments.somra
        beginCaptures:
          1: {name: punctuation.definition.comment.somra}
          2: {name: keyword.other.flow-include.somra}
        endCaptures:
          1: {name: punctuation.definition.comment.somra}
        patterns:
          - include: '#typed-comments-optional-parameter'
          - include: '#module'
          - include: '#typed-keywords'
          - include: '#typed-predicate'
          - include: '#typed-parse-types'
          - include: '#function'
          - include: '#keyword-storage'
      - begin: \s*+(/\*)\s*(:)((?=::)|(?![:<=>]))
        end: \s*(\*/)
        name: meta.comments.somra
        beginCaptures:
          1: {name: punctuation.definition.comment.somra}
          2: {name: punctuation.type.somra}
        endCaptures:
          1: {name: punctuation.definition.comment.somra}
        patterns:
          - include: '#typed-predicate'
          - include: '#typed-parse-types'
  typed-comments-optional-parameter:
    patterns:
      - match: (?<=::|flow-include)\s*(\?)
        captures:
          1: {name: keyword.operator.optional.parameter.somra}
  typed-declare:
    patterns:
      - match: (?<![\#\.])\s*+\b(decl?|def)\b\s*+
        captures:
          1: {name: keyword.other.declare.somra}
      - applyEndPatternLast: 1
        begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+\b(module)(.)(exports)(:)((?=::)|(?![:<=>]))
        comment: 'declare module.exports:'
        end: (?=.)
        beginCaptures:
          1: {name: keyword.other.declare.somra}
          2: {name: storage.type.module.somra}
          3: {name: keyword.operator.accessor.somra}
          4: {name: storage.type.module.somra}
          5: {name: punctuation.type.somra}
        patterns:
          - include: '#typed-parse-objects'
          - include: '#typed-parse-types'
      - begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+\b(module)(\s|$)
        comment: declare modules
        end: \s*(?<=})
        beginCaptures:
          1: {name: keyword.other.declare.somra}
          2: {name: storage.type.module.somra}
        patterns:
          - include: '#typed-polymorphs'
          - comment: look for module names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            captures:
              1: {name: entity.name.class.somra}
          - comment: look for module names in quoted string forms
            include: '#string'
          - begin: \s*+({)
            contentName: meta.class.body.somra
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-keywords'
              - include: '#typed-method'
              - include: '#core'
      - begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+(\bexport\b)?\s*+\b(class)\b
        comment: declare classes
        end: \s*(?<=})
        beginCaptures:
          1: {name: keyword.other.declare.somra}
          2: {name: keyword.constrol.module.somra}
          3: {name: storage.type.class.somra}
        patterns:
          - comment: look for extends keyword
            match: \s*+\b((ext))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
          - comment: look for implements keyword
            match: \s*+\b((impl))\b\s*+
            captures:
              1: {name: meta.class.implements.somra}
              2: {name: storage.type.implements.somra}
          - comment: look for mixins keyword
            match: \s*+\b((mix))\b\s*+
            captures:
              1: {name: meta.class.extends.somra}
              2: {name: storage.type.extends.somra}
          - comment: look for class names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
            captures:
              1: {name: entity.name.class.somra}
          - begin: \s*+({)
            contentName: meta.class.body.somra
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.somra}
            endCaptures:
              1: {name: punctuation.section.class.end.somra}
            patterns:
              - include: '#typed-method'
              - include: '#core'
          - include: '#typed-polymorphs'
          - include: '#comma'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.somra}
  typed-interface:
    begin: (?<![\#\.])\s*+\b(inter|schema|struct)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.interface.somra}
    endCaptures:
      1: {name: keyword.operator.assignment.somra}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.somra}
          2: {name: storage.type.extends.somra}
          3: {name: storage.type.implements.somra}
          4: {name: keyword.operator.expression.only.somra}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.interface.somra
      - include: '#types'
      - begin: \s*+({)
        contentName: meta.class.body.somra
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.somra}
        endCaptures:
          1: {name: punctuation.section.class.end.somra}
        patterns:
          - include: '#typed-method'
          - include: '#core'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.somra}
      - include: '#core'
  typed-keywords:
    patterns:
      - include: '#typed-declare'
      - include: '#typed-type-aliases'
      - include: '#typed-interface'
  typed-method:
    applyEndPatternLast: 1
    begin: (?<!:)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
    comment: 'trap methods without a name  e.g.   <Key, Value>(): Map<Key, Value>'
    end: \s*(?=.)
    beginCaptures:
      1: {name: storage.modifier.somra}
      2: {name: storage.type.somra}
      3: {name: keyword.generator.asterisk.somra}
    patterns:
      - include: '#types'
  typed-object-property:
    patterns:
      - comment: Only these props syntax {| |}
        match: ((\|)(?={|))|(\s*(\|)(?=}))
        captures:
          1: {name: keyword.operator.only.somra}
          4: {name: keyword.operator.only.somra}
      - include: '#method'
      - include: '#comments'
      - include: '#typed-variable'
  typed-parse-array:
    patterns:
      - begin: (?<!=|[$_A-Za-z\d])\s*+(#\[)
        comment: 'arrays such as [name: string, dob: Date]'
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.open.somra}
        endCaptures:
          1: {name: meta.brace.square.end.somra}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*(?=[_$[:alpha:]][_$[:alnum:]]*\s*[=:])
            comment: destructring in arrays requires vars parse before types
            end: (?=.)
            patterns:
              - include: '#typed-variable'
              - include: '#typed-parse-types'
          - include: '#typed-parse-types'
          - include: '#typed-variable'
      - begin: (?<!=|[$_A-Za-z\d])\s*+(\[)
        comment: 'arrays such as [name: string, dob: Date]'
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.open.somra}
        endCaptures:
          1: {name: meta.brace.square.end.somra}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*(?=[_$[:alpha:]][_$[:alnum:]]*\s*[=:])
            comment: destructring in arrays requires vars parse before types
            end: (?=.)
            patterns:
              - include: '#typed-variable'
              - include: '#typed-parse-types'
          - include: '#typed-parse-types'
          - include: '#typed-variable'
  typed-parse-objects:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=:|\||&|\?|=>|<|\()\s*+(\#{)
        comment: 'object literal ts  preceded by either => : | & ? symbols'
        end: \s*(\})
        name: meta.object.somra
        beginCaptures:
          1: {name: meta.brace.curly.open.somra}
        endCaptures:
          1: {name: meta.brace.curly.close.somra}
        patterns:
          - include: '#typed-object-property'
      - applyEndPatternLast: 1
        begin: (?<=:|\||&|\?|=>|<|\()\s*+({)
        comment: 'object literal ts  preceded by either => : | & ? symbols'
        end: \s*(\})
        name: meta.object.somra
        beginCaptures:
          1: {name: meta.brace.curly.open.somra}
        endCaptures:
          1: {name: meta.brace.curly.close.somra}
        patterns:
          - include: '#typed-object-property'
  typed-parse-types:
    patterns:
      - include: '#for-all-clause'
      - include: '#modifiers'
      - include: '#keywords'
      - include: '#number'
      - include: '#string'
      - include: '#regexp'
      - include: '#regexp-multiline'
      - match: (?<![\#\.])\s*+\b(typeof|nameof|infer|keyof|extends)\b\s*+
        captures:
          1: {name: keyword.operator.expression.$1.somra}
      - include: '#language-constant'
      - comment: primitive types
        match: (?i)(?<![\#\.])\s*+\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func))\b
        captures:
          1: {name: support.type.builtin.primitive.somra}
      - comment: built-in variable types
        match: (?i)(?<![\#\.])\s*+\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|unit|buff))\b
        captures:
          1: {name: support.type.builtin.somra}
      - comment: custom Shout-case types
        match: \s*+\b([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)\b
        name: support.type.builtin.somra
      - comment: custom Class Types e.g. Abc avoid Abc(
        match: \s*+\b([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\b
        name: support.type.class.somra
      - comment: custom primitive/var Types e.g. abc avoid abc(
        match: \s*+\b([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\b
        name: support.type.primitive.somra
      - comment: Immutable modifier
        match: \s*#(?!\p{Ps})\s*
        name: keyword.operator.private.somra
      - match: (?<==>)\*
        name: keyword.generator.asterisk.somra
      - comment: Maybe types
        match: \s*+(\?)
        captures:
          1: {name: keyword.operator.maybe.somra}
      - comment: symmetric difference of types &
        match: \s*+(\^)
        captures:
          1: {name: keyword.operator.bitwise.somra}
      - comment: complement of types ~
        match: \s*+(\~)
        captures:
          1: {name: keyword.operator.logical.somra}
      - comment: Type Unions |
        match: \s*+(\|)(?<!{\|)(?!}|>)
        captures:
          1: {name: keyword.operator.union.somra}
      - comment: intersection of types &
        match: \s*+(\&)
        captures:
          1: {name: keyword.operator.intersection.somra}
      - comment: as per React declares in ts github
        match: \s*+(\*)(?!/([^\*]|$))
        captures:
          1: {name: keyword.operator.existential.somra}
      - comment: 'types of type marker e.g. <T: number | string>'
        match: \s*+(:)((?=::)|(?![:<=>]))
        name: punctuation.type.somra
        captures:
          1: {name: support.type.builtin.primitive.somra}
      - comment: call back with a form () => type
        match: (?<=\))\s*+(=>)
        captures:
          1: {name: storage.type.function.arrow.somra}
      - comment: Built-in Class Types
        match: (?!^)\s*+\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
        captures:
          1: {name: support.type.builtin.class.somra}
      - match: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        captures:
          2: {name: support.type.builtin.class.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: support.type.builtin.class.somra}
      - match: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        captures:
          2: {name: support.type.builtin.class.somra}
          4: {name: keyword.operator.accessor.somra}
          5: {name: support.type.builtin.class.somra}
      - include: '#typed-polymorphs'
      - include: '#typed-bracketed-parameters'
      - include: '#typed-parse-objects'
      - include: '#typed-parse-array'
      - include: '#square-brackets'
      - include: '#comments'
    repository:
      as-clause:
        begin: (?<![\#\.])\s*\b(as)\b\s*
        end: (?<![\#\.])\s*\b(?=where)
        beginCaptures:
          1: {name: keyword.control.forall.somra}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
          - include: '#as-clause'
          - include: '#case-separator'
          - include: '#typed-parse-types'
      case-separator:
        begin: ([,;])
        end: (?<![\#\.])\s*\b(?=as|where)
        beginCaptures:
          1: {patterns: [{include: '#core'}]}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
          - include: '#as-clause'
          - include: '#case-separator'
          - include: '#core'
      for-all-clause:
        begin: (?<![\#\.])\s*+\b(for\s*all)\b\s*
        comment: for all clause
        end: ^\s*|$|(?=;|,|\p{Pe})
        beginCaptures:
          1: {name: keyword.control.forall.somra}
        patterns:
          - begin: (?<![\#\.])\s*+\b(where)\b
            end: ^\s*|$|(?=;|,|\p{Pe})
            beginCaptures:
              1: {name: keyword.control.forall.somra}
            patterns:
              - include: '#comments'
              - include: '#core'
          - match: (?<![\#\.])\s*+\b(va[rl]|const|con|let)\b\s*+
            name: storage.type.somra
          - include: '#as-clause'
          - include: '#core'
  typed-polymorphs:
    comment: Support Bounded Polymorphism http://ts.org/blog/2015/03/12/Bounded-Polymorphism.html
    patterns:
      - begin: \s*+\b((?>Array|Class|Map|Promise|Set|WeakMap|WeakSet))\s*+(<)
        comment: Built-in Class Types with elements of type <T>
        end: \s*(>)
        beginCaptures:
          1: {name: support.type.builtin.class.somra}
          2: {name: punctuation.somra}
        endCaptures:
          1: {name: punctuation.somra}
        patterns:
          - include: '#comma'
          - match: \s*+(\+|-)
            captures:
              1: {name: support.type.variant.somra}
          - include: '#typed-parse-types'
      - begin: \s*+(<)
        comment: just the polymorph bit like this <K,V>(arg,arg)
        end: \s*(>)
        beginCaptures:
          1: {name: punctuation.somra}
        endCaptures:
          1: {name: punctuation.somra}
        patterns:
          - include: '#comma'
          - match: \s*+(\+|-)
            captures:
              1: {name: support.type.variant.somra}
          - include: '#typed-parse-types'
  typed-predicate:
    applyEndPatternLast: 1
    begin: \s*+(?<=\s)(%checks)\b
    comment: flow predicate checks
    end: (?=.)
    beginCaptures:
      1: {name: entity.name.function.predicate.somra}
    patterns:
      - include: '#round-brackets'
  typed-return:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=\))\s*+(:)((?=::)|(?![:<=>]))
        comment: maybe an issue if a object literal is returned and the start of func block isn't on same line!
        end: (?=.)
        beginCaptures:
          1: {name: punctuation.type.somra}
        patterns:
          - include: '#typed-predicate'
          - include: '#typed-parse-types'
      - include: '#typed-predicate'
  typed-trap:
    comment: traps ts vars that aren't caught normally - e.g. multi-line arrow funcs
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=\))\s*(?=:)
        end: (?=.)
        patterns:
          - include: '#typed-return'
      - applyEndPatternLast: 1
        begin: \s*:(?!:)
        end: (?=.)
        patterns:
          - include: '#typed-parse-types'
  typed-type-aliases:
    applyEndPatternLast: 1
    begin: (?<=^|;|\S)\s*+\b(opaque)?\s*+\b(type|alias)\b\s+(?!(i[sn])\b)(?=[$_A-Za-z{\[])
    comment: type aliases for export but avoid type instaceof or type in operators
    end: $|(?=;|,|\p{Pe})
    beginCaptures:
      1: {name: keyword.other.typedef.somra}
      2: {name: keyword.other.typedef.somra}
    patterns:
      - include: '#typed-parse-types'
      - include: '#types'
      - include: '#comments'
      - include: '#typed-function-name'
      - include: '#operator'
      - include: '#operators'
      - match: \s*+(=)(?!=|>)
        captures:
          1: {name: keyword.operator.assignment.somra}
      - include: '#punctuation'
  typed-variable:
    patterns:
      - comment: 'e.g. let a: ()=>null  =  function() {return null}'
        match: (?<![\#\.])\s*+(\#?)((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)\s*+(\??)\s*+(?=:\s*([_\\\p{L}\p{Nl}](?:[.\\_\\p{L}\p{M}\p{N}])*+)?\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\b(?:[fF]unc?|[fF]n)\b|(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*=>|\(\s*$))
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: storage.type.function.somra}
          3: {name: keyword.operator.optional.parameter.somra}
      - comment: 'name of variable spread var with optional ? and optional ts :'
        match: ((?<![\#\.])\.\.\.)?\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\??)\s*+(?!::)(?=:|=>)
        captures:
          1: {name: keyword.operator.spread.somra}
          2: {name: keyword.operator.private.somra}
          3: {name: variable.other.readwrite.somra}
          4: {name: keyword.operator.optional.parameter.somra}
      - include: '#typed-vars-and-props'
  typed-vars-and-props:
    patterns:
      - comment: 'ts optional arg/parameter e.g. protocol? : string'
        match: \s*+(\?)
        captures:
          1: {name: punctuation.type.somra}
      - comment: Type Unions |
        match: \s*+(\|)(?<!{\|)(?!}|>)
        captures:
          1: {name: keyword.operator.union.somra}
      - comment: intersection of types &
        match: \s*+(\&)
        captures:
          1: {name: keyword.operator.intersection.somra}
      - applyEndPatternLast: 1
        begin: \s*+(:)((?=::)|(?![:<=>]))
        comment: 'typed entity :'
        end: (?=.)|$
        beginCaptures:
          1: {name: punctuation.type.somra}
        patterns:
          - include: '#typed-parse-types'
      - include: '#comma'
      - comment: An Iterator prefix?
        match: \s*+(@@)
      - applyEndPatternLast: 1
        begin: \s*+(=>)
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.function.arrow.somra}
        patterns:
          - include: '#typed-parse-types'
      - begin: (?<!let|const|var|val|def|con)(?<=[_\\p{L}\p{M}\p{N}])\s+(?=\b(?:of|in)\b)
        comment: varname of|in
        end: \s*(?=[,;\p{Pe}]|\*/|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert))
        patterns:
          - include: '#core'
      - begin: (?<!:)\s*+(?=((\#?)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*=)(?!=>|==)
        comment: assignment var = or =
        end: \s*(?=[,;\p{Pe}]|\*/|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)
        patterns:
          - include: '#core'
      - include: '#typed-bracketed-parameters'
      - include: '#typed-parse-array'
      - include: '#core'
  types:
    patterns:
      - include: '#comments'
      - include: '#typed-return'
      - include: '#typed-polymorphs'
      - include: '#typed-bracketed-args'
  variable:
    patterns:
      - comment: e.g. dollar vars
        match: \s*+(\#?)([_\\][_\\\p{L}\p{M}\p{N}]+)
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.dollar.somra}
      - comment: e.g. CONSTANT
        match: \s*+(\#?)(_|[\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)(?!\p{Ll})
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.constant.somra}
      - comment: e.g. Class
        match: \s*+(\#?)\b([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.class.somra}
      - comment: e.g. obj.property
        match: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*+[!?~]?\[|\s*+[!?~]?\.|->)
        name: variable.other.object.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.object.somra}
      - comment: e.g. obj.property
        match: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
        name: meta.property.object.somra
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.property.somra}
      - match: \s*+(\#?)([\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|\\)
        captures:
          1: {name: keyword.operator.private.somra}
          2: {name: variable.other.readwrite.somra}
  variable-typed:
    patterns:
      - begin: (?<=^|,|\()\s*+(?=(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*\??\s*(:)((?=::)|(?![:<=>])))
        comment: Assume this is a flow typed var
        end: \s*(?=,|\))
        beginCaptures:
          3: {name: punctuation.somra}
        patterns:
          - include: '#typed-variable'
      - begin: (?<=^|,|\()\s*+(?="[^"]"\s*(:))
        comment: Assume this is a flow typed var
        end: \s*(?>=|\))
        beginCaptures:
          3: {name: punctuation.somra}
        patterns:
          - include: '#typed-variable'
      - begin: (?<=^|,|\()\s*+(?='[^']'\s*(:))
        comment: Assume this is a flow typed var
        end: \s*(?>=|\))
        beginCaptures:
          3: {name: punctuation.somra}
        patterns:
          - include: '#typed-variable'
limitLineLength: false
