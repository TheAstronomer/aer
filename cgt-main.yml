comment: ([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
firstLineMatch: ^#!\s*/.*\b(cgt?|cogito)$\n?
foldingEndMarker: (\*/|\}|\))
foldingStartMarker: (/\*|{|\()
information_for_contributors: |
  This file is a fork of the Babel JavaScript grammar file and features many syntax
  edits/customizations for Cogito, a programming I am working on (sometime in the near 
  future). This syntax is experimental and is still in the works.

  Cogito is a programming language that combines the best* features of JavaScript and 
  Python, as well as many features you crave from many paradigms and languages.

  Should you want to provide a fix or improvement, or even a new feature,
  please create a pull request against this repo: https://github.com/NoxUltima/saga,
  and I will be very happy to receive them.

  TODOs:
    - Fix generics in function/method calls 
    - Revamp regex syntax (more syntax scopes for constructs)
    
  Unresolved:
    - As of the moment, custom binary operators do not capture combinations of /[</>]+/,
      except those leading in either characters, such as <!, >* and /%. Several of 
      those can be captured within a single string: <!>*
      This is done to avoid confusion with JSX <></> and multiline regex syntax. /></></
      Might need some help here (scroll to section `operators`.)

  Fixed: 
    - (JSDoc/CogitoDoc) block comments can now support Markdown.
    - \ is the new $. $ has been repurposed as the binary function operator.
    - New numeric literals for bases 2 to 64. Higher bases use special Latin 
      and Greek letters.
    - Functions, classes and methods are grouped by their initial starting letter. 
      Cogito has no standard library yet, and uses Python built-in functions and methods.
    - Old JavaScript keywords now removed, and long keywords such as `protected`
      are shortened.
name: Cogito
scopeName: source.nearley
fileTypes:
  - cgt
  - cogito
  - cg
  - ne
patterns:
  - include: '#core'
repository:
  arrow-expression:
    begin: (?<==>)\s*$
    comment: or inside a class def on a ; or braced block } end of line or ;
    end: (?=\s*([,;}]|$))|(?<=})
    patterns:
      - include: '#core'
  arrow-function:
    patterns:
      - begin: >-
          \s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.cgt
        beginCaptures:
          1: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. arg => { }
        match: \s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.arrow.cgt
        captures:
          1: {name: storage.type.cgt}
          2: {name: meta.function.parameters.cgt}
          3: {name: variable.other.readwrite.cgt}
          4: {name: storage.type.function.arrow.cgt}
      - include: '#arrow-function-simple-assignments'
      - begin: >-
          \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: Sound.prototype.play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.prototype.function.arrow.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: variable.language.prototype.cgt}
          6: {name: keyword.operator.existential.cgt}
          7: {name: keyword.operator.accessor.cgt}
          8: {name: keyword.operator.private.cgt}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.cgt}
          11: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. Sound.prototype.play = arg => { }
        match: >-
          \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?\s*(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(=>)
        name: meta.prototype.function.arrow.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: variable.language.prototype.cgt}
          6: {name: keyword.operator.existential.cgt}
          7: {name: keyword.operator.accessor.cgt}
          8: {name: keyword.operator.private.cgt}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.cgt}
          11: {name: storage.type.cgt}
          12: {name: variable.other.readwrite.cgt}
          13: {name: storage.type.function.arrow.cgt}
      - begin: >-
          \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. Sound.play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.static.arrow.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: keyword.operator.private.cgt}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.cgt}
          8: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. Sound.play = arg => { }
        match: >-
          \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(=>)
        name: meta.function.static.arrow.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: keyword.operator.private.cgt}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.cgt}
          8: {name: storage.type.cgt}
          9: {name: variable.other.readwrite.cgt}
          10: {name: storage.type.function.arrow.cgt}
  arrow-function-labels:
    patterns:
      - include: '#async-arrow-function-labels'
      - begin: >-
          (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: 'e.g. play: async <T>(args) => { }'
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.cgt
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.cgt}
          3: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: 'e.g. play: arg => { }'
        match: >-
          (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.json.arrow.cgt
        captures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: keyword.operator.assignment.cgt}
          3: {name: storage.type.cgt}
          4: {name: meta.function.parameters.cgt}
          5: {name: variable.other.readwrite.cgt}
          6: {name: storage.type.function.arrow.cgt}
      - begin: >-
          (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: 'e.g. ''play'': (args) => { }'
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.cgt
        beginCaptures:
          1: {name: string.quoted.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.cgt}
          5: {name: punctuation.separator.key-value.cgt}
          6: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: 'e.g. ''play'': arg => { }'
        match: >-
          (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.json.arrow.cgt
        captures:
          1: {name: string.quoted.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.cgt}
          5: {name: keyword.operator.assignment.cgt}
          6: {name: storage.type.cgt}
          7: {name: meta.function.parameters.cgt}
          8: {name: variable.other.readwrite.cgt}
          9: {name: storage.type.function.arrow.cgt}
  arrow-function-simple-assignments:
    patterns:
      - include: '#async-arrow-function-simple-assignments'
      - begin: >-
          \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=(\s*+<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
        comment: e.g. play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.cgt}
          4: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - comment: e.g. play = arg => { }
        match: >-
          \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))\s*(=>)
        name: meta.function.arrow.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.cgt}
          4: {name: storage.type.cgt}
          5: {name: meta.function.parameters.cgt}
          6: {name: variable.other.readwrite.cgt}
          7: {name: storage.type.function.arrow.cgt}
  async-arrow-function-labels:
    patterns:
      - begin: >-
          (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: 'e.g. play: async <T>('
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.cgt
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.cgt}
          3: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: 'e.g. ''play'': async <T>('
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.json.arrow.cgt
        beginCaptures:
          1: {name: string.quoted.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.cgt}
          5: {name: punctuation.separator.key-value.cgt}
          6: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
  async-arrow-function-simple-assignments:
    patterns:
      - begin: >-
          \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(?:(\basync)\s+)(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g. play = (args) => { }
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.cgt}
          4: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
  brackets:
    patterns:
      - include: '#round-brackets'
      - include: '#square-brackets'
      - include: '#curly-brackets'
  cast-expression:
    match: (?x)(\()\s*(.*)\s*(\))(?=\s*[\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]*?[-_\\\p{L}\p{M}\p{N}\p{Ps}\p{Pe}])
    captures:
      1: {name: punctuation.definition.cast.begin.cgt}
      2: {patterns: [{include: '#flowtype-parse-types'}]}
      3: {name: punctuation.definition.cast.end.cgt}
  catch:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(try|catch|rescue|finally)\b\s*(await)?\b
        end: \s*((?<=[});])|(?=\b(try|catch|rescue|finally)\b))
        name: meta.catch.cgt
        beginCaptures:
          1: {name: keyword.control.trycatch.cgt}
          2: {name: keyword.control.flow.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#curly-brackets'
          - include: '#type-argument-brackets'
          - include: $self
  class:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b((class))\s+
        comment: Classes
        end: \s*(=(?!=|>))|\s*(?<=})
        beginCaptures:
          1: {name: meta.class.cgt}
          2: {name: storage.type.class.cgt}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - match: \s*+\b((ext)|(impl)|(only))\b\s*+
            captures:
              1: {name: meta.class.extends.cgt}
              2: {name: storage.type.extends.cgt}
              3: {name: storage.type.implements.cgt}
              4: {name: keyword.operator.expression.only.cgt}
          - comment: look for interface names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
            name: entity.name.class.cgt
          - include: '#flowtype'
          - begin: \s*+({)
            contentName: meta.class.body.cgt
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.cgt}
            endCaptures:
              1: {name: punctuation.section.class.end.cgt}
            patterns:
              - include: '#flowtype-method'
              - include: '#class-content'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.cgt}
          - include: '#core'
  class-body:
    patterns:
      - include: '#core'
      - include: '#attributes'
      - include: '#modifiers'
      - include: '#flowtype-keywords'
      - include: '#arrow-expression'
      - include: '#arrow-function-simple-assignments'
      - include: '#arrow-function'
      - include: '#brackets'
      - include: '#es7-decorators'
      - include: '#comments'
      - comment: 'handle class fields with no flow types like var = '
        match: (?<!:)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(?==)(?!=>|==)
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.readwrite.cgt}
      - begin: \s*+(?==[^=>])
        comment: a line starts with a static, [, name(, name:, name=, } or a semi-colon anywhere
        end: >-
          ((?=^\s*(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+\??\s*+(:|=(?!^==|=>))|\[|((?:(\#?)[_\\p{L}\p{Nl}])(?:[(\#?)_\\p{L}\p{M}\p{N}])*+)\s*+\(|\b(static|async)\b)|}))|\s*(;)
        endCaptures:
          9: {name: punctuation.terminator.statement.cgt}
        patterns:
          - include: '#method'
          - include: '#core'
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(static)\b(?!\.)
        captures:
          1: {name: storage.modifier.cgt}
      - include: '#flowtype-variable'
      - include: '#semi-colon'
  class-content:
    patterns:
      - include: '#core'
  comma:
    patterns:
      - match: \s*+(,)
        captures:
          1: {name: meta.delimiter.comma.cgt}
  comments:
    repository:
      nested:
        begin: /\*
        end: \*/
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested'
    patterns:
      - include: '#flowtype-comments'
      - include: '#special-comments-conditional-compilation'
      - begin: \s*+((/\*\*))(?!/|\*)
        contentName: comment.block.documentation.cgt
        end: (\s*(\*/))
        captures:
          1: {name: comment.block.documentation.cgt}
          2: {name: punctuation.definition.comment.cgt}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested'
      - begin: \s*+((/\*))
        contentName: comment.block.cgt
        end: (\s*(\*/))
        captures:
          1: {name: comment.block.cgt}
          2: {name: punctuation.definition.comment.cgt}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested'
      - begin: \s*+(<!--)
        contentName: comment.block.html.cgt
        end: \s*+(-->)
        beginCaptures:
          1: {name: punctuation.definition.comment.cgt}
        endCaptures:
          1: {name: punctuation.definition.comment.cgt}
      - begin: ((^\s*)|\s*)((///))
        comment: leading whitespace on a new line comment is scoped so Atom reflow works
        contentName: comment.line.triple-slash.cgt
        end: \s*$
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.cgt}
          3: {name: comment.line.triple-slash.cgt}
          4: {name: punctuation.definition.comment.cgt}
        endCaptures:
          0: {name: comment.line.triple-slash.cgt}
      - begin: ((^\s*)|\s*)((//))
        comment: leading whitespace on a new line comment is scoped so Atom reflow works
        contentName: comment.line.double-slash.cgt
        end: \s*$
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.cgt}
          3: {name: comment.line.double-slash.cgt}
          4: {name: punctuation.definition.comment.cgt}
        endCaptures:
          0: {name: comment.line.double-slash.cgt}
      - match: ^(\#!).*$\n?
        name: comment.line.shebang.cgt
        captures:
          1: {name: punctuation.definition.comment.cgt}
  core:
    patterns:
      - include: '#for'
      - include: '#if'
      - include: '#switch'
      - include: '#match'
      - include: '#catch'
      - include: '#with'
      - include: '#do'
      - comment: before module as it traps default {
        include: '#object'
      - include: '#new'
      - include: '#query'
      - include: '#module'
      - include: '#function'
      - include: '#arrow-function'
      - comment: after function, which includes some prototype strings
        include: '#prototype'
      - include: '#keyword-storage'
      - include: '#method-call'
      - include: '#function-call'
      - include: '#enum-declaration'
      - include: '#operator'
      - include: '#class'
      - include: '#flowtype-keywords'
      - include: '#flowtype-trap'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#multiline-arrow-function-generics'
      - include: '#jsx'
      - include: '#es7-decorators'
      - include: '#js-label'
      - include: '#multiline-regexp'
      - comment: before operators to avoid ambiguities
        include: '#regexp'
      - include: '#number'
      - include: '#quasi'
      - include: '#string'
      - include: '#language-constant'
      - include: '#language-variable'
      - include: '#support'
      - include: '#implicit-call'
      - include: '#cast-expression'
      - include: '#support-properties'
      - include: '#variable'
      - include: '#brackets'
      - include: '#operators'
      - include: '#punctuation'
      - include: '#comments'
      - include: '#fat-arrow'
  curly-brackets:
    patterns:
      - begin: \s*+(#{)
        end: \s*(\})
        beginCaptures:
          1: {name: meta.brace.curly.litobj.cgt}
        endCaptures:
          1: {name: meta.brace.curly.litobj.cgt}
        patterns:
          - include: '#object-body'
      - begin: \s*+({)
        end: \s*(\})
        beginCaptures:
          1: {name: meta.brace.curly.cgt}
        endCaptures:
          1: {name: meta.brace.curly.cgt}
        patterns:
          - include: '#js-label'
          - include: '#core'
  do:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(do)\b\s*(await)?\b
        end: \s*(?<=[})])
        name: meta.do.cgt
        beginCaptures:
          1: {name: keyword.control.do.cgt}
          2: {name: keyword.control.flow.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#round-brackets'
          - include: '#curly-brackets'
          - include: $self
  enum-declaration:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(enum)\s+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?
    end: \s*(=(?!=|>))|\s*(?<=})
    name: meta.enum.declaration.flowtype
    beginCaptures:
      1: {name: storage.type.enum.flowtype}
      2: {name: entity.name.type.enum.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#comments'
          - begin: ([_$[:alpha:]][_$[:alnum:]]*)(?:\s*(=(?!=|>)))?\s*
            end: (?=([,;}])|$)
            beginCaptures:
              1: {name: variable.other.enummember.flowtype}
              2: {name: keyword.operator.assignment.cgt}
            endCaptures:
              1: {patterns: [{include: '#core'}]}
            patterns:
              - include: '#core'
      - include: '#of-clause'
      - include: '#comments'
      - include: '#flowtype-polymorphs'
      - include: '#type-argument-brackets'
      - include: '#core'
  es7-decorators:
    patterns:
      - applyEndPatternLast: 1
        begin: >-
          (?<!@)\s*+(?:(@)(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+)))
        comment: Look for a @identifier start If unicode start uppercase e.g. @A class it as a class
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.decorator.cgt}
          2: {name: keyword.operator.private.cgt}
          3: {name: entity.name.class.decorator.cgt}
          4: {name: variable.other.readwrite.decorator.cgt}
        patterns:
          - begin: \s*(?:(\?\.)|(\.))
            commnent: decorator .property or .method which may be on a different line
            end: >-
              \s*(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+))
            beginCaptures:
              1: {name: keyword.operator.existential.cgt}
              2: {name: keyword.operator.accessor.cgt}
            endCaptures:
              1: {name: keyword.operator.private.cgt}
              2: {name: entity.name.class.decorator.cgt}
              3: {name: variable.other.property.decorator.cgt}
            patterns:
              - include: '#comments'
          - comment: arguments for decorators
            include: '#round-brackets'
          - begin: >-
              (?:(?<=^|;)|(?=\s))\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<!(?<!\.\.)\.|\#)(\#?)((?:[_\\\p{L}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
            comment: 'method that always follow decorators such as play<T,T>(arg1, arg2): Type<T> { }'
            end: (?<=:|})|(?=;|}|,)
            name: meta.function.method.cgt
            beginCaptures:
              1: {name: storage.modifier.cgt}
              2: {name: storage.type.cgt}
              3: {name: keyword.generator.asterisk.cgt}
              4: {name: keyword.operator.private.cgt}
              5: {name: entity.name.function.method.cgt}
            patterns:
              - include: '#flowtype'
              - include: '#curly-brackets'
              - include: '#class-content'
              - include: $self
          - include: '#comments'
          - match: |
              \s*
  es7-function-bind:
    patterns:
      - comment: https://github.com/zenparsing/es-function-bind#examples
        match: \s*(::)
        captures:
          1: {name: keyword.operator.accessor.cgt}
  esnext-pipeline:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(\+>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.pipeline.cgt}
        patterns:
          - match: >-
              (?<=\+>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: meta.function-call.without-arguments.cgt}
              4: {patterns: [{include: '#function-name'}]}
          - match: >-
              \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: meta.method-call.without-arguments.cgt}
              4: {patterns: [{include: '#method-name'}]}
          - match: >-
              \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: variable.other.object.cgt}
              4: {name: keyword.operator.existential.cgt}
              5: {name: keyword.operator.accessor.cgt}
          - include: '#comments'
      - applyEndPatternLast: 1
        begin: \s*(\|>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
        end: (?=.)
        beginCaptures:
          1: {name: keyword.operator.pipeline.cgt}
        patterns:
          - match: >-
              (?<=\|>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: meta.function-call.without-arguments.cgt}
              4: {patterns: [{include: '#function-name'}]}
          - match: >-
              \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: meta.method-call.without-arguments.cgt}
              4: {patterns: [{include: '#method-name'}]}
          - match: >-
              \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
            captures:
              2: {name: keyword.operator.private.cgt}
              3: {name: variable.other.object.cgt}
              4: {name: keyword.operator.existential.cgt}
              5: {name: keyword.operator.accessor.cgt}
          - include: '#comments'
      - match: \s*(\|>|\+>)
        captures:
          1: {name: keyword.operator.pipeline.cgt}
  fat-arrow:
    comment: trap fat-arrow
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(=>)
        comment: match arrow func symbol
        end: (?=.)
        beginCaptures:
          1: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: $self
  fat-arrow-braced-body:
    begin: \s*(=>)\s*({)
    comment: ' => {'
    end: \s*(})
    beginCaptures:
      1: {name: storage.type.function.arrow.cgt}
      2: {name: meta.brace.curly.cgt}
    endCaptures:
      1: {name: meta.brace.curly.cgt}
    patterns:
      - include: $self
  flowtype:
    patterns:
      - include: '#comments'
      - include: '#flowtype-return'
      - include: '#flowtype-polymorphs'
      - include: '#flowtype-bracketed-args'
  flowtype-bracketed-args:
    patterns:
      - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
        comment: Get parameters within a function/method call
        contentName: meta.function.parameters.cgt
        end: \s*((\)))
        beginCaptures:
          1: {name: punctuation.definition.parameters.begin.cgt}
          2: {name: meta.brace.round.cgt}
        endCaptures:
          1: {name: punctuation.definition.parameters.end.cgt}
          2: {name: meta.brace.round.cgt}
        patterns:
          - include: '#modifiers'
          - include: '#flowtype-polymorphs'
          - include: '#flowtype-variable'
  flowtype-bracketed-parameters:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*+(?=(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(?!\.|:|=>|{|/\*\s*:))
        comment: 'trap balanced parens which are NOT followed by . : => { or /*: '
        end: (?=.)
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.cgt}
            endCaptures:
              1: {name: meta.brace.round.cgt}
            patterns:
              - include: '#flowtype-parse-types'
      - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
        comment: Get parameters within a function/method call
        contentName: meta.function.parameters.cgt
        end: \s*((\)))
        beginCaptures:
          1: {name: punctuation.definition.parameters.begin.cgt}
          2: {name: meta.brace.round.cgt}
        endCaptures:
          1: {name: punctuation.definition.parameters.end.cgt}
          2: {name: meta.brace.round.cgt}
        patterns:
          - include: '#flowtype-polymorphs'
          - include: '#flowtype-variable'
  flowtype-comments:
    patterns:
      - begin: \s*+(/\*)\s*(::)
        end: \s*(\*/)
        name: meta.comments.flowtype
        beginCaptures:
          1: {name: punctuation.definition.comment.cgt}
          2: {name: punctuation.type.flowtype}
        endCaptures:
          1: {name: punctuation.definition.comment.cgt}
        patterns:
          - include: '#flowtype-comments-optional-parameter'
          - include: '#module'
          - include: '#flowtype-keywords'
          - include: '#flowtype-predicate'
          - include: '#flowtype-parse-types'
          - include: '#function'
          - include: '#keyword-storage'
      - begin: \s*+(/\*)\s*(flow-include)\b
        end: \s*(\*/)
        name: meta.comments.flowtype
        beginCaptures:
          1: {name: punctuation.definition.comment.cgt}
          2: {name: keyword.other.flow-include.flowtype}
        endCaptures:
          1: {name: punctuation.definition.comment.cgt}
        patterns:
          - include: '#flowtype-comments-optional-parameter'
          - include: '#module'
          - include: '#flowtype-keywords'
          - include: '#flowtype-predicate'
          - include: '#flowtype-parse-types'
          - include: '#function'
          - include: '#keyword-storage'
      - begin: \s*+(/\*)\s*(:)((?=::)|(?!:))
        end: \s*(\*/)
        name: meta.comments.flowtype
        beginCaptures:
          1: {name: punctuation.definition.comment.cgt}
          2: {name: punctuation.type.flowtype}
        endCaptures:
          1: {name: punctuation.definition.comment.cgt}
        patterns:
          - include: '#flowtype-predicate'
          - include: '#flowtype-parse-types'
  flowtype-comments-optional-parameter:
    patterns:
      - match: (?<=::|flow-include)\s*(\?)
        captures:
          1: {name: keyword.operator.optional.parameter.flowtype}
  flowtype-declare:
    patterns:
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(decl)\b\s*+
        captures:
          1: {name: keyword.other.declare.flowtype}
      - applyEndPatternLast: 1
        begin: (?<!(?<!\.\.)\.|\#)\s*+\b(decl)\b\s*+\b(module)(.)(exports)(:)((?=::)|(?!:))
        comment: 'declare module.exports:'
        end: (?=.)
        beginCaptures:
          1: {name: keyword.other.declare.flowtype}
          2: {name: storage.type.module.flowtype}
          3: {name: keyword.operator.accessor.flowtype}
          4: {name: storage.type.module.flowtype}
          5: {name: punctuation.type.flowtype}
        patterns:
          - include: '#flowtype-parse-objects'
          - include: '#flowtype-parse-types'
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(decl)\b\s*+\b(module)(\s|$)
        comment: declare modules
        end: \s*(?<=})
        beginCaptures:
          1: {name: keyword.other.declare.flowtype}
          2: {name: storage.type.module.flowtype}
        patterns:
          - include: '#flowtype-polymorphs'
          - comment: look for module names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
            captures:
              1: {name: entity.name.class.cgt}
          - comment: look for module names in quoted string forms
            include: '#string'
          - begin: \s*+({)
            contentName: meta.class.body.cgt
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.cgt}
            endCaptures:
              1: {name: punctuation.section.class.end.cgt}
            patterns:
              - include: '#flowtype-keywords'
              - include: '#flowtype-method'
              - include: '#class-content'
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(decl)\b\s*+(\bexport\b)?\s*+\b(class)\b
        comment: declare classes
        end: \s*(?<=})
        beginCaptures:
          1: {name: keyword.other.declare.flowtype}
          2: {name: keyword.constrol.module.flowtype}
          3: {name: storage.type.class.flowtype}
        patterns:
          - comment: look for extends keyword
            match: \s*+\b((ext))\b\s*+
            captures:
              1: {name: meta.class.extends.cgt}
              2: {name: storage.type.extends.cgt}
          - comment: look for implements keyword
            match: \s*+\b((impl))\b\s*+
            captures:
              1: {name: meta.class.implements.cgt}
              2: {name: storage.type.implements.cgt}
          - comment: look for mixins keyword
            match: \s*+\b((mix))\b\s*+
            captures:
              1: {name: meta.class.extends.cgt}
              2: {name: storage.type.extends.cgt}
          - comment: look for class names but don't assume uppercase start char
            match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
            captures:
              1: {name: entity.name.class.cgt}
          - begin: \s*+({)
            contentName: meta.class.body.cgt
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.section.class.begin.cgt}
            endCaptures:
              1: {name: punctuation.section.class.end.cgt}
            patterns:
              - include: '#flowtype-method'
              - include: '#class-content'
          - include: '#flowtype-polymorphs'
          - include: '#comma'
          - match: \s*(\.)
            captures:
              1: {name: keyword.operator.accessor.cgt}
  flowtype-extension:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(extn)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.extension.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.extension.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#core'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-given:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(given)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.given.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.given.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#flowtype-method'
          - include: '#class-content'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-interface:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(inter|schema|struct)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.interface.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.interface.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#flowtype-method'
          - include: '#class-content'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-keywords:
    patterns:
      - include: '#flowtype-declare'
      - include: '#flowtype-type-aliases'
      - include: '#flowtype-interface'
      - include: '#flowtype-trait'
      - include: '#flowtype-struct'
      - include: '#flowtype-module'
      - include: '#flowtype-namespace'
      - include: '#flowtype-object'
      - include: '#flowtype-given'
      - include: '#flowtype-extension'
      - include: '#enum-declaration'
  flowtype-method:
    applyEndPatternLast: 1
    begin: (?<!:)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
    comment: 'trap methods without a name  e.g.   <Key, Value>(): Map<Key, Value>'
    end: \s*(?=.)
    beginCaptures:
      1: {name: storage.modifier.cgt}
      2: {name: storage.type.cgt}
      3: {name: keyword.generator.asterisk.cgt}
    patterns:
      - include: '#flowtype'
  flowtype-module:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(module)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.module.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.module.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#core'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-namespace:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(nspace)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.namespace.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.namespace.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#core'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-object:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(object|record)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.object.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.object.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#flowtype-method'
          - include: '#class-content'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
  flowtype-object-property:
    patterns:
      - comment: Only these props syntax {| |}
        match: ((\|)(?={|))|(\s*(\|)(?=}))
        captures:
          1: {name: keyword.operator.only.flowtype}
          4: {name: keyword.operator.only.flowtype}
      - include: '#method'
      - include: '#comments'
      - include: '#flowtype-variable'
  flowtype-parse-array:
    begin: (?<!=|[$_A-Za-z\d])\s*+(#?\[)
    comment: 'arrays such as [name: string, dob: Date]'
    end: \s*(\])
    beginCaptures:
      1: {name: meta.brace.square.open.flowtype}
    endCaptures:
      1: {name: meta.brace.square.end.flowtype}
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(?=[_$[:alpha:]][_$[:alnum:]]*\s*[=:])
        comment: destructring in arrays requires vars parse before types
        end: (?=.)
        patterns:
          - include: '#flowtype-variable'
          - include: '#flowtype-parse-types'
      - include: '#flowtype-parse-types'
      - include: '#flowtype-variable'
  flowtype-parse-objects:
    applyEndPatternLast: 1
    begin: (?<=:|\||&|\?|=>|<|\()\s*+(#?{)
    comment: 'object literal flowtype  preceded by either => : | & ? symbols'
    end: \s*(\})
    name: meta.object.flowtype
    beginCaptures:
      1: {name: meta.brace.curly.open.flowtype}
    endCaptures:
      1: {name: meta.brace.curly.close.flowtype}
    patterns:
      - include: '#flowtype-object-property'
  flowtype-parse-types:
    patterns:
      - include: '#operator'
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(typeof|nameof|infer|keyof|extends)\b\s*+
        captures:
          1: {name: keyword.operator.$1.flowtype}
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(for\s*all)\b\s*
        end: ^\s*|\s*(?=;|/[/*]|$)
        beginCaptures:
          1: {name: keyword.operator.forall.cgt}
        patterns:
          - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(where)\b
            end: ^\s*|\s*(?=;|/[/*]|$)
            beginCaptures:
              1: {name: keyword.operator.forall.cgt}
            patterns:
              - include: '#comments'
              - include: '#core'
          - match: (?<!(?<!\.\.)\.|\#)\s*+\b(va[rl]|const|con|let)\b\s*+
            name: storage.type.cgt
          - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(as)\b
            end: (?=$|;|/[/*]|\s*where)
            beginCaptures:
              1: {name: keyword.operator.forall.cgt}
            patterns:
              - include: '#flowtype-parse-types'
      - comment: Immutable modifier
        match: \s*#(?![(\[{])\s*
        name: keyword.operator.private.cgt
      - begin: (?![!=]==?|=<|=[:!]=)(?==>|=|{)\s*
        comment: There is no = in flowtype
        end: $
        patterns:
          - include: '#core'
      - begin: (?<=[>-_\\\p{L}\p{M}\p{N}])\s+(?=\b(?:of|in)\b)
        comment: Fix of|in
        end: $
        patterns:
          - include: '#core'
      - include: '#number'
      - include: '#string'
      - include: '#language-constant'
      - include: '#regexp'
      - include: '#multiline-regexp'
      - match: (?<==>)\*
        name: keyword.generator.asterisk.cgt
      - include: '#modifiers'
      - begin: (?<=[>-_\\\p{L}\p{M}\p{N}])\s+(?=\b(?:of|in)\b)
        comment: 'sometypename of|in '
        end: >-
          \s*(?=,|;|\)|}|\]|\*/|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\b(async|await)\b\s*+(?!=|:)|type\s+[$\w]+|declare\s+[$\w]+|interface\s+[$\w]+)
        patterns:
          - include: '#core'
      - comment: Maybe types
        match: \s*+(\?)
        captures:
          1: {name: keyword.operator.maybe.flowtype}
      - comment: primitive flowtypes
        match: (?i)(?!^)\s*+\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func))\b
        captures:
          1: {name: support.type.builtin.primitive.flowtype}
      - comment: primitive flowtypes
        match: (?i)(?!^)\s*+\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|unit|buff))\b
        captures:
          1: {name: support.type.builtin.flowtype}
      - comment: Built-in Class Types
        match: >-
          (?!^)\s*+\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
        captures:
          1: {name: support.type.builtin.class.flowtype}
      - match: >-
          \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        captures:
          2: {name: support.type.builtin.class.flowtype}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: support.type.builtin.class.flowtype}
      - match: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        captures:
          2: {name: support.type.builtin.class.flowtype}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: support.type.builtin.class.flowtype}
      - comment: custom Class Types e.g. Abc avoid Abc(
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        captures:
          1: {name: support.type.class.flowtype}
      - comment: custom primitive/var Types e.g. abc avoid abc(
        match: >-
          (?!\s*\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)(?!^)\s*(?<=\s|:|&|\||<)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        captures:
          2: {name: support.type.primitive.flowtype}
      - comment: symmetric difference of types &
        match: \s*+(\^)
        captures:
          1: {name: keyword.operator.bitwise.flowtype}
      - comment: complement of types ~
        match: \s*+(\~)
        captures:
          1: {name: keyword.operator.logical.flowtype}
      - comment: Type Unions |
        match: \s*+(\|)(?<!{\|)(?!}|>)
        captures:
          1: {name: keyword.operator.union.flowtype}
      - comment: intersection of types &
        match: \s*+(\&)
        captures:
          1: {name: keyword.operator.intersection.flowtype}
      - comment: as per React declares in flowtype github
        match: \s*+(\*)(?!/([^\*]|$))
        captures:
          1: {name: keyword.operator.existential.flowtype}
      - comment: 'types of type marker e.g. <T: number | string>'
        match: \s*+(:)((?=::)|(?!:))
        name: punctuation.type.flowtype
        captures:
          1: {name: support.type.builtin.primitive.flowtype}
      - comment: call back with a form  ) => type
        match: (?<=\))\s*+(=>)
        captures:
          1: {name: storage.type.function.arrow.cgt}
      - include: '#flowtype-polymorphs'
      - include: '#flowtype-bracketed-parameters'
      - include: '#flowtype-parse-objects'
      - include: '#flowtype-parse-array'
      - include: '#comments'
  flowtype-polymorphs:
    comment: Support Bounded Polymorphism http://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html
    patterns:
      - begin: \s*+\b((?>Array|Class|Map|Promise|Set|WeakMap|WeakSet))\s*+(<)
        comment: Built-in Class Types with elements of type <T>
        end: \s*(>)
        beginCaptures:
          1: {name: support.type.builtin.class.flowtype}
          2: {name: punctuation.flowtype}
        endCaptures:
          1: {name: punctuation.flowtype}
        patterns:
          - include: '#comma'
          - match: \s*+(\+|-)
            captures:
              1: {name: support.type.variant.flowtype}
          - include: '#flowtype-parse-types'
      - begin: \s*+(<)
        comment: just the polymorph bit like this <K,V>(arg,arg)
        end: \s*(>)
        beginCaptures:
          1: {name: punctuation.flowtype}
        endCaptures:
          1: {name: punctuation.flowtype}
        patterns:
          - include: '#comma'
          - match: \s*+(\+|-)
            captures:
              1: {name: support.type.variant.flowtype}
          - include: '#flowtype-parse-types'
  flowtype-predicate:
    applyEndPatternLast: 1
    begin: \s*+(?<=\s)(%checks)\b
    comment: flow predicate checks
    end: (?=.)
    beginCaptures:
      1: {name: entity.name.function.predicate.flowtype}
    patterns:
      - include: '#round-brackets'
  flowtype-return:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=\))\s*+(:)((?=::)|(?!:))
        comment: maybe an issue if a object literal is returned and the start of func block isn't on same line!
        end: (?=.)
        beginCaptures:
          1: {name: punctuation.type.flowtype}
        patterns:
          - include: '#flowtype-predicate'
          - include: '#flowtype-parse-types'
      - include: '#flowtype-predicate'
  flowtype-struct:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(frag)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.struct.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.struct.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#flowtype-method'
          - include: '#class-content'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-trait:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(trait)(\s+|$)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: keyword.other.trait.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#type-argument-brackets'
      - match: \s*+\b((ext)|(impl)|(only))\b\s*+
        captures:
          1: {name: meta.class.extends.cgt}
          2: {name: storage.type.extends.cgt}
          3: {name: storage.type.implements.cgt}
          4: {name: keyword.operator.expression.only.cgt}
      - comment: look for interface names but don't assume uppercase start char
        match: \s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.type.trait.cgt
      - include: '#flowtype'
      - begin: \s*+({)
        contentName: meta.class.body.cgt
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.cgt}
        endCaptures:
          1: {name: punctuation.section.class.end.cgt}
        patterns:
          - include: '#class-content'
          - include: '#flowtype-method'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.cgt}
      - include: '#core'
  flowtype-trap:
    comment: traps flowtype vars that aren't caught normally - e.g. multi-line arrow funcs
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=\))\s*(?=:)
        end: (?=.)
        patterns:
          - include: '#flowtype-return'
      - applyEndPatternLast: 1
        begin: \s*:(?!:)
        end: (?=.)
        patterns:
          - include: '#flowtype-parse-types'
  flowtype-type-aliases:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<=^|;|\S)\s*+\b(opaque)?\s*+\b(type)\b\s+(?!(i[sn])\b)(?=[$_A-Za-z{\[])
        comment: type aliases for export but avoid type instaceof or type in operators
        end: (?=.)
        beginCaptures:
          1: {name: keyword.other.typedef.flowtype}
          2: {name: keyword.other.typedef.flowtype}
        patterns:
          - begin: \s*+({)
            end: \s*(})
            name: meta.object.flowtype
            captures:
              1: {name: meta.brace.curly.cgt}
            patterns:
              - include: '#flowtype-object-property'
          - include: '#flowtype'
          - include: '#flowtype-parse-types'
          - include: '#comments'
          - include: '#flowtype-function-name'
          - match: \s*+(=)(?!=|>)
            captures:
              1: {name: keyword.operator.assignment.cgt}
  flowtype-variable:
    patterns:
      - comment: 'e.g. let a: ()=>null  =  function() {return null}'
        match: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\#?)((?:[_\\\p{L}\p{Nl}])(?:[-_\\\p{L}\p{M}\p{N}])*+)\s*+(\??)\s*+(?=:\s*([_\\\p{L}\p{Nl}](?:[.\\_\\p{L}\p{M}\p{N}])*+)?\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\b(?:[fF]unc?|[fF]n)\b|(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*=>|\(\s*$))
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: storage.type.function.cgt}
          3: {name: keyword.operator.optional.parameter.flowtype}
      - comment: 'name of variable spread var with optional ? and optional flowtype :'
        match: ((?<!(?<!\.\.)\.|\#)\.\.\.)?\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(\??)\s*+(?!::)(?=:|=>)
        captures:
          1: {name: keyword.operator.spread.cgt}
          2: {name: keyword.operator.private.cgt}
          3: {name: variable.other.readwrite.cgt}
          4: {name: keyword.operator.optional.parameter.flowtype}
      - include: '#flowtype-vars-and-props'
  flowtype-vars-and-props:
    patterns:
      - comment: 'flowtype optional arg/parameter e.g. protocol? : string'
        match: \s*+(\?)
        captures:
          1: {name: punctuation.type.flowtype}
      - comment: Type Unions |
        match: \s*+(\|)(?<!{\|)(?!}|>)
        captures:
          1: {name: keyword.operator.union.flowtype}
      - comment: intersection of types &
        match: \s*+(\&)
        captures:
          1: {name: keyword.operator.intersection.flowtype}
      - applyEndPatternLast: 1
        begin: \s*+(:)((?=::)|(?!:))
        comment: 'typed entity :'
        end: (?=.)
        beginCaptures:
          1: {name: punctuation.type.flowtype}
        patterns:
          - include: '#flowtype-parse-types'
      - include: '#comma'
      - comment: An Iterator prefix?
        match: \s*+(@@)
      - applyEndPatternLast: 1
        begin: \s*+(=>)
        end: (?=.)
        beginCaptures:
          1: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype-parse-types'
      - begin: (?<!let|const|con|va[lr])(?<=[-_\\p{L}\p{M}\p{N}])\s+(?=\b(?:of|in)\b)
        comment: 'varname of|in '
        end: >-
          \s*(?=,|;|\)|}|\]|\*/|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\b(async|await)\b\s*+(?!=|:)|type\s+[$\w]+|declare\s+[$\w]+|interface\s+[$\w]+)
        patterns:
          - include: '#core'
      - begin: (?<!:)\s*+(?=((?:(\#?)[_\\p{L}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)?\s*=)(?!=>|==)
        comment: 'assignment var = or = '
        end: >-
          \s*(?=,|;|\)|}|\]|\*/|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\b(async|await)\b\s*+(?!=|:)|type\s+[$\w]+|declare\s+[$\w]+|interface\s+[$\w]+)
        patterns:
          - include: '#core'
      - include: '#flowtype-bracketed-parameters'
      - include: '#flowtype-parse-array'
      - include: '#core'
  for:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(for|while|until)\b\s*(await)?\b
        end: \s*(?<=[})])
        name: meta.for.cgt
        beginCaptures:
          1: {name: keyword.control.loop.cgt}
          2: {name: keyword.control.flow.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - match: (?<!(?<!\.\.)\.|\#)\s*+\b(in|of|by|to|til)\b
            name: keyword.control.loop.cgt
          - include: '#curly-brackets'
          - include: '#type-argument-brackets'
          - include: '#core'
  function:
    patterns:
      - applyEndPatternLast: 1
        begin: >-
          \s*+(?:\b(async)\b\s+)?\s*+(?:(?<=\.\.\.)|(?<!(?<!\.\.)\.|\#))(\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. function play<T>(arg1, arg2) { }
        end: >-
          \s*(=(?!=|>)|{)|\s*(?<=;|})|\s*(?=,|;|:|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|})
        beginCaptures:
          1: {name: storage.type.cgt}
          2: {name: storage.type.function.cgt}
          3: {name: keyword.generator.asterisk.cgt}
          4: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<!(?<!\.\.)\.|\#)\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. play = function(arg1, arg2) { }
        end: >-
          \s*(=(?!=|>)|{)|\s*(?<=;|})|\s*(?=,|;|:|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|})
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.assignment.cgt}
          4: {name: storage.type.cgt}
          5: {name: storage.type.function.cgt}
          6: {name: keyword.generator.asterisk.cgt}
          7: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\p{Lu}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<!(?<!\.\.)\.|\#)\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. Sound.prototype.play = function(arg1, arg2) { }
        end: >-
          \s*(=(?!=|>)|{)|\s*(?<=;|})|\s*(?=,|;|:|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|})
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: variable.language.prototype.cgt}
          6: {name: keyword.operator.existential.cgt}
          7: {name: keyword.operator.accessor.cgt}
          8: {name: keyword.operator.private.cgt}
          9: {patterns: [{include: '#function-name'}]}
          10: {name: keyword.operator.assignment.cgt}
          11: {name: storage.type.cgt}
          12: {name: storage.type.function.cgt}
          13: {name: keyword.generator.asterisk.cgt}
          14: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\p{Lu}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])\s*+(=)\s*+(?:(async)\s+)?\s*+((?<!(?<!\.\.)\.|\#)\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*|'.*?'|".*?"|\[.*?\])?(?=\s*+(\(|<))
        comment: e.g. Sound.play = function(arg1, arg2) { }
        end: >-
          \s*(=(?!=|>)|{)|\s*(?<=;|})|\s*(?=,|;|:|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|})
        name: meta.function.static.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: keyword.operator.private.cgt}
          6: {patterns: [{include: '#function-name'}]}
          7: {name: keyword.operator.assignment.cgt}
          8: {name: storage.type.cgt}
          9: {name: storage.type.function.cgt}
          10: {name: keyword.generator.asterisk.cgt}
          11: {patterns: [{include: '#function-name'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
  function-call:
    patterns:
      - include: '#comments'
      - comment: A new expression with no type params or arguments, like new Foo()
        match: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\)))
        name: meta.new-class.without-arguments.cgt
        captures:
          1: {name: keyword.operator.new.cgt}
          2: {name: meta.function-call.without-arguments.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: entity.name.type.instance.cgt}
          5: {name: keyword.operator.existential.cgt}
          6: {name: keyword.operator.cascade.cgt}
          7: {name: keyword.operator.assertion.cgt}
          8: {name: keyword.operator.accessor.cgt}
          9: {name: meta.brace.round.cgt}
          10: {name: meta.brace.round.cgt}
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
        comment: A new expression with type params and no arguments, like new Foo<string>()
        end: (?=.)
        name: meta.new-class.without-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.new.cgt}
          2: {name: meta.function-call.without-arguments.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: entity.name.type.instance.cgt}
          5: {name: keyword.operator.existential.cgt}
          6: {name: keyword.operator.cascade.cgt}
          7: {name: keyword.operator.assertion.cgt}
          8: {name: keyword.operator.accessor.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
        comment: A new expression with arguments and maybe type params, like new Foo<string>(123)
        end: (?=.)
        name: meta.new-class.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.new.cgt}
          2: {name: meta.function-call.with-arguments.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: entity.name.type.instance.cgt}
          5: {name: keyword.operator.existential.cgt}
          6: {name: keyword.operator.cascade.cgt}
          7: {name: keyword.operator.assertion.cgt}
          8: {name: keyword.operator.accessor.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - include: '#operators'
      - comment: A call expression with no type params or arguments, like foo()
        match: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\))
        name: meta.function-call.without-arguments.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.cascade.cgt}
          5: {name: keyword.operator.assertion.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {name: meta.brace.round.cgt}
          8: {name: meta.brace.round.cgt}
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\)))
        comment: A call expression with type params and no arguments, like foo<string>()
        end: (?=.)
        name: meta.function-call.without-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.cascade.cgt}
          5: {name: keyword.operator.assertion.cgt}
          6: {name: keyword.operator.accessor.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(?=\s*(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\(\s*+\))
        comment: maybe in array form e.g. foo[bar]() or foo[bar]<string>()
        end: (?=.)
        name: meta.function-call.without-arguments.cgt
        beginCaptures:
          2: {name: keyword.operator.new.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: variable.other.object.cgt}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: A call expression with arguments and maybe type params, like foo(123) or foo<string>(123)
        end: (?=.)
        name: meta.function-call.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#function-name'}]}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.cascade.cgt}
          5: {name: keyword.operator.assertion.cgt}
          6: {name: keyword.operator.accessor.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: maybe in array form e.g. foo[bar](123)
        end: (?=.)
        name: meta.function-call.with-arguments.cgt
        beginCaptures:
          2: {name: keyword.operator.new.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: variable.other.object.cgt}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - include: '#keywords'
  function-labels:
    patterns:
      - begin: >-
          (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(async)\s+)?\s*+((?<!(?<!\.\.)\.|\#)\b(?:defn?|func?|fn|proc|macro)\b)\s*+(?:(\*)\s*)?(?=\s*(\(|<))
        comment: 'e.g. play: function(arg1, arg2) { }'
        end: \s*(=)|\s*(?<=})
        name: meta.function.json.cgt
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: punctuation.separator.key-value.cgt}
          3: {name: storage.type.cgt}
          4: {name: storage.type.function.cgt, patterns: [{include: '#string-content'}]}
          5: {name: keyword.generator.asterisk.cgt}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
      - begin: >-
          (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(async)?\s*+((?<!(?<!\.\.)\.|\#)\b(?:defn?|func?|fn|proc|macro)\b)\s*(\*\s*)?(?=\s*(\(|<))
        comment: 'e.g. ''play'': function(arg1, arg2) { }'
        end: \s*(=)|\s*(?<=})
        name: meta.function.json.cgt
        beginCaptures:
          1: {name: string.quoted.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
          3: {patterns: [{include: '#function-name'}]}
          4: {name: punctuation.definition.string.end.cgt}
          5: {name: punctuation.separator.key-value.cgt}
          6: {name: storage.type.cgt}
          7: {name: storage.type.function.cgt}
          8: {name: keyword.generator.asterisk.cgt}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#core'
          - include: '#curly-brackets'
  function-name:
    patterns:
      - include: '#support-functions'
      - include: '#support-methods'
      - comment: primitive flowtypes
        match: (?i)\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func))\b
        name: support.type.builtin.primitive.flowtype
      - comment: primitive flowtypes
        match: (?i)\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|unit|buff))\b
        name: support.type.builtin.flowtype
      - match: >-
          \b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        name: support.type.builtin.class.flowtype
      - match: (([a-zA-Z])[-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.$2.cgt
      - match: '[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*'
        name: support.type.class.flowtype
      - match: '[_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*'
        name: entity.name.function.cgt
  graphql:
    patterns:
      - include: '#graphql-fragment-definition'
      - include: '#graphql-type-interface'
      - include: '#graphql-enum'
      - include: '#graphql-scalar'
      - include: '#graphql-union'
      - include: '#graphql-schema'
      - include: '#graphql-operation-def'
      - include: '#graphql-comment'
      - include: '#quasi-embedded'
    repository:
      graphql-arguments:
        begin: \s*(\()
        end: \s*(\))
        name: meta.arguments.graphql
        beginCaptures:
          1: {name: meta.brace.round.directive.graphql}
        endCaptures:
          1: {name: meta.brace.round.directive.graphql}
        patterns:
          - include: '#graphql-comment'
          - begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?:\s*(:))?
            end: (?=\s*(?:(?:([_A-Za-z][_\\dA-Za-z]*)\s*(:))|\)))|\s*(,)
            beginCaptures:
              1: {name: variable.arguments.graphql}
              2: {name: punctuation.colon.graphql}
            endCaptures:
              3: {name: punctuation.comma.graphql}
            patterns:
              - include: '#graphql-value'
              - include: '#graphql-comment'
              - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-boolean-value:
        match: \s*\b(true|false)\b
        captures:
          1: {name: constant.boolean.graphql}
      graphql-colon:
        match: \s*(:)
        captures:
          1: {name: punctuation.colon.graphql}
      graphql-comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.comma.graphql}
      graphql-comment:
        patterns:
          - begin: \s*+"""
            end: \s*"""
            name: comment.block.graphql.cgt
          - match: (\s*)((\#.*)|(".*"))
            name: comment.line.graphql.cgt
            captures:
              1: {name: punctuation.whitespace.comment.leading.graphql}
      graphql-directive:
        applyEndPatternLast: 1
        begin: \s*((@)\s*([_A-Za-z][_\\dA-Za-z]*))
        end: (?=.)
        beginCaptures:
          1: {name: entity.name.function.directive.graphql}
        patterns:
          - include: '#graphql-arguments'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-enum:
        begin: \s*+\b(enum)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        end: (?<=})
        name: meta.enum.graphql
        beginCaptures:
          1: {name: keyword.enum.graphql}
          2: {name: support.type.enum.graphql}
        patterns:
          - begin: \s*({)
            end: \s*(})
            name: meta.type.object.graphql
            beginCaptures:
              1: {name: punctuation.operation.graphql}
            endCaptures:
              1: {name: punctuation.operation.graphql}
            patterns:
              - include: '#graphql-object-type'
              - include: '#graphql-comment'
              - include: '#graphql-enum-value'
              - include: '#quasi-embedded'
      graphql-enum-value:
        match: \s*(?!=\b(true|false|null)\b)([_A-Za-z][_\\dA-Za-z]*)
        name: constant.character.enum.graphql
      graphql-field:
        patterns:
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)\s*(:)
            captures:
              1: {name: string.unquoted.alias.graphql}
              2: {name: punctuation.colon.graphql}
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)
            captures:
              1: {name: variable.graphql}
          - include: '#graphql-arguments'
          - include: '#graphql-directive'
          - include: '#graphql-selection-set'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-float-value:
        match: \s*((-)?(0|([1-9]\d*)(\.\d*)?((e|E)(\+|-)?\d*)?))
        captures:
          1: {name: constant.float.graphql}
      graphql-fragment-definition:
        begin: \s*(?:(\bfragment\b)\s*(?!\bon\b)([_A-Za-z][_\\dA-Za-z]*)\s*(?:(\bon\b)\s*([_A-Za-z][_\\dA-Za-z]*)))
        end: (?<=})
        name: meta.fragment.graphql
        captures:
          1: {name: keyword.fragment.graphql}
          2: {name: entity.name.fragment.graphql}
          3: {name: keyword.on.graphql}
          4: {name: support.type.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-fragment-spread:
        applyEndPatternLast: 1
        begin: \s*(\.\.\.)\s*(?!\bon\b)([_A-Za-z][_\\dA-Za-z]*)
        end: (?=.)
        captures:
          1: {name: keyword.operator.spread.graphql}
          2: {name: variable.fragment.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-ignore-spaces:
        match: \s*
      graphql-inline-fragment:
        applyEndPatternLast: 1
        begin: \s*(\.\.\.)\s*(?:(\bon\b)\s*([_A-Za-z][_\\dA-Za-z]*))?
        end: (?=.)
        captures:
          1: {name: keyword.operator.spread.graphql}
          2: {name: keyword.on.graphql}
          3: {name: support.type.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-selection-set'
          - include: '#graphql-directive'
          - include: '#graphql-skip-newlines'
          - include: '#quasi-embedded'
      graphql-input-types:
        patterns:
          - include: '#graphql-scalar-type'
          - match: \s*([_A-Za-z][_\\dA-Za-z]*)(?:\s*(!))?
            captures:
              1: {name: support.type.graphql}
              2: {name: keyword.operator.nulltype.graphql}
          - begin: \s*(\[)
            end: \s*(\])(?:\s*(!))?
            name: meta.type.list.graphql
            captures:
              1: {name: meta.brace.squart.graphql}
              2: {name: keyword.operator.nulltype.graphql}
            patterns:
              - include: '#graphql-input-types'
              - include: '#graphql-comment'
              - include: '#graphql-comma'
              - include: '#quasi-embedded'
      graphql-int-value:
        match: \s*((-)?(0|[1-9][\d]*))
        captures:
          1: {name: constant.int.graphql}
      graphql-list-value:
        patterns:
          - begin: \s*+(\[)
            end: \s*(\])
            name: meta.listvalues.graphql
            beginCaptures:
              1: {name: meta.brace.square.graphql}
            endCaptures:
              1: {name: meta.brace.square.graphql}
            patterns:
              - include: '#graphql-value'
      graphql-name:
        match: \s*([_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: entity.name.function.graphql}
      graphql-object-field:
        match: \s*(([_A-Za-z][_\\dA-Za-z]*))\s*(:)
        captures:
          1: {name: constant.object.key.graphql}
          2: {name: string.unquoted.graphql}
          3: {name: punctuation.graphql}
      graphql-object-value:
        patterns:
          - begin: \s*+({)
            end: \s*(})
            name: meta.objectvalues.graphql
            beginCaptures:
              1: {name: meta.brace.curly.graphql}
            endCaptures:
              1: {name: meta.brace.curly.graphql}
            patterns:
              - include: '#graphql-object-field'
              - include: '#graphql-value'
      graphql-operation-def:
        patterns:
          - include: '#graphql-query-mutation'
          - include: '#graphql-name'
          - include: '#graphql-variable-definitions'
          - include: '#graphql-directive'
          - include: '#graphql-selection-set'
      graphql-query-mutation:
        match: \s*\b(query|mutation)\b
        captures:
          1: {name: keyword.operation.graphql}
      graphql-scalar:
        match: \s*\b(scalar)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: keyword.scalar.graphql}
          2: {name: entity.scalar.graphql}
      graphql-scalar-type:
        match: \s*\b(Int|Float|String|Boolean|ID)\b(?:\s*(!))?
        captures:
          1: {name: support.type.builtin.graphql}
          2: {name: keyword.operator.nulltype.graphql}
      graphql-schema:
        begin: \s*\b(schema)\b
        end: (?<=})
        beginCaptures:
          1: {name: keyword.schema.graphql}
        patterns:
          - begin: \s*({)
            end: \s*(})
            beginCaptures:
              1: {name: punctuation.operation.graphql}
            endCaptures:
              1: {name: punctuation.operation.graphql}
            patterns:
              - begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
                end: (?=\s*(([_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(})))|\s*(,)
                beginCaptures:
                  1: {name: variable.arguments.graphql}
                endCaptures:
                  5: {name: punctuation.comma.graphql}
                patterns:
                  - match: \s*([_A-Za-z][_\\dA-Za-z]*)
                    captures:
                      1: {name: support.type.graphql}
                  - include: '#graphql-colon'
                  - include: '#graphql-comment'
                  - include: '#graphql-skip-newlines'
              - include: '#graphql-comment'
              - include: '#graphql-skip-newlines'
          - include: '#graphql-comment'
          - include: '#graphql-skip-newlines'
      graphql-selection-set:
        begin: \s*({)
        end: \s*(})
        name: meta.selectionset.graphql
        beginCaptures:
          1: {name: punctuation.operation.graphql}
        endCaptures:
          1: {name: punctuation.operation.graphql}
        patterns:
          - include: '#graphql-field'
          - include: '#graphql-fragment-spread'
          - include: '#graphql-inline-fragment'
          - include: '#graphql-comma'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-skip-newlines:
        match: |
          \s*
      graphql-string-content:
        patterns:
          - match: \\[/'"\\nrtbf]
            name: constant.character.escape.graphql
          - match: \\u(\h{4})
            name: constant.character.escape.graphql
      graphql-string-value:
        begin: \s*+(("))
        contentName: string.quoted.double.graphql
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.double.graphql}
          2: {name: punctuation.definition.string.begin.graphql}
        endCaptures:
          1: {name: string.quoted.double.graphql}
          2: {name: punctuation.definition.string.end.graphql}
          3: {name: invalid.illegal.newline.graphql}
        patterns:
          - include: '#graphql-string-content'
          - include: '#quasi-embedded'
      graphql-type-definition:
        begin: \s*([_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
        comment: 'key (optionalArgs): Type'
        end: (?=\s*(([_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(})))|\s*(,)
        beginCaptures:
          1: {name: variable.graphql}
        endCaptures:
          5: {name: punctuation.comma.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-variable-definitions'
          - include: '#graphql-type-object'
          - include: '#graphql-colon'
          - include: '#graphql-input-types'
          - include: '#quasi-embedded'
      graphql-type-interface:
        applyEndPatternLast: 1
        begin: \s*\b(?:(extends?)?\b\s*\b(type)|(interface)|(input))\b\s*([_A-Za-z][_\\dA-Za-z]*)?
        end: (?=.)
        name: meta.type.interface.graphql
        beginCaptures:
          1: {name: keyword.type.graphql}
          2: {name: keyword.type.graphql}
          3: {name: keyword.interface.graphql}
          4: {name: keyword.input.graphql}
          5: {name: support.type.graphql}
        patterns:
          - match: \s*\b(implements)\b\s*([_A-Za-z][_\\dA-Za-z]*)
            captures:
              1: {name: keyword.implements.graphql}
              2: {name: support.type.graphql}
          - include: '#graphql-comment'
          - include: '#graphql-type-object'
          - include: '#quasi-embedded'
          - include: '#graphql-ignore-spaces'
      graphql-type-object:
        begin: \s*({)
        end: \s*(})
        name: meta.type.object.graphql
        beginCaptures:
          1: {name: punctuation.operation.graphql}
        endCaptures:
          1: {name: punctuation.operation.graphql}
        patterns:
          - include: '#graphql-object-type'
          - include: '#graphql-comment'
          - include: '#graphql-type-definition'
          - include: '#quasi-embedded'
      graphql-union:
        applyEndPatternLast: 1
        begin: \s*\b(union)\b\s*([_A-Za-z][_\\dA-Za-z]*)
        end: (?=.)
        captures:
          1: {name: keyword.union.graphql}
          2: {name: support.type.graphql}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*(=(?!=|>))\s*([_A-Za-z][_\\dA-Za-z]*)
            end: (?=.)
            captures:
              1: {name: punctuation.assignment.graphql}
              2: {name: support.type.graphql}
            patterns:
              - include: '#graphql-skip-newlines'
              - include: '#graphql-comment'
              - include: '#quasi-embedded'
              - match: \s*(\|)\s*([_A-Za-z][_\\dA-Za-z]*)
                captures:
                  1: {name: punctuation.or.graphql}
                  2: {name: support.type.graphql}
          - include: '#graphql-skip-newlines'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-union-mark:
        match: \s*(\|)
        captures:
          1: {name: punctuation.union.graphql}
      graphql-value:
        patterns:
          - include: '#graphql-variable-name'
          - include: '#graphql-float-value'
          - include: '#graphql-int-value'
          - include: '#graphql-string-value'
          - include: '#graphql-boolean-value'
          - include: '#graphql-enum-value'
          - include: '#graphql-list-value'
          - include: '#graphql-object-value'
          - include: '#graphql-comment'
          - include: '#quasi-embedded'
      graphql-variable-assignment:
        applyEndPatternLast: 1
        begin: \s(=)
        end: (?=.)
        beginCaptures:
          1: {name: punctuation.assignment.graphql}
        patterns:
          - include: '#graphql-value'
      graphql-variable-definition:
        begin: \s*(\$?[_A-Za-z][_\\dA-Za-z]*)(?=\s*\(|:)
        comment: 'variable: type = value,.... which may be a list'
        end: (?=\s*((\$?[_A-Za-z][_\\dA-Za-z]*)\s*(\(|:)|(}|\))))|\s*(,)
        name: meta.variables.graphql
        beginCaptures:
          1: {name: variable.graphql}
        endCaptures:
          5: {name: punctuation.comma.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-colon'
          - include: '#graphql-input-types'
          - include: '#graphql-variable-assignment'
          - include: '#quasi-embedded'
          - include: '#graphql-skip-newlines'
      graphql-variable-definitions:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: meta.brace.round.graphql}
        patterns:
          - include: '#graphql-comment'
          - include: '#graphql-variable-definition'
          - include: '#quasi-embedded'
      graphql-variable-name:
        match: \s*(\$[_A-Za-z][_\\dA-Za-z]*)
        captures:
          1: {name: variable.graphql}
  heregexp:
    patterns:
      - include: '#regexp-patterns'
      - include: '#comments'
  html-template:
    begin: (?:(?:^|(?<=,|{))\s*\b((template))\b\s*(:)\s*(`))
    comment: 'Assume object properties of template: `some html` contain html'
    end: \s*(`)
    beginCaptures:
      1: {name: constant.other.object.key.cgt}
      2: {name: string.unquoted.cgt}
      3: {name: punctuation.separator.key-value.cgt}
      4: {name: punctuation.definition.quasi.begin.cgt}
    endCaptures:
      1: {name: punctuation.definition.quasi.end.cgt}
    patterns:
      - begin: (?<!\\)\${
        end: \s*}
        name: entity.quasi.element.cgt
        beginCaptures:
          0: {name: punctuation.quasi.element.begin.cgt}
        endCaptures:
          0: {name: punctuation.quasi.element.end.cgt}
        patterns:
          - include: '#core'
      - include: text.html.mustache
  if:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(if|els?if|ell?ess?|unless?|guard)\b\s*(await)?\b
        end: \s*(?<=[})])
        name: meta.if.cgt
        beginCaptures:
          1: {name: keyword.control.conditional.cgt}
          2: {name: keyword.control.flow.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#curly-brackets'
          - include: '#type-argument-brackets'
          - include: $self
  ignore-long-lines:
    comment: so set at arbitary 1000 chars to avoid parsing minified files
    patterns:
      - match: ^.{1000,}
  implicit-call:
    patterns:
      - comment: Avoid all language keywords as much as possible
        match: (?x)(?<=\.)\s* ([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*) \s*(?=['"`(]|::|<[+|])
        captures:
          1: {patterns: [{include: '#method-name'}]}
      - comment: Avoid all language keywords as much as possible
        match: (?x)\s* ([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*) \s*(?=['"`(]|::|<[+|])
        captures:
          1: {patterns: [{include: '#function-name'}]}
  js-label:
    comment: 'jslabel: $|for|while|do'
    match: >-
      (?:^|(?<=;))\s*([_\\p{L}\p{Nl}][-_\\p{L}\p{M}\p{N}]*+)(:)\s*(?=(/\*.*?\*/\s*$|//|$|;|\b(for|while|do|if|switch|match|repeat)\b))
    captures:
      1: {name: constant.other.label.cgt}
      2: {name: punctuation.separator.label.cgt}
  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-namepath'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-namepath'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-noname'
      - comment: additional jsdoc V2 keywords
        match: >-
          (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: >-
          (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss
          mixin|singleton|template|uses|xtype)\b
        name: storage.type.class.jsdoc
    repository:
      jsdoc-access:
        comment: '@tag protected....'
        match: (?:^[\s*]*|(?<=/\*\*)\s*)(@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-as-namepath:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        comment: to terminate the block
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-namepath-scopes'
      jsdoc-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.jsdoc
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.jsdoc}
              3: {name: string.jsdoc}
      jsdoc-module:
        begin: >-
          (?:^[\s*]*|(?<=/\*\*)\s*)(@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        comment: '@tag {optional type} module:file'
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - match: (?:(module)(:))?(((?!\*/)\S)+)
            captures:
              1: {name: keyword.module.jsdoc}
              2: {name: punctuation.jsdoc}
              3: {name: string.modulename.jsdoc}
      jsdoc-name-scopes:
        patterns:
          - match: ((?!\*/)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.jsdoc}
          - begin: \[
            end: \]|^
            name: variable.other.jsdoc
            patterns:
              - include: '#jsdoc-string'
              - include: '#jsdoc-name-scopes'
      jsdoc-namepath-scopes:
        patterns:
          - match: \s*\b(as)\b\s*(?=[$_A-Za-z])
            captures:
              1: {name: keyword.as.jsdoc}
          - match: \s*(?:([A-Z][$_A-Za-z\d]*)|([$_A-Za-z][$_A-Za-z\d]*))(?=[\s\-~.#]|$)
            captures:
              1: {name: entity.name.class.jsdoc}
              2: {name: entity.name.function.jsdoc}
          - match: (\.)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.static.jsdoc}
          - match: (\#)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.instance.jsdoc}
          - match: (~|-)([$_A-Za-z][$_A-Za-z\d]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.inner.jsdoc}
          - match: (\#)(event)(:)
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: keyword.event.jsdoc}
              3: {name: keyword.operator.jsdoc}
          - applyEndPatternLast: 1
            begin: \.(?="|')
            end: (?=.)
            name: string.method.jsdoc
            patterns:
              - include: '#jsdoc-string'
      jsdoc-simple:
        comment: '@tag'
        match: >-
          (?:^[\s*]*|(?<=/\*\*)\s*)(@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-namepath:
        begin: >-
          (?:^[\s*]*|(?<=/\*\*)\s*)(@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - include: '#jsdoc-namepath-scopes'
      jsdoc-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.jsdoc
      jsdoc-type-name:
        begin: >-
          (?:^[\s*]*|(?<=/\*\*)\s*)(@(arg|argument|class|constant|constructor|constructs|const|con|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        comment: '@tag {optional type} name'
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
          - include: '#jsdoc-name-scopes'
      jsdoc-type-noname:
        begin: >-
          (?:^[\s*]*|(?<=/\*\*)\s*)(@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        comment: '@tag {types}'
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-scopes'
      jsdoc-typedef-obj:
        begin: '{'
        comment: typedef object
        end: '}|^'
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-primitives'
          - match: \b([$_A-Za-z][$_A-Za-z\d]*)\s*(:)
            captures:
              1: {name: variable.other.readwrite.jsdoc}
          - include: '#jsdoc-namepath-scopes'
          - include: '#jsdoc-typedef-obj'
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-scopes:
        begin: '{'
        end: '}|^'
        name: entity.name.type.instance.jsdoc
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: '#jsdoc-typedef-primitives'
          - include: '#jsdoc-namepath-scopes'
          - include: '#jsdoc-typedef-obj'
  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    patterns:
      - applyEndPatternLast: 1
        begin: >-
          (?<=^|\(|{|\[|,|&&|\|\||\?|:|=|=>|\Wreturn|^return|\Wyield|^yield|\Wdefault|\Wvoid|^void)\s*+(?=<[_\\\p{L}\p{Nl}]|<\s*>)
        end: (?=.)
        patterns:
          - include: '#jsx-tag-element-name'
    repository:
      jsx-assignment:
        patterns:
          - comment: look for attribute assignment
            match: '=(?=\s*(?:''|"|{|/\*|<|//|\n))'
            name: keyword.operator.assignment.jsx
      jsx-attribute-name:
        patterns:
          - comment: look for attribute name
            match: (?<!\S)([_\\\p{L}\p{Nl}](?:[._\\p{L}\p{M}\d\p{Nl}-](?<!\.\.))*+)(?<!(?<!\.\.)\.|\#)(?=//|/\*|=|\s|>|/>)
            captures:
              0: {name: entity.other.attribute-name.jsx}
      jsx-entities:
        patterns:
          - comment: Embeded HTML entities &blah
            match: (&)([a-zA-Z\d]+|#[\d]+|#x\h+)(;)
            captures:
              0: {name: constant.character.entity.jsx}
              1: {name: punctuation.definition.entity.jsx}
              2: {name: entity.name.tag.html.jsx}
              3: {name: punctuation.definition.entity.jsx}
          - comment: Entity with & and invalid name
            match: '&\s*+;'
            name: invalid.illegal.bad-ampersand.jsx
      jsx-evaluated-code:
        patterns:
          - begin: '{'
            contentName: source.cgt
            end: '}'
            name: meta.embedded.expression.cgt
            beginCaptures:
              0: {name: punctuation.section.embedded.begin.jsx}
            endCaptures:
              0: {name: punctuation.section.embedded.end.jsx}
            patterns:
              - include: '#jsx-string-double-quoted'
              - include: '#jsx-string-single-quoted'
              - include: '#jsx-spread-attribute'
              - include: '#core'
      jsx-spread-attribute:
        patterns:
          - comment: Spread attribute { ... AssignmentExpression }
            match: (?<!(?<!\.\.)\.|\#)\.\.\.
            name: keyword.operator.spread.jsx
      jsx-string-double-quoted:
        begin: '"'
        end: '"(?<!\\")'
        name: string.quoted.double.cgt
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
          - include: '#jsx-entities'
      jsx-string-single-quoted:
        begin: ''''
        end: '''(?<!\\'')'
        name: string.quoted.single.cgt
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
          - include: '#jsx-entities'
      jsx-tag-attributes:
        patterns:
          - include: '#jsx-attribute-name'
          - include: '#jsx-assignment'
          - include: '#jsx-string-double-quoted'
          - include: '#jsx-string-single-quoted'
          - include: '#jsx-evaluated-code'
          - include: '#jsx-tag-element-name'
          - include: '#comments'
      jsx-tag-element-name:
        patterns:
          - begin: \s*+(<)\s*(?=>)
            comment: JSX Fragment
            contentName: JSXAttrs
            end: (?<=</)(>)
            name: meta.tag.jsx
            beginCaptures:
              1: {name: punctuation.definition.tag.jsx}
            endCaptures:
              1: {name: punctuation.definition.tag.jsx}
            patterns:
              - include: '#jsx-tag-termination'
          - begin: >-
              \s*+(<)((\p{Ll}[\p{Ll}\d]*)|((?:[_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}-]*?:)?+(?:[_\\\p{L}\p{Nl}](?:[-_\\\p{L}\p{M}\p{N}\.-](?<!\.\.))*+)+))(?=[/>\s])(?![:])(?<!\.|:)
            comment: 'Tags that end > are trapped in #jsx-tag-termination'
            contentName: JSXAttrs
            end: \s*(?<=</)((\4)|\2)(>)|(/>)|((?<=</)[\S ]*?)>
            name: meta.tag.jsx
            beginCaptures:
              1: {name: punctuation.definition.tag.jsx}
              2: {name: entity.name.tag.open.jsx}
              4: {name: support.class.component.open.jsx}
            endCaptures:
              1: {name: entity.name.tag.close.jsx}
              2: {name: support.class.component.close.jsx}
              3: {name: punctuation.definition.tag.jsx}
              4: {name: punctuation.definition.tag.jsx}
              5: {name: invalid.illegal.termination.jsx}
            patterns:
              - include: '#jsx-tag-termination'
              - include: '#jsx-tag-attributes'
      jsx-tag-termination:
        patterns:
          - begin: (>)
            comment: uses non consuming search for </ in </tag>
            contentName: JSXNested
            end: (</)
            beginCaptures:
              0: {name: punctuation.definition.tag.jsx}
              1: {name: JSXStartTagEnd}
            endCaptures:
              0: {name: punctuation.definition.tag.jsx}
              1: {name: JSXEndTagStart}
            patterns:
              - include: '#jsx-evaluated-code'
              - include: '#jsx-entities'
              - include: '#jsx-tag-element-name'
  keyword-storage:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(const|con|let|var|val)\b
        end: >-
          (?=\s*[_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*:\s*($|\b(do|for|while)\b))|\s*(?=;|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|})
        beginCaptures:
          1: {name: storage.type.cgt}
        patterns:
          - include: '#flowtype-variable'
  keywords:
    patterns:
      - include: '#new'
      - include: '#query'
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(halt|skip|break|continue|goto|label)\b
        end: >-
          ^\s*|\s*(?=,|;|:|//|$|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b)
        beginCaptures:
          1: {name: keyword.control.loop.cgt}
        patterns:
          - include: '#comments'
          - include: '#keywords'
          - include: '#modifiers'
          - match: \s*([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*
            captures:
              1: {name: constant.other.label.cgt}
      - comment: Keyword operators
        match: |
          (?x)(?<!(?<!\.\.)\.|\#)\s*+\b(?:
            (in|of|as|void|new|(?:type|name|key|size)of|infer)| #1
            (size)|(len)|(del)|(is)|(to|til|by)|(then)| #2-7
            (n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|
            not(of|in)?|(is)no?t)#8-11
          )\b
        captures:
          1: {name: keyword.operator.$1.cgt}
          2: {name: keyword.operator.sizeof.cgt}
          3: {name: keyword.operator.length.cgt}
          4: {name: keyword.operator.delete.cgt}
          5: {name: keyword.operator.instanceof.cgt}
          6: {name: keyword.control.range.cgt}
          7: {name: keyword.control.then.cgt}
          8: {name: keyword.other.logical.cgt}
          9: {name: keyword.operator.$9.cgt}
          10: {name: keyword.operator.instanceof.cgt}
      - comment: Control flow keywords
        match: |
          (?x)(?<!(?<!\.\.)\.|\#)\s*+\b(?:
            (if|else|els?if|ell?ess?|unless?|guard)|(for|while|until|repeat)| #1,2
            (switch|case|def)|(match|when|pass)| #3,4
            (try|throw|raise|catch|rescue|finally)|(with|as)| #5,6
            (defn?|func?|fn|macro|proc)|(let|va[rl]|con|const)| #7,8
            (use|using|ref|open|close|out|union|move|crate|box|begin|end)| #9
            (do|goto|label|await|return|fallthru|yield|halt|skip)| #10
            (from|where|join|equals|[io]nto|order|(?:a|de)sc|group)| #11
            ((?:im|ex)port|from|as|def) #12
          )\b
        captures:
          1: {name: keyword.control.conditional.cgt}
          2: {name: keyword.control.loop.cgt}
          3: {name: keyword.control.switch.cgt}
          4: {name: keyword.control.match.cgt}
          5: {name: keyword.control.trycatch.cgt}
          6: {name: keyword.control.with.cgt}
          7: {name: storage.type.function.cgt}
          8: {name: storage.type.cgt}
          9: {name: keyword.control.cgt}
          10: {name: keyword.control.flow.cgt}
          11: {name: keyword.query.cgt}
          12: {name: keyword.control.module.cgt}
  labels:
    patterns:
      - comment: string as a property name
        match: (?<!\.|\?)\s*+(((")(\\.|[^\\"])*("))|((')(\\.|[^\\'])*(')))\s*+(:)((?=::)|(?!:))
        name: meta.object.member.cgt meta.object-literal.key.cgt
        captures:
          1: {name: constant.other.object.key.cgt}
          2: {name: string.quoted.double.cgt, patterns: [{include: '#string-content'}]}
          3: {name: punctuation.definition.string.begin.cgt}
          5: {name: punctuation.definition.string.end.cgt}
          6: {name: string.quoted.single.cgt, patterns: [{include: '#string-content'}]}
          7: {name: punctuation.definition.string.begin.cgt}
          9: {name: punctuation.definition.string.end.cgt}
          10: {name: punctuation.separator.key-value.cgt}
      - begin: (?<!\.|\?)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+:\s*+[\S&&[^:]])
        comment: '[some expression] : as  property name'
        end: \s*(:)((?=::)|(?!:))
        name: meta.object.member.cgt meta.object-literal.key.cgt
        endCaptures:
          1: {name: punctuation.separator.key-value.cgt}
        patterns:
          - include: '#core'
      - include: '#js-label'
      - match: (?<!\.|\?)\s*+(([-_\\\p{L}\p{M}\p{N}]*))\s*+(:)((?=::)|(?!:))
        name: meta.object.member.cgt meta.object-literal.key.cgt
        captures:
          1: {name: constant.other.object.key.cgt, patterns: [{include: '#number'}]}
          2: {name: string.unquoted.cgt}
          3: {name: punctuation.separator.key-value.cgt}
  language-constant:
    patterns:
      - match: >-
          (?i)(?<!(?<!\.\.)\.|\#)\s*+\b((true|yes|on)|(false|no|off)|(null|nil|none)|(undefined|undef)|(nan)|(inf|infin|infinity))\b
        captures:
          2: {name: constant.language.boolean.true.cgt}
          3: {name: constant.language.boolean.false.cgt}
          4: {name: constant.language.null.cgt}
          5: {name: constant.language.undefined.cgt}
          6: {name: constant.language.nan.cgt}
          7: {name: constant.language.infinity.cgt}
  language-variable:
    patterns:
      - match: (?<!(?<!\.\.)\.)\s*+\b(params|args)\b
        captures:
          1: {name: variable.language.arguments.cgt}
      - match: (?<!(?<!\.\.)\.)\s*+\b(super)\b\s*+(?!\()
        captures:
          1: {name: variable.language.super.cgt}
      - match: (?<!(?<!\.\.)\.)\s*+\b(this)\b
        captures:
          1: {name: variable.language.this.cgt}
      - match: (?<!(?<!\.\.)\.)\s*+\b(self)\b\s*+(?!\()
        captures:
          1: {name: variable.language.self.cgt}
      - match: (?<=\.)\s*+\b(\\proto)\b
        captures:
          1: {name: variable.language.proto.cgt}
      - match: (?<=\.)\s*+\b(ctor)\b\s*+(?!\()
        captures:
          1: {name: variable.language.constructor.cgt}
      - match: (?<=\.)\s*+\b(proto)\b
        captures:
          1: {name: variable.language.prototype.cgt}
      - match: |
          (?x)(?<!(?<!\.\.)\.|\#)\s*+\b(?:
            (params|args)|(super|this|self|proto)|(\\proto|main)|(ctor)|(targ)|(len|size)
          )\b
        captures:
          1: {name: variable.language.arguments.cgt}
          2: {name: variable.language.$2.cgt}
          3: {name: variable.language.prototype.cgt}
          4: {name: variable.language.constructor.cgt}
          5: {name: variable.language.target.cgt}
          6: {name: variable.language.length.cgt}
  match:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(match)\b
        end: \s*(\})
        name: meta.match.cgt
        beginCaptures:
          1: {name: keyword.control.match.cgt}
        endCaptures:
          1: {name: meta.brace.curly.matchEnd.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - begin: \s*+({)
            end: \s*(?=})
            beginCaptures:
              1: {name: meta.brace.curly.matchStart.cgt}
            patterns:
              - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(if|unless?|els?if|ell?ess?|else\s+if|else\s+unless?)\b
                end: \s*(=>)|\s*(:)((?=::)|(?!:))
                beginCaptures:
                  1: {name: keyword.control.match.cgt}
                endCaptures:
                  1: {name: storage.type.function.arrow.cgt}
                  2: {name: keyword.operator.cgt}
                patterns:
                  - include: '#core'
              - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(else|def)\b
                contentName: meta.match.cgt
                end: \s*(=>)|\s*(:)((?=::)|(?!:))
                beginCaptures:
                  1: {name: keyword.control.match.cgt}
                endCaptures:
                  1: {name: storage.type.function.arrow.cgt}
                  2: {name: keyword.operator.cgt}
              - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(when|case)\b
                end: \s*(=>)|\s*(:)((?=::)|(?!:))
                beginCaptures:
                  1: {name: keyword.control.match.cgt}
                endCaptures:
                  1: {name: storage.type.function.arrow.cgt}
                  2: {name: keyword.operator.cgt}
                patterns:
                  - include: '#with-clause'
                  - include: '#if-clause'
                  - include: '#flowtype-parse-types'
              - include: $self
          - include: $self
    repository:
      if-clause:
        begin: \s*+\b(if|unless|where)
        comment: with clause precedes with
        end: \s*((?=:(?!:))|=>)
        beginCaptures:
          1: {name: keyword.control.match.cgt}
        endCaptures:
          1: {name: keyword.operator.cgt}
        patterns:
          - include: '#core'
      with-clause:
        begin: \s*+\b(as|with)
        comment: when clause precedes with
        end: \s*(:)((?=::)|(?!:))|\s*(?=(:|;|=>)|\b(where|if|unless)\b)
        beginCaptures:
          1: {name: keyword.control.match.cgt}
        endCaptures:
          1: {name: keyword.operator.cgt}
          2: {patterns: [{include: '#core'}]}
          3: {patterns: [{include: '#core'}]}
          4: {name: keyword.control.match.cgt}
        patterns:
          - include: '#if-clause'
          - include: '#core'
  method:
    patterns:
      - begin: >-
          (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<!(?<!\.\.)\.|\#)(\#?)(?!\bstatic\b)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\())
        comment: 'e.g. play<T,T>(arg1, arg2): Type<T> { }'
        end: \s*(=(?!=|>))|(?={)|(?=;|}|,)
        beginCaptures:
          1: {name: storage.modifier.cgt}
          2: {name: storage.type.cgt}
          3: {name: keyword.generator.asterisk.cgt}
          4: {name: keyword.operator.private.cgt}
          5: {name: entity.name.function.method.cgt, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#curly-brackets'
          - include: '#class-content'
          - include: $self
      - begin: >-
          (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<!(?<!\.\.)\.|\#)(('|")([^"']*)(\k<-3>))(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
        comment: 'e.g. ''play''<T,T>(arg1, arg2): Type<T> { }'
        end: \s*(=(?!=|>))|(?={)|(?=;|}|,)
        beginCaptures:
          1: {name: storage.modifier.cgt}
          2: {name: storage.type.cgt}
          3: {name: keyword.generator.asterisk.cgt}
          4: {name: entity.name.function.method.cgt, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#curly-brackets'
          - include: '#class-content'
          - include: $self
      - begin: >-
          (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\]))\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\())
        comment: 'e.g. [expression]<T,T>(arg1, arg2): Type<T> { } or ''text''<T,T>(arg1, arg2)'
        end: \s*(=(?!=|>))|(?={)|(?=;|}|,)
        beginCaptures:
          1: {name: storage.modifier.cgt}
          2: {name: storage.type.cgt}
          3: {name: keyword.generator.asterisk.cgt}
          4: {name: entity.name.function.method.cgt, patterns: [{include: '#string-content'}]}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#square-brackets'
          - include: '#curly-brackets'
          - include: '#class-content'
          - include: $self
      - begin: >-
          (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s++(\#?)(?!\bstatic\b)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(?=\s*+\()
        comment: getter/setter
        end: \s*(=(?!=|>))|(?={)|(?=;|}|,)
        beginCaptures:
          1: {name: storage.modifier.cgt}
          2: {name: storage.type.accessor.cgt}
          3: {name: keyword.operator.private.cgt}
          4: {name: entity.name.function.accessor.cgt}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#curly-brackets'
          - include: '#class-content'
          - include: $self
      - begin: >-
          (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(((')((?:[^']|\\')*)('))|\s*+((")((?:[^"]|\\")*)("))))\s*+(\())
        comment: getter/setter set [expression]() or get 'text'()
        end: \s*(=(?!=|>))|(?={)|(?=;|}|,)
        beginCaptures:
          1: {name: storage.modifier.cgt}
          2: {name: storage.type.accessor.cgt}
          3: {name: entity.name.function.accessor.cgt}
        endCaptures:
          1: {name: keyword.operator.assignment.cgt}
        patterns:
          - include: '#flowtype-parse-array'
          - include: '#string'
          - include: '#flowtype'
          - include: '#square-brackets'
          - include: '#class-content'
          - include: $self
  method-call:
    patterns:
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g CONSTNAME.method() or CONST.method[p]()
        end: (?=.)
        name: meta.method-call.without-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.constant.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: keyword.operator.assertion.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {name: keyword.operator.private.cgt}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g Abc.aaa()
        end: (?=.)
        name: meta.method-call.without-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.assertion.cgt}
          5: {name: keyword.operator.cascade.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {name: keyword.operator.private.cgt}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g CONSTNAME.method()
        end: (?=.)
        name: meta.method-call.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.constant.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.assertion.cgt}
          5: {name: keyword.operator.cascade.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {name: keyword.operator.private.cgt}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g Abc.aaa()
        end: (?=.)
        name: meta.method-call.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.assertion.cgt}
          5: {name: keyword.operator.cascade.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {name: keyword.operator.private.cgt}
          8: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#round-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
        comment: e.g .aaa()
        end: (?=.)
        name: meta.method-call.without-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#method-name'}]}
          3: {name: meta.group.braces.round.function.arguments.cgt}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
        comment: e.g .aaa()
        end: (?=.)
        name: meta.method-call.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.operator.private.cgt}
          2: {patterns: [{include: '#method-name'}]}
        patterns:
          - include: '#square-brackets'
          - include: '#type-argument-brackets'
          - include: '#round-brackets'
  method-name:
    patterns:
      - include: '#support-methods'
      - match: (([a-zA-Z])[-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.method.$2.cgt
      - match: ([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: entity.name.function.method.cgt
  modifiers:
    patterns:
      - comment: Modifier keywords
        match: |
          (?x)(?<!(?<!\.\.)\.|\#)\s*+\b(?:
            (pub|prot|pvt|ro|(?:in|ex)tl)| #1
            (over|abs|stat|dyn|vol|a?sync|(?:im)?mut|part|seal|final|dele|[dr]ef
            trans|(?:im|ex)pl|dele|ext|(?:un)?(?:sign|safe|check|size|set))| #2
            (rec|gen|inline|(?:pre|in|suf|)fix|(?:u|bi|ter|)nary|[gs]et|
            prev|next|lock|fixed) #3
          )\b
        captures:
          1: {name: storage.modifier.cgt}
          2: {name: keyword.modifier.cgt}
          3: {name: storage.type.accessor.cgt}
      - comment: Type alias keywords
        match: |
          (?x)(?<!(?<!\.\.)\.|\#)\s*+\b(?:
            (trait|enum|given)|(obj|rec)|(nspace)|(inter|schema|struct)| #1-4
            (pkg)|(extn)|(class)|(frag)|(ext)|(impl)|(decl) #6-10
          )\b
        captures:
          1: {name: keyword.other.$1.cgt}
          2: {name: keyword.other.object.cgt}
          3: {name: keyword.other.namespace.cgt}
          4: {name: keyword.other.interface.cgt}
          5: {name: keyword.other.module.cgt}
          6: {name: keyword.other.extension.cgt}
          7: {name: storage.type.class.cgt}
          8: {name: keyword.other.struct.cgt}
          9: {name: keyword.other.extends.cgt}
          10: {name: keyword.other.implements.cgt}
          11: {name: keyword.other.declare.cgt}
  module:
    begin: (?<!(?<!\.\.)\.|\#)\s*+\b(from|import|export|open|close|as|def)\b\s*
    comment: from ... import
    end: (?=;|\p{Pe}|$)
    beginCaptures:
      1: {name: keyword.control.module.cgt}
    patterns: 
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(from|import|export|open|close|as|def)\b\s*
        name: keyword.control.module.cgt
      - match: \s*\*
        name: keyword.operator.module.all.cgt
      - begin: \s*+(('))
        contentName: string.quoted.module.cgt
        end: |-
          \s*+(?:(('))|(
          ))
        beginCaptures:
          1: {name: string.quoted.module.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: string.quoted.module.cgt}
          2: {name: punctuation.definition.string.end.cgt}
          3: {name: invalid.illegal.newline.cgt}
        patterns:
          - include: '#string-content'
      - begin: \s*+(("))
        contentName: string.quoted.module.cgt
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.module.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: string.quoted.module.cgt}
          2: {name: punctuation.definition.string.end.cgt}
          3: {name: invalid.illegal.newline.cgt}
        patterns:
          - include: '#string-content'
      - include: '#keyword-storage'
      - include: '#flowtype-keywords'
      - include: '#flowtype-parse-types'
      - include: '#operator'
      - include: '#operators'
      - include: '#punctuation'
  module-as:
    match: \s*+(?:(\*)|(\bdef\b))?\s*+(\bas\b)\s*+(?:(\*)|(\bdef\b))?
    captures:
      1: {name: keyword.operator.module.all.cgt}
      2: {name: keyword.control.module.cgt}
      3: {name: keyword.control.module.reference.cgt}
      4: {name: keyword.operator.module.all.cgt}
      5: {name: keyword.control.module.cgt}
  module-brackets:
    patterns:
      - begin: \s*+(?:({)|(\[))
        end: \s*(?:(\})|(\]))
        beginCaptures:
          1: {name: meta.brace.curly.cgt}
          2: {name: meta.brace.square.cgt}
        endCaptures:
          1: {name: meta.brace.curly.cgt}
          2: {name: meta.brace.square.cgt}
        patterns:
          - match: \*
            name: keyword.operator.module.all.cgt
          - include: '#module-typeof'
          - include: '#module-as'
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#string'
          - include: '#comments'
          - include: '#comma'
  module-export:
    patterns:
      - comment: e.g. export let variable =, export type a=
        match: >-
          (?<!(?<!\.\.)\.|\#)\s*+\b(export)(?!\s*:)\b(?=\s++(const|con|let|opaque|va[rl]|type|typeof)\s++(?:[_\\p{L}\p{Nl}]))
        captures:
          1: {name: keyword.control.module.cgt}
      - begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+\b(export)\b\s*(\btype\b)?(?=\s++({|\*|((?:[_\\p{L}\p{Nl}])(?:[-_\\p{L}\p{M}\p{N}])*+)(\s++from\b|\s*,)))
        comment: export {  or  export * or export var or export type {} from module
        end: >-
          \s*(?:(?:(\bfrom\b)?+\s++(('|")([^"']*)(\k<-3>)))|(?=;|^\s*\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|}))
        beginCaptures:
          1: {name: keyword.control.module.cgt}
          2: {name: keyword.control.module.cgt}
        endCaptures:
          1: {name: keyword.control.module.cgt}
          2: {name: string.quoted.module.cgt}
          3: {name: punctuation.definition.string.begin.cgt}
          5: {name: punctuation.definition.string.end.cgt}
        patterns:
          - include: '#module-as'
          - match: \s*\*
            name: keyword.operator.module.all.cgt
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#comments'
          - include: '#comma'
      - comment: trap expressions among - export function* () {}
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(export|default)(?!\s*:)\b
        captures:
          1: {name: keyword.control.module.cgt}
  module-import:
    patterns:
      - applyEndPatternLast: 1
        begin: (?<!(?<!\.\.)\.|\#)\s*+(import)(?=\()
        end: (?=.)
        name: meta.function-call.with-arguments.cgt
        beginCaptures:
          1: {name: keyword.control.module.cgt}
        patterns:
          - include: '#round-brackets'
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(import)(?!\s*:)\b
        end: >-
          \s*(?:(?:(\bfrom\b)?+\s++(('|")([^"']*)(\k<-3>)))|(?=;|^\s*\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|n?and|x?n?or|[gl][te]|(?:as|sh)[lr]|div|rem|mod|pow|not(?:of|in)?|is(?:no?t)?|if|else|els?if|ell?ess?|unless?|guard|for|while|until|repeat|switch|case|def|match|when|pass|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|(?:a|de)sc|group|(?:im|ex)port|use|using|ref|open|close|out|union|move|crate|box|begin|end)\b|\)|}))
        beginCaptures:
          1: {name: keyword.control.module.cgt}
        endCaptures:
          1: {name: keyword.control.module.cgt}
          2: {name: string.quoted.module.cgt}
          3: {name: punctuation.definition.string.begin.cgt}
          5: {name: punctuation.definition.string.end.cgt}
        patterns:
          - match: \s*\b(default)\b
            captures:
              1: {name: keyword.control.module.cgt}
          - include: '#module-typeof'
          - include: '#module-as'
          - match: \s*\*
            name: keyword.operator.module.all.cgt
          - include: '#module-brackets'
          - include: '#variable'
          - include: '#comments'
          - include: '#comma'
  module-typeof:
    match: \s*\b(typeof|type)\b\s++(?={|\*|(?:[_\\p{L}\p{Nl}]))(?!\b(i[sn]|as)\b|,)
    captures:
      1: {name: keyword.other.typedef.flowtype}
  multiline-arrow-function-generics:
    patterns:
      - begin: \s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?+\s*+\(\s*$)
        comment: e.g. export default async <T>(
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.cgt
        beginCaptures:
          1: {name: storage.type.cgt}
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
      - begin: \s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*+>)\()
        comment: e.g. export default <T>(
        end: ((?<=})|(?:\s*(=>)(?!\s*{)))
        name: meta.function.arrow.cgt
        endCaptures:
          2: {name: storage.type.function.arrow.cgt}
        patterns:
          - include: '#flowtype'
          - include: '#fat-arrow-braced-body'
  multiline-regexp:
    comment: Updated to support Perl regex syntax
    patterns:
      - begin: ([[:alpha:]]*)(/>)\s*\n?
        end: \s*(\n?</)([[:alnum:]]*)
        name: string.regexp.multiline.cgt
        beginCaptures:
          1: {name: keyword.modifier.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: punctuation.definition.string.end.cgt}
          2: {name: keyword.other.flag.cgt}
        patterns:
          - include: '#heregexp'
      - begin: (?!\\)(?<=</)(>)\s*\n?
        contentName: string.quoted.cgt
        end: \s*\n?(</)([[:alnum:]]*)
        name: string.regexp.cgt
        beginCaptures:
          1: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: punctuation.definition.string.end.cgt}
          2: {name: keyword.other.flag.cgt}
        patterns:
          - match: \\[1-9]\d*
            name: keyword.other.back-reference.regexp
          - begin: (\\<)
            end: \s*(>)
            name: keyword.other.back-reference.regexp
            beginCaptures:
              1: {name: keyword.other.back-reference.regexp}
            endCaptures:
              1: {name: keyword.other.back-reference.regexp}
            patterns:
              - include: '#regex-group-name'
          - include: '#string-content'
  new:
    - comment: A new expression with no type params or arguments, like new Foo()
      match: (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?(\()\s*+(\)))
      name: meta.new-class.without-arguments.cgt
      captures:
        1: {name: keyword.operator.new.cgt}
        2: {name: meta.function-call.without-arguments.cgt}
        3: {name: keyword.operator.private.cgt}
        4: {name: entity.name.type.instance.cgt}
        5: {name: keyword.operator.existential.cgt}
        6: {name: meta.brace.round.cgt}
        7: {name: meta.brace.round.cgt}
    - applyEndPatternLast: 1
      begin: >-
        (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
      comment: A new expression with type params and no arguments, like new Foo<string>()
      end: (?=.)
      name: meta.new-class.without-arguments.cgt
      beginCaptures:
        1: {name: keyword.operator.new.cgt}
        2: {name: meta.function-call.without-arguments.cgt}
        3: {name: keyword.operator.private.cgt}
        4: {name: entity.name.type.instance.cgt}
        5: {name: keyword.operator.existential.cgt}
      patterns:
        - include: '#type-argument-brackets'
        - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: >-
        (?<!(?<!\.\.)\.|\#)\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
      comment: A new expression with arguments and maybe type params, like new Foo<string>(123)
      end: (?=.)
      name: meta.new-class.with-arguments.cgt
      beginCaptures:
        1: {name: keyword.operator.new.cgt}
        2: {name: meta.function-call.with-arguments.cgt}
        3: {name: keyword.operator.private.cgt}
        4: {name: entity.name.type.instance.cgt}
        5: {name: keyword.operator.existential.cgt}
      patterns:
        - include: '#type-argument-brackets'
        - include: '#round-brackets'
  number:
    comments: Generated numeric literals
    patterns:
      - match: |-
          (?xi)\s*\b
          0b
          [01] [01_]* [01]?
          (?:(\.) [01] [01_]* [01]?)?
          (?:(r) [01] [01_]* [01]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.binary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0b
          (?:[01] [01_]* [01]?)?
          (?:(\.) [01] [01_]* [01]?)
          (?:(r) [01] [01_]* [01]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.binary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0q
          [0-3] [0-3_]* [0-3]?
          (?:(\.) [0-3] [0-3_]* [0-3]?)?
          (?:(r) [0-3] [0-3_]* [0-3]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.quaternary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0q
          (?:[0-3] [0-3_]* [0-3]?)?
          (?:(\.) [0-3] [0-3_]* [0-3]?)
          (?:(r) [0-3] [0-3_]* [0-3]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.quaternary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0s
          [0-5] [0-5_]* [0-5]?
          (?:(\.) [0-5] [0-5_]* [0-5]?)?
          (?:(r) [0-5] [0-5_]* [0-5]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.senary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0s
          (?:[0-5] [0-5_]* [0-5]?)?
          (?:(\.) [0-5] [0-5_]* [0-5]?)
          (?:(r) [0-5] [0-5_]* [0-5]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.senary.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0o
          [0-7] [0-7_]* [0-7]?
          (?:(\.) [0-7] [0-7_]* [0-7]?)?
          (?:(r) [0-7] [0-7_]* [0-7]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.octal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0o
          (?:[0-7] [0-7_]* [0-7]?)?
          (?:(\.) [0-7] [0-7_]* [0-7]?)
          (?:(r) [0-7] [0-7_]* [0-7]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.octal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0z
          [\dabetxz] [\dabetxz_]* [\dabetxz]?
          (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.duodecimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0z
          (?:[\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)
          (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.duodecimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0x
          \h [\h_]* \h?
          (?:(\.) \h [\h_]* \h?)?
          (?:(r) \h [\h_]* \h?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.hexadecimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          0x
          (?:\h [\h_]* \h?)?
          (?:(\.) \h [\h_]* \h?)
          (?:(r) \h [\h_]* \h?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.hexadecimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          \d [\d_]* \d?
          (?:(\.) \d [\d_]* \d?)?
          (?:(r) \d [\d_]* \d?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.decimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          (?:\d [\d_]* \d?)?
          (?:(\.) \d [\d_]* \d?)
          (?:(r) \d [\d_]* \d?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.decimal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          \d\w
          \w [\w_]* \w?
          (?:(\.) \w [\w_]* \w?)?
          (?:(r) \w [\w_]* \w?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.illegal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
      - match: |-
          (?xi)\s*\b
          \d\w
          (?:\w [\w_]* \w?)?
          (?:(\.) \w [\w_]* \w?)
          (?:(r) \w [\w_]* \w?)?
          (?:(p[+-]?) \d+)?
          (?:(s) \d+)?
          (?:(k) \w+)?
        captures:
          0: {name: constant.numeric.illegal.cgt}
          1: {name: meta.delimiter.decimal.period.cgt}
          2: {name: storage.type.numeric.bigint.cgt}
          3: {name: storage.type.numeric.bigint.cgt}
          4: {name: storage.type.numeric.bigint.cgt}
          5: {name: storage.type.numeric.bigint.cgt}
  object:
    begin: (?:(?<=\(|\[|,)|(?:\s*(?:(=)|\b(default)\b|\b(return)\b|(,))))\s*({)
    comment: obj lteral ({ or ,{ or [{ or ={ or return { or default {
    end: \s*+(})
    beginCaptures:
      1: {name: keyword.operator.assignment.cgt}
      2: {name: keyword.control.module.cgt}
      3: {name: keyword.control.flow.cgt}
      4: {name: meta.delimiter.comma.cgt}
      5: {name: meta.brace.curly.litobj.cgt}
    endCaptures:
      1: {name: meta.brace.curly.litobj.cgt}
    patterns:
      - include: '#object-body'
  object-body:
    patterns:
      - include: '#flowtype-keywords'
      - include: languagebabel.ttlextension
      - include: '#html-template'
      - include: '#object-brace-property'
      - include: '#function-labels'
      - include: '#arrow-function-labels'
      - include: '#arrow-function'
      - include: '#method'
      - include: '#arrow-expression'
      - include: '#object-prop-shorthand'
      - include: '#labels'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#core'
      - include: '#punctuation'
  object-brace:
    begin: \s*({)
    comment: nested obj literal found inside other objects like arrays
    end: \s*+(})
    beginCaptures:
      1: {name: meta.brace.curly.litobj.cgt}
    endCaptures:
      1: {name: meta.brace.curly.litobj.cgt}
    patterns:
      - include: '#object-body'
  object-brace-property:
    begin: (?<=:)\s*({)
    comment: 'nested obj literal key: {object} '
    end: \s*+(})
    beginCaptures:
      1: {name: meta.brace.curly.litobj.cgt}
    endCaptures:
      1: {name: meta.brace.curly.litobj.cgt}
    patterns:
      - include: '#object-body'
  object-prop-shorthand:
    comment: give an alternate scope name to shorthand object literals
    patterns:
      - match: (?<=^|,|{)(?<!:|\.)\s*+(((?:[_\\p{Lu}\p{Nl}])(?:[_\\p{Lu}\p{Nl}])*+))\s*+(?=$|,|})
        captures:
          1: {name: constant.other.object.key.cgt}
          2: {name: variable.other.constant.shorthandpropertyname.cgt}
      - match: (?<=^|,|{)(?<!:|\.)\s*+(([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*))\s*+(?=$|,|})
        captures:
          1: {name: variable.other.readwrite.shorthandpropertyname.cgt}
  of-clause:
    begin: \s*+\b(of)
    end: \s*(=(?!=|>))|\s*(?<=})
    beginCaptures:
      1: {name: meta.enum.of.flowtype}
    endCaptures:
      1: {name: keyword.operator.assignment.cgt}
    patterns:
      - include: '#flowtype-parse-types'
  operator:
    patterns:
      - begin: \s*((:\?[<=>]?))\s*
        comment: Type assertion/conversion/coercion/casting operator
        end: (?=[^&|^~<>!?\p{L}\p{N}\p{Sc}\[\]{}_])
        beginCaptures:
          1: {name: keyword.operator.type.cgt}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
          - include: '#flowtype-parse-types'
      - match: \s*:=\s*
        name: keyword.operator.assignment.cgt
      - match: \s*\\\s*($|(?=/[/*]))
        name: constant.character.escape.newline.cgt
      - match: \s*(?:(::+)|([<>]:+|:+[<>]|[<>]:+[<>]))\s*
        captures:
          1: {name: keyword.operator.accessor.cgt}
          2: {name: keyword.operator.class.cgt}
          3: {name: keyword.operator.accessor.cgt}
  operators:
    patterns:
      - include: '#unary-ops'
      - include: '#binary-ops'
      - include: '#special-operators'
    repository:
      binary-ops:
        patterns:
          - comment: built-in operators need to be surrounded with spaces
            match: |
              (?x)(?<=^|\s)(?:
                ([\p{S}\p{P}&&[^_@:.;,'"`\\\p{Ps}\p{Pe}]]+(?<![!~<=>])=)| #1
                (\+\+|--)| #2
                (\+|-(?!>)|\*{1,3}|(?<!<)/(?!>)|\#|%%?|\*>|<\*)| #3
                (&&|\|\||\^\^|\\/|/\\)| #4
                ([&^]|\|(?!>)|~(?![!=<>]))| #5
                (=\.\.|\.\.=|=\.=|\.\.(?!\.))| #6
                (<[|+]|[|+]>)|(<<+|>>+)| #7-8
                ([<>]:|:[<>]|[<>]:[<>])| #9
                (=<|<>|[!=]~|~[!=]|[<>]~|~[<>])| #10
                (->|<-)|(<=>|[<>]=?)|(=[!:]=|[!=]==?)| #11-13
                (!\?|\?!)|(\?\??)|(\?:)|(!:)|(\.\.\.)| #14-18
                (\?\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}?])\?(?![.:])(?=\B))| #19
                (!\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}!])\!(?![.:])(?=\B))| #20
                (~\.)|((?<!(?<!\.\.)\.|\#)\.(?!=)|:::?)|((?:\.|::?)?=) #21-23
              )(?=$|\s)
            name: keyword.operator.builtin.cgt
            captures:
              1: {name: keyword.operator.assignment.augmented.cgt}
              2: {name: keyword.operator.crement.cgt}
              3: {name: keyword.operator.arithmetic.cgt}
              4: {name: keyword.operator.logical.cgt}
              5: {name: keyword.operator.bitwise.cgt}
              6: {name: keyword.operator.range.cgt}
              7: {name: keyword.operator.pipeline.cgt}
              8: {name: keyword.operator.bitwise.shift.cgt}
              9: {name: keyword.operator.class.cgt}
              10: {name: keyword.operator.similarity.cgt}
              11: {name: keyword.operator.then.cgt}
              12: {name: keyword.operator.relational.cgt}
              13: {name: keyword.operator.comparison.cgt}
              14: {name: keyword.operator.nonnull.cgt}
              15: {name: keyword.operator.nullcoalesce.cgt}
              16: {name: keyword.operator.ternary.cgt}
              17: {name: keyword.operator.quasiternary.cgt}
              18: {name: keyword.operator.spread.cgt}
              19: {name: keyword.operator.existential.cgt}
              20: {name: keyword.operator.assertion.cgt}
              21: {name: keyword.operator.cascade.cgt}
              22: {name: keyword.operator.accessor.cgt}
              23: {name: keyword.operator.assignment.cgt}
          - match: (?:(\?\.)|(~\.)|(!\.)|(\.))
            captures:
              1: {name: keyword.operator.existential.cgt}
              2: {name: keyword.operator.cascade.cgt}
              3: {name: keyword.operator.assertion.cgt}
              4: {name: keyword.operator.accessor.cgt}
          - comment: |
              custom operators
              (#7) /(<//+>|<//+|//+>|<{2,}|(?<!</)>{2,}|/+)(?!=)/ does not work
              so we will leave it here for now (please help)
            match: |
              (?x)
              ([&|^~][\p{S}\p{Po}\p{Pd}&&[^.,:;'"`\\$]]+)| #1
              (/[\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]+|
              [-+*%\#][\p{S}\p{Po}\p{Pd}&&[^.,:;'"`\\$]]+)| #2
              ([:.][\p{S}\p{Po}\p{Pd}&&[^.,:;'"`\\$]]+)| #3
              ([<>][\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]+)| #4
              ([!=][\p{S}\p{Po}\p{Pd}&&[^.,:;'"`\\$]]+)| #5
              (\?[\p{S}\p{Po}\p{Pd}&&[^.,:;'"`\\$]]+)| #6
              ([\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]+) #7
            name: keyword.operator.infix.cgt
            captures:
              1: {name: keyword.operator.logical.cgt}
              2: {name: keyword.operator.arithmetic.cgt}
              3: {name: keyword.operator.accessor.cgt}
              4: {name: keyword.operator.relational.cgt}
              5: {name: keyword.operator.comparison.cgt}
              6: {name: keyword.operator.existential.cgt}
              7: {name: keyword.operator.infix.cgt}
      unary-ops:
        patterns:
          - comment: Unary prefix operators
            match: |
              (?x)
              (?:(\*+)|(\++)|(\-+)|(\&+)|(\|+)|(\^+)|(\!+)|(\#+)|(\@+)|(\~+)|(\?+)| #1-11
              [\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]+) #12
              (?=[\p{L}\p{M}\p{N}\p{Ps}\p{Pe}])
            name: keyword.operator.prefix.cgt
            captures:
              1: {name: keyword.operator.module.all.cgt}
              2: {name: keyword.operator.increment.cgt}
              3: {name: keyword.operator.decrement.cgt}
              4: {name: keyword.operator.intersection.cgt}
              5: {name: keyword.operator.union.cgt}
              6: {name: keyword.operator.symdiff.cgt}
              7: {name: keyword.operator.logical.cgt}
              8: {name: keyword.operator.private.cgt}
              9: {name: keyword.operator.decorator.cgt}
              10: {name: keyword.operator.bitwise.cgt}
              11: {name: keyword.operator.existential.cgt}
              12: {name: keyword.operator.prefix.cgt}
          - comment: Unary suffix operators
            match: |
              (?x)
              (?<=[\p{L}\p{M}\p{N}\p{Ps}\p{Pe}])
              (?:(\*+)|(\++)|(\-+)|(\&+)|(\|+)|(\^+)|(\!+\.?)|(\#+)|(\@+)|(\~+\.?)|(\?+\.?)| #1-11
              [\p{S}\p{Po}\p{Pd}&&[^.,:;'"`</>\\$]]+) #12
            name: keyword.operator.suffix.cgt
            captures:
              1: {name: keyword.operator.module.all.cgt}
              2: {name: keyword.operator.increment.cgt}
              3: {name: keyword.operator.decrement.cgt}
              4: {name: keyword.operator.intersection.cgt}
              5: {name: keyword.operator.union.cgt}
              6: {name: keyword.operator.symdiff.cgt}
              7: {name: keyword.operator.assertion.cgt}
              8: {name: keyword.operator.private.cgt}
              9: {name: keyword.operator.decorator.cgt}
              10: {name: keyword.operator.cascade.cgt}
              11: {name: keyword.operator.existential.cgt}
              12: {name: keyword.operator.suffix.cgt}
  preprocessor:
    begin: ^\s*(\#)\s*
    end: (?<=$)
    name: meta.preprocessor.cgt
    beginCaptures:
      1: {name: punctuation.separator.hash.cgt}
    patterns:
      - include: '#comment'
      - include: '#preprocessor-define-or-undef'
      - include: '#preprocessor-if-or-elif'
      - include: '#preprocessor-else-or-endif'
      - include: '#preprocessor-warning-or-error'
      - include: '#preprocessor-region'
      - include: '#preprocessor-endregion'
      - include: '#preprocessor-load'
      - include: '#preprocessor-r'
      - include: '#preprocessor-line'
      - include: '#preprocessor-pragma-warning'
      - include: '#preprocessor-pragma-checksum'
  preprocessor-define-or-undef:
    match: \b(?:(define)|(undef))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b
    captures:
      1: {name: keyword.preprocessor.define.cgt}
      2: {name: keyword.preprocessor.undef.cgt}
      3: {name: entity.name.variable.preprocessor.symbol.cgt}
  preprocessor-else-or-endif:
    match: \b(?:(else)|(endif))\b
    captures:
      1: {name: keyword.preprocessor.else.cgt}
      2: {name: keyword.preprocessor.endif.cgt}
  preprocessor-endregion:
    match: \b(endregion)\b
    captures:
      1: {name: keyword.preprocessor.endregion.cgt}
  preprocessor-expression:
    patterns:
      - include: '#core'
  preprocessor-if-or-elif:
    begin: \b(?:(if)|(elif))\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.if.cgt}
      2: {name: keyword.preprocessor.elif.cgt}
    patterns:
      - include: '#comment'
      - include: '#preprocessor-expression'
  preprocessor-line:
    begin: \b(line)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.line.cgt}
    patterns:
      - match: \b(?:(default|hidden))
        captures:
          1: {name: keyword.preprocessor.default.cgt}
          2: {name: keyword.preprocessor.hidden.cgt}
      - match: '[0-9]+'
        captures:
          0: {name: constant.numeric.decimal.cgt}
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.cgt}
  preprocessor-load:
    begin: \b(load)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.load.cgt}
    patterns:
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.cgt}
  preprocessor-pragma-checksum:
    match: \b(pragma)\b\s*\b(checksum)\b\s*(\"[^"]*\")\s*(\"[^"]*\")\s*(\"[^"]*\")
    captures:
      1: {name: keyword.preprocessor.pragma.cgt}
      2: {name: keyword.preprocessor.checksum.cgt}
      3: {name: string.quoted.double.cgt}
      4: {name: string.quoted.double.cgt}
      5: {name: string.quoted.double.cgt}
  preprocessor-pragma-warning:
    match: \b(pragma)\b\s*\b(warning)\b\s*\b(?:(disable)|(restore))\b(\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
    captures:
      1: {name: keyword.preprocessor.pragma.cgt}
      2: {name: keyword.preprocessor.warning.cgt}
      3: {name: keyword.preprocessor.disable.cgt}
      4: {name: keyword.preprocessor.restore.cgt}
      5: {patterns: [{match: '[0-9]+', captures: {0: {name: constant.numeric.decimal.cgt}}}, {include:
      '#punctuation-comma'}]}
  preprocessor-r:
    begin: \b(r)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.r.cgt}
    patterns:
      - match: \"[^"]*\"
        captures:
          0: {name: string.quoted.double.cgt}
  preprocessor-region:
    match: \b(region)\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.region.cgt}
      2: {name: string.unquoted.preprocessor.message.cgt}
  preprocessor-warning-or-error:
    match: \b(?:(warning)|(error))\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.warning.cgt}
      2: {name: keyword.preprocessor.error.cgt}
      3: {name: string.unquoted.preprocessor.message.cgt}
  prototype:
    patterns:
      - comment: e.g. Sound.prototype
        match: \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\b
        name: meta.prototype.access.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: variable.language.prototype.cgt}
      - comment: e.g. Sound.prototype = { }
        match: \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\s*+=\s*+
        name: meta.prototype.declaration.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: entity.name.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: variable.language.prototype.cgt}
  punctuation:
    patterns:
      - include: '#semi-colon'
      - include: '#comma'
  punctuation-semicolon:
    match: ;
    name: punctuation.terminator.statement.cgt
  quasi:
    patterns:
      - include: languagebabel.ttlextension
      - begin: >-
          \s*+(?:(?:\b(css|injectGlobal|keyframes|createGlobalStyle|stylesheet)\b)|(?:(\bstyled)(?:(?:(\?\.)|(\.))\s*(\w+)))|(/\*
          CSS \*/))\s*((`))
        comment: Styled CSS tags
        contentName: source.inside-js.css.styled
        end: \s*((`))
        beginCaptures:
          1: {name: entity.name.tag.styledcss.cgt}
          2: {name: entity.name.tag.styledcss.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: entity.name.tag.styledcss.cgt}
          6: {name: string.quoted.template.styled.start.cgt}
          7: {name: punctuation.definition.quasi.begin.cgt}
        endCaptures:
          1: {name: string.quoted.template.styled.end.cgt}
          2: {name: punctuation.definition.quasi.end.cgt}
        patterns:
          - include: source.css.styled
      - begin: (?<!(?<!\.\.)\.|\#)\s*+(?:([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(extend))\s*((`))
        comment: Styled CSS tags
        contentName: source.inside-js.css.styled
        end: \s*((`))
        beginCaptures:
          1: {name: variable.other.class.cgt}
          2: {name: keyword.operator.existential.cgt}
          3: {name: keyword.operator.accessor.cgt}
          4: {name: entity.name.tag.styledcss.cgt}
          5: {name: string.quoted.template.styled.start.cgt}
          6: {name: punctuation.definition.quasi.begin.cgt}
        endCaptures:
          1: {name: string.quoted.template.styled.end.cgt}
          2: {name: punctuation.definition.quasi.end.cgt}
        patterns:
          - include: source.css.styled
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(?:(\bstyled)|([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(withComponent))(?=\s*((\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))*\s*(`|\.extend`|$)))
        comment: Styled CSS tag functions
        end: (?=.)
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
          2: {name: variable.other.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.cgt}
              2: {name: punctuation.definition.quasi.begin.cgt}
            endCaptures:
              1: {name: string.quoted.template.styled.end.cgt}
              2: {name: punctuation.definition.quasi.end.cgt}
            patterns:
              - include: source.css.styled
          - comment: Styled CSS tags
            match: \s*(\.)\s*(extend)(?=\s*`)
            captures:
              1: {name: keyword.operator.accessor.cgt}
              2: {name: entity.name.tag.styledcss.cgt}
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(?:(\bstyled))(?=\s*((\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))*\s*\??\.\s*attrs\s*\())
        comment: Styled CSS tag functions
        end: (?=.)
        beginCaptures:
          1: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - match: \s*(?:(\?\.)|(\.))\s*(attrs)
            captures:
              1: {name: keyword.operator.existential.cgt}
              2: {name: keyword.operator.accessor.cgt}
              3: {patterns: [{include: '#function-name'}]}
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.cgt}
              2: {name: punctuation.definition.quasi.begin.cgt}
            endCaptures:
              1: {name: string.quoted.template.styled.end.cgt}
              2: {name: punctuation.definition.quasi.end.cgt}
            patterns:
              - include: source.css.styled
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+(?:(\bstyled)\s*(?:(\?\.)|(\.))\s*([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*(?:(\?\.)|(\.))\s*(attrs|withConfig))(?=\s*\()
        comment: Styled CSS tag functions
        end: (?=.|\n)
        beginCaptures:
          1: {name: entity.name.tag.styledcss.cgt}
          2: {name: keyword.operator.existential.cgt}
          3: {name: keyword.operator.accessor.cgt}
          4: {name: entity.name.tag.styledcss.cgt}
          5: {name: keyword.operator.existential.cgt}
          6: {name: keyword.operator.accessor.cgt}
          7: {patterns: [{include: '#function-name'}]}
        patterns:
          - include: '#round-brackets'
          - begin: \s*((`))
            contentName: source.inside-js.css.styled
            end: \s*((`))
            beginCaptures:
              1: {name: string.quoted.template.styled.start.cgt}
              2: {name: punctuation.definition.quasi.begin.cgt}
            endCaptures:
              1: {name: string.quoted.template.styled.end.cgt}
              2: {name: punctuation.definition.quasi.end.cgt}
            patterns:
              - include: source.css.styled
      - begin: \s*+(?:((Relay)(?:(\?\.)|(\.))(QL))|(gql|graphql|graphql\.experimental)|(/\* GraphQL \*/))\s*((`))
        comment: GraphQL ( Relay.QL ) supprt. Use two forms of scopes! fixes some themes
        end: \s*((`))
        beginCaptures:
          2: {name: variable.other.class.cgt}
          3: {name: keyword.operator.existential.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: entity.name.tag.graphql.cgt}
          6: {name: entity.name.tag.graphql.cgt}
          7: {name: entity.name.tag.graphql.cgt}
          8: {name: string.quoted.template.cgt}
          9: {name: punctuation.definition.quasi.begin.cgt}
        endCaptures:
          1: {name: string.quoted.template.graphql.cgt}
          2: {name: punctuation.definition.quasi.end.cgt}
        patterns:
          - include: '#graphql'
      - begin: \s*+(?!\b(?:return|void)\b)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)?\s*((`))
        comment: Use two forms of scopes! fixes some themes
        contentName: string.quoted.template.cgt
        end: \s*((`))
        name: string.quasi.cgt
        beginCaptures:
          1: {name: entity.name.tag.cgt}
          2: {name: string.quoted.template.cgt}
          3: {name: punctuation.definition.quasi.begin.cgt}
        endCaptures:
          1: {name: string.quoted.template.cgt}
          2: {name: punctuation.definition.quasi.end.cgt}
        patterns:
          - include: '#quasi-embedded'
          - include: '#string-content'
  quasi-embedded:
    patterns:
      - comment: Accepts arbitrary expressions
        match: (?<!\\)(\#)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)((:)[-\w/.%#<^>+*=!]+)?
        captures:
          1: {name: punctuation.quasi.element.cgt}
          2: {patterns: [{include: '#core'}]}
          3: {name: storage.type.format.cgt}
          4: {name: punctuation.separator.label.regexp}
      - begin: (?<!\\)(\#\{)\s*
        end: \s*(\})((:)[-\w/.%#<^>+*=!]+)?
        name: entity.quasi.element.cgt
        beginCaptures:
          1: {name: punctuation.quasi.element.begin.cgt}
        endCaptures:
          1: {name: punctuation.quasi.element.end.cgt}
          2: {name: storage.type.format.cgt}
          3: {name: punctuation.separator.label.regexp}
        patterns:
          - include: '#core'
  quasi-embedded-regexp:
    patterns:
      - comment: Accepts arbitrary expressions
        match: (?<!\\)(\#)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)((:)[-\w/.%#<^>+*=!]+)?
        captures:
          1: {name: punctuation.quasi.element.cgt}
          2: {patterns: [{include: '#core'}]}
          3: {name: storage.type.format.cgt}
          4: {name: punctuation.separator.label.regexp}
      - begin: (?<!\\)(\#\{)\s*
        end: \s*(\})((:)[-\w/.%#<^>+*=!]+)?
        name: entity.quasi.element.cgt
        beginCaptures:
          1: {name: punctuation.quasi.element.begin.cgt}
        endCaptures:
          1: {name: punctuation.quasi.element.end.cgt}
          2: {name: storage.type.format.cgt}
          3: {name: punctuation.separator.label.regexp}
        patterns:
          - include: '#core'    
  query:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(query)\b\s*
        comment: query ... in
        end: \s*(in|of)\b
        beginCaptures:
          1: {name: keyword.query.cgt}
        endCaptures:
          1: {name: keyword.query.cgt}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#join-keywords'
      - include: '#order-direction'
      - include: '#order-clause'
      - include: '#group-clause'
      - include: '#select-clause'
      - include: '#order-clause'
    repository:
      group-clause:
        begin: (?<!(?<!\.\.)\.|\#)\s*+\b(group)\b\s*
        comment: group ... by
        end: \s*(by)\b
        beginCaptures:
          1: {name: keyword.query.cgt}
        endCaptures:
          1: {name: keyword.query.cgt}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      join-clause:
        begin: (?<!(?<!\.\.)\.|\#)\s*+\b(join)\b\s*
        comment: group ... by
        end: \s*(in|of)\b
        beginCaptures:
          1: {name: keyword.query.cgt}
        endCaptures:
          1: {name: keyword.query.cgt}
        patterns:
          - include: '#let-clause'
          - include: '#core'
      join-keywords:
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(equals?|[io]nto)\b\s*
        name: keyword.query.cgt
      let-clause:
        comment: override let keyword
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(const|con|let|var|val)\b\s*
        name: storage.type.cgt
      order-clause:
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(order\s*(by)?)\b\s*
        name: keyword.query.cgt
      order-direction:
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(ascending|descending)\b\s*
        name: keyword.query.cgt
      select-clause:
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(select)\b\s*
        name: keyword.query.cgt
      where-clause:
        match: (?<!(?<!\.\.)\.|\#)\s*+\b(where)\b\s*
        name: keyword.query.cgt
  regex-group-name:
    patterns:
      - include: '#jsx-tag-attributes'
      - include: '#support'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#method-name'
      - include: '#function-name'
      - include: '#operator'
      - include: '#operators'
  regexp:
    begin: >-
      (?<=^|[^/\-_\\\p{L}\p{M}\p{N}])\s*+([[:alnum:]]*)(/)(?![*/])(?=.*/[[:alnum:]]*\s*($|[,;)}\]]|\.[-_\\\p{L}\p{M}\p{N}]))
    comment: Updated to support Perl regex syntax
    end: (/)(?:((?:\\.|.)*?)(/))?([[:alnum:]]*)
    name: string.regexp.cgt
    beginCaptures:
      1: {name: keyword.modifier.cgt}
      2: {name: punctuation.definition.string.begin.cgt}
    endCaptures:
      1: {name: punctuation.definition.string.end.cgt}
      2: {name: keyword.other.flag.cgt}
    patterns:
      - include: '#regexp-patterns'
  regexp-patterns:
    patterns:
      - include: '#quasi-embedded-regexp'
      - match: \|
        name: keyword.operator.or.regexp
      - match: (?i)\\[abyz]|\^|\$
        name: keyword.control.anchor.regexp
      - comment: Suppress ? in (? sequence
        match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.regexp}
          2: {name: keyword.operator.quantifier.lazy.regexp}
          3: {name: keyword.operator.quantifier.eager.regexp}
          4: {name: keyword.operator.quantifier.greedy.regexp}
      - begin: (?<=\()(\?\{)
        comment: Embedded code callouts
        end: \s*(\})([<*>])?(?:(\[)(.*)(\]))?
        name: keyword.operator.callout.regexp
        beginCaptures:
          1: {name: keyword.operator.callout.regexp}
          2: {name: keyword.operator.callout.regexp}
        endCaptures:
          1: {name: keyword.operator.callout.regexp}
          2: {name: keyword.operator.range.regexp}
          3: {name: punctuation.definition.tag.regexp}
          4: {patterns: [{include: $self}]}
          5: {name: punctuation.definition.tag.regexp}
        patterns:
          - include: $self
      - begin: (?<=\()(\?<)
        comment: Named groups
        end: \s*(>)
        name: punctuation.definition.group.named.regexp
        beginCaptures:
          1: {name: punctuation.definition.group.named.regexp}
        endCaptures:
          1: {name: punctuation.definition.group.named.regexp}
        patterns:
          - include: '#regex-group-name'
      - match: (?<=\()(\?(?:([+-]?\d+?)|([A-Z\d]+(?:-[A-Z\d]+)?)|([a-z\d]+(?:-[a-z\d]+)?)))\s*(:)?
        name: keyword.control.back-reference.regexp
        captures:
          1: {name: keyword.other.back-reference.regexp}
          2: {name: entity.name.function.method.regexp}
          3: {name: keyword.control.recursion.regexp}
          4: {name: storage.type.regexp}
          5: {name: punctuation.separator.label.regexp}
      - match: (?<=\?\()(?:([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)|([+-]?\d*))(?=\))
        name: keyword.control.conditional.group.regexp
        captures:
          1: {name: variable.other.regexp}
          2: {name: keyword.other.back-reference.regexp}
      - match: \\[1-9]\d*
        name: keyword.other.back-reference.regexp
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}\??
        name: keyword.operator.quantifier.regexp
      - begin: (\\Q)
        contentName: string.quoted.double.regexp
        end: (\\E)
        name: string.quoted.raw.regexp
        beginCaptures:
          1: {name: punctuation.definition.string.begin.regexp}
        endCaptures:
          1: {name: punctuation.definition.string.end.regexp}
      - begin: (\\q)
        contentName: string.quoted.single.regexp
        end: (\\e)
        name: string.quoted.regexp
        beginCaptures:
          1: {name: punctuation.definition.string.begin.regexp}
        endCaptures:
          1: {name: punctuation.definition.string.end.regexp}
        patterns:
          - include: '#string-content'
      - begin: \((\?(?:&|P(=))(?:([+-]?\d+)|([_\\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
        end: \s*(\))
        name: meta.group.regexp
        beginCaptures:
          0: {name: punctuation.definition.group.regexp}
          1: {name: keyword.other.back-reference.regexp}
          2: {name: keyword.operator.assignment.regexp}
          3: {name: entity.name.function.method.regexp}
          4: {name: variable.other.regexp}
          5: {name: punctuation.separator.label.regexp}
        endCaptures:
          1: {name: punctuation.definition.group.regexp}
        patterns:
          - include: '#regexp-patterns'
      - begin: \(([*+])
        end: \s*(\))
        name: constant.other.pcre.regexp
        beginCaptures:
          0: {name: punctuation.definition.group.regexp}
          1: {name: keyword.generator.regexp}
        endCaptures:
          1: {name: punctuation.definition.group.regexp}
        patterns:
          - include: '#mini-expression'
      - begin: (\()(\?#)
        contentName: comment.line.number-sign.regexp
        end: \s*(\))
        name: comment.line.number-sign.regexp
        beginCaptures:
          1: {name: punctuation.definition.group.regexp}
          2: {name: punctuation.definition.comment.regexp}
        endCaptures:
          1: {name: punctuation.definition.group.regexp}
        patterns:
          - match: \\.
            name: comment.line.number-sign.regexp
      - begin: (\()((\?=)|(\?!)|(\?<=)|(\?<!)|(\?>)|(?:(\?))(?=[(|])|(\?~))
        end: \s*(\))
        name: meta.group.regexp
        beginCaptures:
          1: {name: punctuation.definition.group.regexp}
          2: {name: punctuation.definition.group.assertion.regexp}
          3: {name: meta.assertion.look-ahead.regexp}
          4: {name: meta.assertion.negative-look-ahead.regexp}
          5: {name: meta.assertion.look-behind.regexp}
          6: {name: meta.assertion.negative-look-behind.regexp}
          7: {name: meta.group.atomic.regexp}
          8: {name: meta.group.branch.regexp}
          9: {name: meta.group.absent.regexp}
        endCaptures:
          1: {name: punctuation.definition.group.regexp}
        patterns:
          - include: '#regexp-patterns'
      - begin: \((?:(\?:)|(?:\?<(.*?)>))?
        end: \s*(\))
        name: meta.group.regexp
        beginCaptures:
          0: {name: punctuation.definition.group.regexp}
          1: {name: punctuation.definition.group.no-capture.regexp}
          2: {patterns: [{include: '#regex-group-name'}]}
        endCaptures:
          0: {name: punctuation.definition.group.regexp}
        patterns:
          - include: '#regexp-patterns'
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.regexp
        beginCaptures:
          1: {name: keyword.other.back-reference.regexp}
        endCaptures:
          1: {name: keyword.other.back-reference.regexp}
        patterns:
          - include: '#jsx-tag-attributes'
          - include: '#support'
          - include: '#keywords'
          - include: '#modifiers'
          - include: '#method-name'
          - include: '#function-name'
          - include: '#operator'
          - include: '#operators'
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.regexp
        beginCaptures:
          1: {name: keyword.other.subroutine.regexp}
        endCaptures:
          1: {name: keyword.other.subroutine.regexp}
        patterns:
          - include: '#jsx-tag-attributes'
          - include: '#support'
          - include: '#keywords'
          - include: '#modifiers'
          - include: '#method-name'
          - include: '#function-name'
          - include: '#operator'
          - include: '#operators'
      - begin: (\[)(\^)?
        end: \s*(\])
        name: constant.other.character-class.set.regexp
        beginCaptures:
          1: {name: punctuation.definition.character-class.regexp}
          2: {name: keyword.operator.negation.regexp}
        endCaptures:
          1: {name: punctuation.definition.character-class.regexp}
        patterns:
          - include: '#comments'
          - match: '--'
            name: keyword.operator.optional.regexp
          - include: '#regex-character-class'
          - include: '#regex-character-range'
          - include: '#regex-character-set'
      - begin: (\{)
        end: \s*(\})
        name: meta.brace.curly.litobj.regexp
        patterns:
          - include: '#regexp-patterns'
      - include: '#regex-character-class'
      - comment: Remaining backslash tokens
        match: (?i)\\(?:(M)|(K)|(G)|(X))
        captures:
          1: {name: keyword.control.anchor.regexp}
          2: {name: keyword.control.keepout.regexp}
          3: {name: keyword.control.search.regexp}
          4: {name: constant.character.unicode.regexp}
      - match: \\.
        name: constant.character.escape.other.regexp
      - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.regexp}
          2: {name: keyword.operator.modifier.eager.regexp}
          3: {name: keyword.operator.modifier.greedy.regexp}
      - match: (\?)|(\+)|(\*)|(;)|(,)|(:)(?!:)|(=+>|~+>)|(['"])|(`)
        captures:
          1: {name: keyword.operator.quantifier.lazy.regexp}
          2: {name: keyword.operator.quantifier.eager.regexp}
          3: {name: keyword.operator.quantifier.greedy.regexp}
          4: {name: punctuation.terminator.statement.cgt}
          5: {name: meta.delimiter.comma.cgt}
          6: {name: meta.switch.cgt keyword.operator.cgt}
          7: {name: storage.type.function.arrow.cgt}
          8: {name: punctuation.definition.string.begin.cgt}
          9: {name: punctuation.definition.quasi.begin.cgt}
      - include: '#operator'
      - include: '#operators'
      - include: '#number'
      - include: '#comments'
    repository:
      regex-character-class:
        patterns:
          - match: |
              \\
            name: constant.character.escape.newline.regexp
          - begin: (?i)(\\p{)
            end: \s*(})
            name: constant.other.character-class.unicode.regexp
            beginCaptures:
              1: {name: constant.other.character-class.unicode.regexp}
            endCaptures:
              1: {name: constant.other.character-class.unicode.regexp}
            patterns:
              - include: '#implicit-call'
              - include: '#regexp-patterns'
          - match: \\x\h{2}|\\U\h{8}
            name: constant.character.escape.hex.regexp
          - match: \\[cCmM][[:alpha:]]|\R
            name: constant.character.control.regexp
          - match: \\[pP][[:alpha:]]|\\O
            name: constant.other.character-class.unicode.regexp
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.regexp
          - match: \\[ux](({[\h\s]+\})|\h{4})
            name: constant.character.escape.unicode.regexp
          - begin: (?i)(\\f{)
            end: \s*(})
            name: constant.character.entity.named.cgt
            beginCaptures:
              1: {name: constant.character.entity.named.cgt}
            endCaptures:
              1: {name: constant.character.entity.named.cgt}
            patterns:
              - include: '#implicit-call'
              - include: '#regexp-patterns'
          - match: \.|\\[wsdvntluh]
            name: constant.other.character-class.regexp
          - match: \\[WSDVNTLUH]
            name: constant.other.character-class.negated.regexp
          - match: \\N{[\w\s]+}
            name: constant.character.escape.unicode.name.regexp
          - match: \\o{[0-7]+}
            name: constant.character.escape.octal.regexp
          - match: \\['"\\nrtfve0`]
            name: constant.character.escape.cgt
      regex-character-range:
        patterns:
          - match: >-
              (?:.|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))
            name: constant.other.character-class.range.regexp
            captures:
              1: {name: constant.character.numeric.regexp}
              2: {name: constant.character.control.regexp}
              3: {name: constant.character.escape.backslash.regexp}
              4: {name: constant.character.numeric.regexp}
              5: {name: constant.character.control.regexp}
              6: {name: constant.character.escape.backslash.regexp}
      regex-character-set:
        patterns:
          - match: '[|]{2}'
            name: keyword.operator.union.regexp
          - match: '&{2}'
            name: keyword.operator.intersection.regexp
          - match: \^{2}
            name: keyword.operator.only.regexp
          - match: ~{2}
            name: keyword.operator.maybe.regexp
          - match: \.
            name: constant.other.character-class.set.regexp
          - begin: (\[=)
            end: \s*(=\])
            name: constant.other.character-class.posix.regexp
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[\.)
            end: \s*(\.\])
            name: constant.other.character-class.posix.regexp
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[:)
            end: \s*(:\])
            name: constant.other.character-class.posix.regexp
            beginCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            endCaptures:
              1: {name: punctuation.definition.character-class.posix.regexp}
            patterns:
              - include: '#comments'
              - include: '#variables'
              - include: '#operators'
          - begin: (\[)(\^)?
            end: \s*(\])
            name: constant.other.character-class.set.regexp
            beginCaptures:
              1: {name: punctuation.definition.character-class.regexp}
              2: {name: keyword.operator.negation.regexp}
            endCaptures:
              1: {name: punctuation.definition.character-class.regexp}
            patterns:
              - include: '#comments'
              - match: '--'
                name: keyword.operator.optional.regexp
              - include: '#regex-character-range'
              - include: '#regex-character-class'
              - include: '#regex-character-set'
              - match: \\.
                name: constant.character.escape.other.regexp
          - match: \\.
            name: constant.character.escape.other.regexp
  round-brackets:
    patterns:
      - begin: \s*+(#\()
        end: \s*(\))
        beginCaptures:
          1: {name: meta.brace.round.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#core'
      - begin: \s*+(\()
        end: \s*(\))
        beginCaptures:
          1: {name: meta.brace.round.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#core'
  semi-colon:
    patterns:
      - match: \s*+(;)
        captures:
          1: {name: punctuation.terminator.statement.cgt}
  special-comments-conditional-compilation:
    patterns:
      - begin: \s*+((/\*))(?=@)
        contentName: comment.block.conditional.cgt
        end: \s*\*/
        captures:
          1: {name: comment.block.conditional.cgt}
          2: {name: punctuation.definition.comment.cgt}
        endCaptures:
          1: {name: keyword.control.conditional.cgt}
          2: {name: punctuation.definition.keyword.cgt}
        patterns:
          - match: \s*+/\*
            name: punctuation.definition.comment.cgt
          - include: $self
      - match: \s*+(?!@)(@)(if|elif|else|end|ifdef|endif|cc_on|set)\b
        name: keyword.control.conditional.cgt
        captures:
          1: {name: punctuation.definition.keyword.cgt}
      - match: >-
          \s*+(?!@)(@)(_win32|_win16|_mac|_alpha|_x86|_mc680x0|_PowerPC|_jscript|_jscript_build|_jscript_version|_debug|_fast|[a-zA-Z]\w+)
        name: variable.other.conditional.cgt
        captures:
          1: {name: punctuation.definition.variable.cgt}
  special-operators:
    patterns:
      - include: '#esnext-pipeline'
      - begin: \s*((:\?[<=>]?))\s*
        comment: Type assertion/conversion/coercion/casting operator
        end: (?=[^&|^~<>!?\p{L}\p{N}\p{Sc}\[\]{}_])
        beginCaptures:
          1: {name: keyword.operator.type.cgt}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
          - include: '#flowtype-parse-types'
      - begin: \s*+(\?)(?!\.[^\d]|[?=])(?=\s)
        comment: 'ternary operator - make sure end : is consumed to avoid mistake as flow type'
        end: \s*(:)((?=::)|(?!:|=))
        beginCaptures:
          1: {name: keyword.operator.ternary.cgt}
        endCaptures:
          1: {name: keyword.operator.ternary.cgt}
        patterns:
          - begin: \s*+(?=([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*:)
            end: \s*(?=:)
            patterns:
              - include: '#language-constant'
              - include: '#variable'
          - include: '#core'
      - begin: (\$)\s*
        end: \s*(\$)
        name: keyword.operator.function.cgt
        beginCaptures:
          1: {name: keyword.operator.cgt}
        endCaptures:
          1: {name: keyword.operator.cgt}
        patterns:
          - include: '#function-name'
          - include: '#method-name'
          - include: '#core'
  square-brackets:
    patterns:
      - begin: \s*+(#\[)
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.cgt}
        endCaptures:
          1: {name: meta.brace.square.cgt}
        patterns:
          - match: ':'
            name: punctuation.separator.slice.cgt
          - include: '#object'
          - include: '#core'
      - begin: \s*+(\[)
        end: \s*(\])
        beginCaptures:
          1: {name: meta.brace.square.cgt}
        endCaptures:
          1: {name: meta.brace.square.cgt}
        patterns:
          - match: ':'
            name: punctuation.separator.slice.cgt
          - include: '#object'
          - include: '#core'
  string:
    patterns:
      - begin: \s*+(('))
        contentName: string.quoted.single.cgt
        end: |-
          \s*+(?:(('))|(
          ))
        beginCaptures:
          1: {name: string.quoted.single.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: string.quoted.single.cgt}
          2: {name: punctuation.definition.string.end.cgt}
          3: {name: invalid.illegal.newline.cgt}
        patterns:
          - include: '#string-content'
      - begin: \s*+(("))
        contentName: string.quoted.double.cgt
        end: |-
          \s*+(?:(("))|(
          ))
        beginCaptures:
          1: {name: string.quoted.double.cgt}
          2: {name: punctuation.definition.string.begin.cgt}
        endCaptures:
          1: {name: string.quoted.double.cgt}
          2: {name: punctuation.definition.string.end.cgt}
          3: {name: invalid.illegal.newline.cgt}
        patterns:
          - include: '#string-content'
  string-content:
    patterns:
      - include: '#new-operators'
      - match: |
          \\
        name: constant.character.escape.newline.cgt
      - begin: \\[hHN]{
        end: '}'
        name: constant.character.entity.named.cgt
        beginCaptures:
          1: {name: constant.character.entity.named.cgt}
        endCaptures:
          1: {name: constant.character.entity.named.cgt}
        patterns:
          - include: '#implicit-call'
          - include: '#regexp-patterns'
      - match: \\[0-7]{1,3}|\\o{[0-7\s.,:;]*?}
        name: constant.character.escape.octal.cgt
      - match: \\['"\\anrtbfve0$%#`]
        name: constant.character.escape.cgt
      - match: \\u({[\h\s.,:;]*?}|\h{4})|\\U\h{8}
        name: constant.character.escape.unicode.cgt
      - match: \\x\h{2}
        name: constant.character.escape.hex.cgt
      - match: '''''|""|``'
        name: constant.character.escape.cgt
      - match: \\.
        name: constant.character.escape.newline.cgt
      - include: '#quasi-embedded'
  support:
    patterns:
      - match: |
          (?x) (?<!(?<!\.\.)\.|\#) \s*+ \b(
            (
              Arithmetic | Assertion | Attribute | Buffer | BlockingIO
              | BrokenPipe | ChildProcess
              | (Connection (Aborted | Refused | Reset)?)
              | EOF | Environment | FileExists | FileNotFound
              | FloatingPoint | IO | Import | Indentation | Index | Interrupted
              | IsADirectory | NotADirectory | Permission | ProcessLookup
              | Timeout
              | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow
              | Reference | Runtime | Recursion | Syntax | System
              | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?
              | Value | Windows | ZeroDivision | ModuleNotFound
            ) Error
          |
            ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import
              | Unicode | Bytes | Resource
            )? Warning
          |
            SystemExit | Stop(Async)?Iteration
            | KeyboardInterrupt
            | GeneratorExit | (Base)?Error
          )\b
        name: support.class.error.cgt
      - applyEndPatternLast: 1
        begin: >-
          \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.builtin.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        beginCaptures:
          2: {name: support.class.builtin.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: support.class.builtin.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        beginCaptures:
          2: {name: support.class.builtin.cgt}
          4: {name: keyword.operator.accessor.cgt}
          5: {name: support.class.builtin.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: (?<!(?<!\.\.)\.|\#)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.error.cgt}
        patterns:
          - include: '#round-brackets'
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(debug)\b
        captures:
          1: {name: keyword.other.cgt}
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.cgt}
      - match: >-
          \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.cgt}
      - applyEndPatternLast: 1
        begin: (?<!(?<!\.\.)\.|\#)\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        beginCaptures:
          1: {name: support.type.object.console.cgt}
          2: {name: keyword.operator.accessor.cgt}
          3: {name: support.function.console.cgt}
        patterns:
          - include: '#round-brackets'
      - match: >-
          (?<!(?<!\.\.)\.|\#)\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.cgt}
          2: {name: keyword.operator.accessor.cgt}
          3: {name: support.type.object.process.cgt}
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        beginCaptures:
          1: {name: support.type.object.process.cgt}
          2: {name: keyword.operator.accessor.cgt}
          3: {name: support.function.process.cgt}
        patterns:
          - include: '#round-brackets'
      - match: (((?<!(?<!\.\.)\.|\#)\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.cgt}
          2: {name: keyword.operator.accessor.cgt}
          3: {name: support.type.object.module.cgt}
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.cgt}
      - applyEndPatternLast: 1
        begin: >-
          \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.class.node.cgt}
        patterns:
          - include: '#round-brackets'
      - begin: \s*+({{)
        contentName: meta.tag.mustache.cgt
        end: (\s*}})
        captures:
          1: {name: meta.tag.mustache.cgt}
      - include: '#support-objects'
  support-functions:
    patterns:
      - include: '#support-python'
  support-methods:
    patterns:
      - applyEndPatternLast: 1
        begin: >-
          (?<!(?<!\.\.)\.|\#)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(add|append|at|average|chunk|clone|compact|concat|construct|copyWithin|count|create|difference|differenceBy|differenceWith|drop|dropRight|dropRightWhile|dropWhile|entries|every|exclude|fill|filter|find|findIndex|findLastIndex|first|flat|flatMap|flatten|flattenDeep|flattenDepth|fnFromIndex|forEach|from|fromPairs|groupBy|head|includes|indexOf|inGroups|inGroupsOf|initial|insert|intersect|intersection|intersectionBy|intersectionWith|isArray|isEmpty|isEqual|join|keys|last|lastIndexOf|least|map|max|median|min|most|none|nth|object|of|pop|pull|pullAll|pullAllBy|pullAllWith|pullAt|push|range|reduce|reduceRight|remove|removeAt|rest|reverse|sample|shift|shuffle|slice|some|sort|sortBy|sortedIndex|sortedIndexBy|sortedIndexOf|sortedLastIndex|sortedLastIndexBy|sortedLastIndexOf|sortedUniq|sortedUniqBy|splice|subtract|sum|tail|take|takeRight|takeRightWhile|takeWhile|to|toLocaleString|toSource|toString|union|unionBy|unionWith|uniq|uniqBy|unique|uniqWith|unshift|unzip|unzipWith|values|without|xor|xorBy|xorWith|zip|zipObject|zipObjectDeep|zipWith)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.array.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(add|and|clamp|clone|compareExchange|contains|dateUnit|every|exchange|intersect|isLockFree|isValid|load|notify|or|span|store|sub|toArray|toString|union|wait|xor)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.atomics.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(asIntN|asUintN|toLocaleString|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.bigint.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(toSource|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.boolean.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(contains|countBy|each|eachRight|every|filter|find|findLast|findWhere|flatMap|flatMapDeep|flatMapDepth|forEach|forEachRight|groupBy|includes|indexBy|invoke|invokeMap|keyBy|map|max|min|orderBy|partition|pluck|reduce|reduceRight|reject|sample|sampleSize|shuffle|size|some|sortBy|toArray|where)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.collection.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(getBigInt64|getBigUint64|getFloat32|getFloat64|getInt16|getInt32|getInt8|getUint16|getUint32|getUint8|setBigInt64|setBigUint64|setFloat32|setFloat64|setInt16|setInt32|setInt8|setUint16|setUint32|setUint8)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.dataview.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(addLocale|addUnits|advance|beginningOfISOWeek|beginningOfUnit|clone|create|daysInMonth|endOfISOWeek|endOfUnit|format|full|get|getAllLocaleCodes|getAllLocales|getDate|getDay|getFullYear|getHours|getISOWeek|getLocale|getMilliseconds|getMinutes|getMonth|getOption|getSeconds|getTime|getTimezoneOffset|getUTCDate|getUTCDay|getUTCFullYear|getUTCHours|getUTCMilliseconds|getUTCMinutes|getUTCMonth|getUTCOffset|getUTCSeconds|getUTCWeekday|getWeekday|getYear|is|isAfter|isBefore|isBetween|isDay|isFuture|isLastUnit|isLeapYear|isNextUnit|iso|isPast|isThisUnit|isUTC|isValid|long|medium|now|parse|range|relative|relativeTo|removeLocale|reset|rewind|set|setDate|setFullYear|setHours|setISOWeek|setLocale|setMilliseconds|setMinutes|setMonth|setOption|setSeconds|setTime|setUTC|setUTCDate|setUTCFullYear|setUTCHours|setUTCMilliseconds|setUTCMinutes|setUTCMonth|setUTCSeconds|setWeekday|setYear|short|toDateString|toGMTString|toISOString|toJSON|toLocaleDateString|toLocaleString|toLocaleTimeString|toSource|toString|toTimeString|toUTCString|unitsAgo|unitsFromNow|unitsSince|unitsUntil|UTC|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.date.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(__|add|addIndex|adjust|after|all|allPass|always|and|andThen|any|anyPass|ap|aperture|append|apply|applySpec|applyTo|ary|ascend|assoc|assocPath|before|binary|bind|bindAll|bindKey|both|call|cancel|chain|clamp|clone|comparator|complement|compose|composeK|composeP|composeWith|concat|cond|construct|constructN|contains|converge|countBy|curry|curryN|curryRight|debounce|dec|defaultTo|defer|delay|descend|difference|differenceWith|dissoc|dissocPath|divide|drop|dropLast|dropLastWhile|dropRepeats|dropRepeatsWith|dropWhile|either|empty|endsWith|eqBy|eqProps|equals|every|evolve|F|filter|find|findIndex|findLast|findLastIndex|flatten|flip|forEach|forEachObjIndexed|fromPairs|groupBy|groupWith|gt|gte|has|hasIn|hasPath|head|identical|identity|ifElse|inc|includes|indexBy|indexOf|init|innerJoin|insert|insertAll|intersection|intersperse|into|invert|invertObj|invoker|is|isEmpty|isNil|join|juxt|keys|keysIn|last|lastIndexOf|lazy|length|lens|lensIndex|lensPath|lensProp|lift|liftN|lock|lt|lte|map|mapAccum|mapAccumRight|mapObjIndexed|match|mathMod|max|maxBy|mean|median|memoize|memoizeWith|merge|mergeAll|mergeDeepLeft|mergeDeepRight|mergeDeepWith|mergeDeepWithKey|mergeLeft|mergeRight|mergeWith|mergeWithKey|min|minBy|modulo|move|multiply|nAry|negate|none|not|nth|nthArg|o|objOf|of|omit|once|or|otherwise|over|overArgs|pair|partial|partialRight|partition|path|pathEq|pathOr|paths|pathSatisfies|pick|pickAll|pickBy|pipe|pipeK|pipeP|pipeWith|pluck|prepend|product|project|prop|propEq|propIs|propOr|props|propSatisfies|range|rearg|reduce|reduceBy|reduced|reduceRight|reduceWhile|reject|remove|repeat|replace|rest|restArguments|reverse|scan|sequence|set|slice|sort|sortBy|sortWith|split|splitAt|splitEvery|splitWhen|spread|startsWith|subtract|sum|symmetricDifference|symmetricDifferenceWith|T|tail|take|takeLast|takeLastWhile|takeWhile|tap|test|throttle|thunkify|times|toLower|toPairs|toPairsIn|toSource|toString|toUpper|transduce|transpose|traverse|trim|tryCatch|type|unapply|unary|uncurryN|unfold|union|unionWith|uniq|uniqBy|uniqWith|unless|unnest|until|update|useWith|values|valuesIn|view|when|where|whereEq|without|wrap|xor|xprod|zip|zipObj|zipWith)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.function.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(next|return|throw)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.generator.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(chain|parse|stringify|value)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.json.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(castArray|clone|cloneDeep|cloneDeepWith|cloneWith|conformsTo|eq|gt|gte|isArguments|isArray|isArrayBuffer|isArrayLike|isArrayLikeObject|isBoolean|isBuffer|isDate|isElement|isEmpty|isError|iSetual|iSetualWith|isFinite|isFunction|isInteger|isLength|isMap|isMatch|isMatchWith|isNaN|isNative|isNil|isNull|isNumber|isObject|isObjectLike|isPlainObject|isProxy|isRegExp|isSafeInteger|isSet|isString|isSymbol|isUndefined|isWeakMap|isWeakSet|lt|lte|toArray|toFinite|toInteger|toLength|toNumber|toPlainObject|toSafeInteger|toString)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.lang.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(clear|delete|entries|forEach|get|has|keys|set|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.map.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(abs|acos|acosh|acot|acoth|acsc|acsch|add|and|apply|arg|asec|asech|asin|asinh|atan|atan2|atanh|bellNumbers|bin|bitAnd|bitNot|bitOr|bitXor|catalan|cbrt|ceil|clone|clz32|column|combinations|combinationsWithRep|compare|compareNatural|compareText|compile|composition|concat|conj|cos|cosh|cot|coth|count|cross|csc|csch|ctranspose|cube|deepEqual|derivative|det|diag|diff|distance|divide|dot|dotDivide|dotMultiply|dotPow|eigs|equal|equalText|erf|evaluate|exp|expm|expm1|factorial|filter|fix|flatten|floor|forEach|format|fround|gamma|gcd|getMatrixDataType|hasNumericValue|help|hex|hypot|identity|im|imul|intersect|inv|isInteger|isNaN|isNegative|isNumeric|isPositive|isPrime|isZero|kldivergence|kron|larger|largerEq|lcm|leftShift|log|log10|log1p|log2|lsolve|lup|lusolve|mad|map|max|maxBy|mean|meanBy|median|min|minBy|mod|mode|multinomial|multiply|norm|not|nthRoot|nthRoots|numeric|oct|ones|or|parser|partitionSelect|permutations|pickRandom|pow|print|prod|qr|quantileSeq|random|randomInt|range|rationalize|re|reshape|resize|rightArithShift|rightLogShift|rotate|rotationMatrix|round|row|sec|sech|setCartesian|setDifference|setDistinct|setIntersect|setIsSubset|setMultiplicity|setPowerset|setSize|setSymDifference|setUnion|sign|simplify|sin|sinh|size|slu|smaller|smallerEq|sort|sqrt|sqrtm|square|squeeze|std|stirlingS2|subset|subtract|sum|sumBy|tan|tanh|to|trace|transpose|trunc|typeOf|unaryMinus|unaryPlus|unequal|usolve|variance|xgcd|xor|zeros)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.math.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(abbr|bytes|cap|ceil|chr|clamp|dateUnit|dateUnitAfter|dateUnitAgo|dateUnitBefore|dateUnitFromNow|downto|duration|floor|format|hex|inRange|isEven|isFinite|isInteger|isMultipleOf|isNaN|isOdd|isSafeInteger|log|math|metric|ordinalize|pad|parseFloat|parseInt|random|range|round|times|toExponential|toFixed|toLocaleString|toNumber|toPrecision|toSource|toString|upto|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.number.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(__defineGetter__|__defineSetter__|__lookupGetter__|__lookupSetter__|add|addAll|allKeys|assign|assignIn|assignInWith|assignWith|at|average|clone|count|create|defaults|defaultsDeep|defineProperties|defineProperty|entries|entriesIn|every|exclude|extend|extendOwn|extendWith|filter|find|findKey|findLastKey|forEach|forIn|forInRight|forOwn|forOwnRight|freeze|fromEntries|fromQueryString|functions|functionsIn|get|getOwnPropertyDescriptor|getOwnPropertyDescriptors|getOwnPropertyNames|getOwnPropertySymbols|getPrototypeOf|has|hasIn|hasOwnProperty|intersect|invert|invertBy|invoke|is|isArguments|isArray|isArrayBuffer|isBoolean|isDataView|isDate|isElement|isEmpty|isEqual|isError|isExtensible|isFinite|isFrozen|isFunction|isMap|isMatch|isNaN|isNull|isNumber|isObject|isPrototypeOf|isRegExp|isSealed|isSet|isString|isSymbol|isType|isTypedArray|isUndefined|isWeakMap|isWeakSet|keys|keysIn|least|map|mapKeys|mapObject|mapValues|matcher|max|median|merge|mergeAll|mergeWith|min|most|none|omit|omitBy|pairs|pick|pickBy|preventExtensions|property|propertyIsEnumerable|propertyOf|reduce|reject|remove|result|seal|select|set|setPrototypeOf|setWith|size|some|subtract|sum|tap|toLocaleString|toPairs|toPairsIn|toPath|toQueryString|toSource|toString|transform|unset|update|updateWith|valueOf|values|valuesIn)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.object.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(all|allSettled|any|catch|finally|race|reject|resolve|then)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.promise.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(apply|construct|defineProperty|deleteProperty|get|getOwnPropertyDescriptor|getPrototypeOf|has|isExtensible|ownKeys|preventExtensions|register|set|setPrototypeOf|unregister)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.proxy.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(address|age|altitude|ampm|android_id|animal|apple_token|areacode|avatar|bb_pin|birthday|bool|capitalize|cc|cc_type|cf|character|city|coin|color|company|coordinates|country|cpf|currency|currency_pair|date|depth|dice|dollar|domain|email|euro|exp|exp_month|exp_year|falsy|fbid|first|floating|gender|geohash|google_analytics|guid|hammertime|hash|hashtag|hidden|hour|integer|ip|ipv6|klout|last|latitude|letter|locale|longitude|millisecond|minute|mixin|month|n|name|natural|normal|pad|paragraph|phone|pick|pickone|pickset|postal|postcode|prefix|prime|profession|province|radio|rpg|second|sentence|set|shuffle|ssn|state|street|string|suffix|syllable|timestamp|timezone|tld|tv|twitter|unique|url|weekday|weighted|word|wp7_anid|wp8_anid2|year|zip)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.random.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(addFlags|compile|escape|exec|getFlags|removeFlags|setFlags|test|toSource|toString)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.regexp.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(at|chain|commit|next|plant|prototype|reverse|tap|thru|toJSON|value|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.seq.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(add|clear|delete|entries|forEach|has|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.set.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(addAcronym|addHuman|addPlural|anchor|at|big|blink|bold|camelCase|camelize|capitalize|chain|charAt|charCodeAt|chars|codePointAt|codePoints|codes|compact|concat|count|countGraphemes|countSubstrings|countWhere|countWords|dasherize|deburr|decapitalize|decodeBase64|encodeBase64|endsWith|escape|escapeHtml|escapeHTML|escapeRegExp|escapeURL|first|fixed|fontcolor|fontsize|forEach|format|from|fromCharCode|fromCodePoint|graphemeAt|graphemes|hankaku|hasScript|hiragana|humanize|includes|indexOf|insert|isAlpha|isAlphaDigit|isBlank|isDigit|isEmpty|isLowerCase|isNumeric|isScript|isString|isUpperCase|italics|katakana|kebabCase|last|lastIndexOf|latinise|lines|link|localeCompare|lowerCase|lowerFirst|match|matchAll|matches|normalize|pad|padEnd|padLeft|padRight|padStart|parameterize|parseInt|pluralize|prune|range|raw|remove|removeAll|removeTags|repeat|replace|replaceAll|reverse|reverseGrapheme|search|shift|singularize|slice|slugify|small|snakeCase|spacify|splice|split|sprintf|startCase|startsWith|strike|stripBom|stripTags|sub|substr|substring|sup|swapCase|template|thru|titleCase|titleize|to|toLocaleLowerCase|toLocaleUpperCase|toLower|toLowerCase|toNumber|toSource|toString|toUpper|toUpperCase|tr|trim|trimEnd|trimLeft|trimRight|trimStart|truncate|truncateOnWord|underscore|unescape|unescapeHtml|unescapeHTML|unescapeURL|upperCase|upperFirst|value|valueOf|vprintf|words|wordWrap|zenkaku)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.string.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(for|keyFor|toSource|toString|valueOf)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.symbol.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(at|copyWithin|entries|every|fill|filter|find|findIndex|forEach|from|includes|indexOf|join|keys|lastIndexOf|map|of|reduce|reduceRight|reverse|set|slice|some|sort|subarray|toLocaleString|toString|values)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.typedarray.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(attempt|bindAll|cond|conforms|constant|defaultTo|escape|flow|flowRight|identity|iteratee|matches|matchesProperty|method|methodOf|mixin|noConflict|noop|now|nthArg|over|overEvery|overSome|property|propertyOf|random|range|rangeRight|result|runInContext|stubArray|stubFalse|stubObject|stubString|stubTrue|template|times|toPath|unescape|uniqueId)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.util.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: \s*+(compile|compileStreaming|instantiate|instantiateStreaming|validate)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.webassembly.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(on(?:Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|Before(?:cut|deactivate|unload|update|paste|print|editfocus|activate)|Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort))\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.event-handler.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.method.cgt}
        patterns:
          - include: '#round-brackets'
      - applyEndPatternLast: 1
        begin: >-
          \s*+(acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|appendChild|appendData|before|blur|canPlayType|captureStream|caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|cloneContents|cloneNode|cloneRange|close|closest|collapse|compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|createAttributeNS|createCaption|createCDATASection|createComment|createContextualFragment|createDocument|createDocumentFragment|createDocumentType|createElement|createElementNS|createEntityReference|createEvent|createExpression|createHTMLDocument|createNodeIterator|createNSResolver|createProcessingInstruction|createRange|createShadowRoot|createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|getClientRects|getContext|getDestinationInsertionPoints|getElementById|getElementsByClassName|getElementsByName|getElementsByTagName|getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|previousSibling|probablySupportsContext|queryCommandEnabled|queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|querySelector|querySelectorAll|registerContentHandler|registerElement|registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|toDataURL|toggle|toString|values|write|writeln)\b
        end: (?=.)
        beginCaptures:
          1: {name: support.function.dom.cgt}
        patterns:
          - include: '#round-brackets'
  support-objects:
    patterns:
      - match: (?<!(?<!\.\.)\.|\#)\s*\b(global|GLOBAL|root|__dirname|__filename)\b\s*
        name: support.variable.object.node.cgt
      - match: (?<!(?<!\.\.)\.|\#)\s*\b(exports|process)\s*\b
        name: support.variable.$1.cgt
      - match: (?<!(?<!\.\.)\.|\#)\s*\b(JSON)\s*\b
        name: support.constant.json.cgt
      - match: (?<!(?<!\.\.)\.|\#)\s*\b(Math)\s*\b
        name: support.constant.math.cgt
      - match: (?<!(?<!\.\.)\.|\#)\s*\b(console)\s*\b
        name: support.constant.console.cgt
      - match: (?<!(?<!\.\.)\.|\#)\s*+\b(document|event|navigator|performance|screen|window)\s*+\b
        name: support.variable.dom.cgt
      - match: |-
          (?x) (?<!(?<!\.\.)\.|\#) \s*+ \b
            (Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream 
          |Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip) \b
        name: support.class.node.cgt
      - applyEndPatternLast: 1
        begin: |-
          (?x) (?<!(?<!\.\.)\.|\#) \s*+ \b
            (AnalyserNode|ArrayBufferView|Attr|AudioBuffer|AudioBufferSourceNode|AudioContext|AudioDestinationNode|AudioListener
            |AudioNode|AudioParam|BatteryManager|BeforeUnloadEvent|BiquadFilterNode|Blob|BufferSource|ByteString|CSS|CSSConditionRule
            |CSSCounterStyleRule|CSSGroupingRule|CSSMatrix|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration
            |CSSStyleRule|CSSStyleSheet|CSSSupportsRule|CSSValue|CSSValueList|CanvasGradient|CanvasImageSource|CanvasPattern
            |CanvasRenderingContext2D|ChannelMergerNode|ChannelSplitterNode|CharacterData|ChromeWorker|CloseEvent|Comment|CompositionEvent
            |Console|ConvolverNode|Coordinates|Credential|CredentialsContainer|Crypto|CryptoKey|CustomEvent|DOMError|DOMException
            |DOMHighResTimeStamp|DOMImplementation|DOMString|DOMStringList|DOMStringMap|DOMTimeStamp|DOMTokenList|DataTransfer
            |DataTransferItem|DataTransferItemList|DedicatedWorkerGlobalScope|DelayNode|DeviceProximityEvent|DirectoryEntry
            |DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|Document|DocumentFragment|DocumentTouch|DocumentType|DragEvent
            |DynamicsCompressorNode|Element|Entry|EntrySync|ErrorEvent|Event|EventListener|EventSource|EventTarget|FederatedCredential
            |FetchEvent|File|FileEntry|FileEntrySync|FileException|FileList|FileReader|FileReaderSync|FileSystem|FileSystemSync
            |FontFace|FormData|GainNode|Gamepad|GamepadButton|GamepadEvent|Geolocation|GlobalEventHandlers|HTMLAnchorElement
            |HTMLAreaElement|HTMLAudioElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLButtonElement|HTMLCanvasElement
            |HTMLCollection|HTMLContentElement|HTMLDListElement|HTMLDataElement|HTMLDataListElement|HTMLDialogElement|HTMLDivElement
            |HTMLDocument|HTMLElement|HTMLEmbedElement|HTMLFieldSetElement|HTMLFontElement|HTMLFormControlsCollection|HTMLFormElement
            |HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLIFrameElement|HTMLImageElement|HTMLInputElement
            |HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMediaElement
            |HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLObjectElement|HTMLOptGroupElement|HTMLOptionElement
            |HTMLOptionsCollection|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPreElement|HTMLProgressElement
            |HTMLQuoteElement|HTMLScriptElement|HTMLSelectElement|HTMLShadowElement|HTMLSourceElement|HTMLSpanElement|HTMLStyleElement
            |HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement
            |HTMLTableRowElement|HTMLTableSectionElement|HTMLTextAreaElement|HTMLTimeElement|HTMLTitleElement|HTMLTrackElement
            |HTMLUListElement|HTMLUnknownElement|HTMLVideoElement|HashChangeEvent|History|IDBCursor|IDBCursorWithValue|IDBDatabase
            |IDBEnvironment|IDBFactory|IDBIndex|IDBKeyRange|IDBMutableFile|IDBObjectStore|IDBOpenDBRequest|IDBRequest|IDBTransaction
            |IDBVersionChangeEvent|IIRFilterNode|IdentityManager|ImageBitmap|ImageBitmapFactories|ImageData|Index|InputDeviceCapabilities
            |InputEvent|InstallEvent|InstallTrigger|KeyboardEvent|LinkStyle|LocalFileSystem|LocalFileSystemSync|Location|MIDIAccess
            |MIDIConnectionEvent|MIDIInput|MIDIInputMap|MIDIOutputMap|MediaElementAudioSourceNode|MediaError|MediaKeyMessageEvent
            |MediaKeySession|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeySystemConfiguration|MediaKeys|MediaRecorder|MediaStream
            |MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessageChannel|MessageEvent|MessagePort|MouseEvent
            |MutationObserver|MutationRecord|NamedNodeMap|Navigator|NavigatorConcurrentHardware|NavigatorGeolocation|NavigatorID
            |NavigatorLanguage|NavigatorOnLine|Node|NodeFilter|NodeIterator|NodeList|NonDocumentTypeChildNode|Notification
            |OfflineAudioCompletionEvent|OfflineAudioContext|OscillatorNode|PageTransitionEvent|PannerNode|ParentNode|PasswordCredential
            |Path2D|PaymentAddress|PaymentRequest|PaymentResponse|Performance|PerformanceEntry|PerformanceFrameTiming|PerformanceMark
            |PerformanceMeasure|PerformanceNavigation|PerformanceNavigationTiming|PerformanceObserver|PerformanceObserverEntryList
            |PerformanceResourceTiming|PerformanceTiming|PeriodicSyncEvent|PeriodicWave|Plugin|Point|PointerEvent|PopStateEvent
            |PortCollection|Position|PositionError|PositionOptions|PresentationConnectionClosedEvent|PresentationConnectionList
            |PresentationReceiver|ProcessingInstruction|ProgressEvent|PromiseRejectionEvent|PushEvent|PushRegistrationManager
            |RTCCertificate|RTCConfiguration|RTCPeerConnection|RTCSessionDescriptionCallback|RTCStatsReport|RadioNodeList|RandomSource
            |Range|ReadableByteStream|RenderingContext|SVGAElement|SVGAngle|SVGAnimateColorElement|SVGAnimateElement|SVGAnimateMotionElement
            |SVGAnimateTransformElement|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength
            |SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPoints|SVGAnimatedPreserveAspectRatio
            |SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGAnimationElement|SVGCircleElement|SVGClipPathElement
            |SVGCursorElement|SVGDefsElement|SVGDescElement|SVGElement|SVGEllipseElement|SVGEvent|SVGFilterElement|SVGFontElement
            |SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement
            |SVGForeignObjectElement|SVGGElement|SVGGlyphElement|SVGGradientElement|SVGHKernElement|SVGImageElement|SVGLength
            |SVGLengthList|SVGLineElement|SVGLinearGradientElement|SVGMPathElement|SVGMaskElement|SVGMatrix|SVGMissingGlyphElement
            |SVGNumber|SVGNumberList|SVGPathElement|SVGPatternElement|SVGPoint|SVGPolygonElement|SVGPolylineElement|SVGPreserveAspectRatio
            |SVGRadialGradientElement|SVGRect|SVGRectElement|SVGSVGElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStringList
            |SVGStylable|SVGStyleElement|SVGSwitchElement|SVGSymbolElement|SVGTRefElement|SVGTSpanElement|SVGTests|SVGTextElement
            |SVGTextPositioningElement|SVGTitleElement|SVGTransform|SVGTransformList|SVGTransformable|SVGUseElement|SVGVKernElement
            |SVGViewElement|ServiceWorker|ServiceWorkerContainer|ServiceWorkerGlobalScope|ServiceWorkerRegistration|ServiceWorkerState
            |ShadowRoot|SharedWorker|SharedWorkerGlobalScope|SourceBufferList|StereoPannerNode|Storage|StorageEvent|StyleSheet
            |StyleSheetList|SubtleCrypto|SyncEvent|Text|TextMetrics|TimeEvent|TimeRanges|Touch|TouchEvent|TouchList|Transferable
            |TreeWalker|UIEvent|USVString|VRDisplayCapabilities|ValidityState|WaveShaperNode|WebGL|WebGLActiveInfo|WebGLBuffer
            |WebGLContextEvent|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLRenderingContext|WebGLShader|WebGLShaderPrecisionFormat
            |WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLUniformLocation|WebGLVertexArrayObject|WebGLVertexArrayObjectOES
            |WebSocket|WebSockets|WebVTT|WheelEvent|Window|WindowBase64|WindowEventHandlers|WindowTimers|Worker|WorkerGlobalScope
            |WorkerLocation|WorkerNavigator|XMLHttpRequest|XMLHttpRequestEventTarget|XMLSerializer|XPathExpression|XPathResult
            |XSLTProcessor)
          \b
        end: (?=.)
        name: support.class.dom.cgt
        beginCaptures:
          1: {name: support.class.dom.cgt}
  support-properties:
    patterns:
      - match: |-
          (?<=\.)\s*\b
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          \b\s*
        name: support.variable.property.dom.cgt
      - match: >-
          (?x)(?<=\.)\s*\b
          (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName   
          |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop   
          |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor   
          |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption   
          |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear   
          |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete   
          |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset   
          |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
              |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
              |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
              |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
              |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
              |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
              |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
              |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
              |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
              |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
              |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
              |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
              |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
              |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
              |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
              |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
              |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
              |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
              |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
          \b\s*
        name: support.variable.property.dom.cgt
      - match: (?x)(?<=\.)\s*\b (module|exports|id|filename|loaded|parent|children) \b\s*
        name: support.type.object.module.cgt
  support-python:
    patterns:
      - match: |
          (?x)
            (?<!(?<!\.\.)\.|\#) \s*+ \b(
              __import__ | abs | all | any | ascii | bin | breakpoint | callable
              | chr | compile | copyright | credits | delattr | dir | divmod
              | enumerate | eval | exec | exit | filter | format | getattr
              | globals | hasattr | hash | help | hex | id | input
              | isinstance | issubclass | iter | len | license | locals | map
              | max | memoryview | min | next | oct | open | ord | pow | print
              | quit | range | reload | repr | reversed | round
              | setattr | sorted | sum | vars | zip
            )\b
        name: support.function.builtin.cgt
      - match: |
          (?x)
            (?<!(?<!\.\.)\.|\#) \s*+ \b(
              file | reduce | intern | raw_input | unicode | cmp | basestring
              | execfile | long | xrange
            )\b
        name: variable.legacy.builtin.cgt
      - match: |
          (?x)
            (?<!(?<!\.\.)\.|\#) \s*+ \b(
              bool | bytearray | bytes | classmethod | complex | dict
              | float | frozenset | int | list | object | property
             | slice | staticmethod | str | tuple | type
              (?# Although 'super' is not a type, it's related to types,
                  and is special enough to be highlighted differently from
                  other built-ins)
              | super
            )\b
        name: support.type.primitive.cgt
      - comment: |
          these methods have magic interpretation by python and are generally called
          indirectly through syntactic constructs
        match: |
          (?x)
           \s*+ \b(
              __(?:
                abs | add | aenter | aexit | aiter | and | anext | await
                | bool | call | ceil | cmp | coerce | complex | contains
                | copy | deepcopy | del | delattr | delete | delitem
                | delslice | dir | div | divmod | enter | eq | exit | float
                | floor | floordiv | format | ge | get | getattr
                | getattribute | getinitargs | getitem | getnewargs
                | getslice | getstate | gt | hash | hex | iadd | iand | idiv
                | ifloordiv | ilshift | imod | imul | index | init
                | instancecheck | int | invert | ior | ipow | irshift | isub
                | iter | itruediv | ixor | le | len | long | lshift | lt
                | missing | mod | mul | ne | neg | new | next | nonzero | oct | or
                | pos | pow | radd | rand | rdiv | rdivmod | reduce
                | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod
                | rmul | ror | round | rpow | rrshift | rshift | rsub
                | rtruediv | rxor | setattr | setitem | setslice
                | setstate | sizeof | str | sub | subclasscheck | truediv
                | trunc | unicode | xor | matmul | rmatmul | imatmul
                | init_subclass | set_name | fspath | bytes | prepare
              )__
            )\b
        captures:
          1: {name: support.function.magic.cgt}
      - comment: magic variables which a class/module may have.
        match: |
          (?x)
           \s*+ \b(
              __(?:
                all | bases | builtins | class | class_getitem | code | debug
                | defaults | dict | doc | file | func | kwdefaults | members
                | metaclass | methods | module | mro | mro_entries | name
                | qualname | post_init | self | signature | slots | subclasses
                | version | weakref | wrapped | annotations | classcell
                | spec | path | package | future | traceback
              )__
            )\b
        captures:
          1: {name: support.variable.magic.cgt}
  switch:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(switch)\b
        end: \s*(\})
        name: meta.switch.cgt
        beginCaptures:
          1: {name: keyword.control.switch.cgt}
        endCaptures:
          1: {name: meta.brace.curly.switchEnd.cgt}
        patterns:
          - include: '#type-argument-brackets'
          - begin: \s*+({)
            end: \s*(?=})
            beginCaptures:
              1: {name: meta.brace.curly.switchStart.cgt}
            patterns:
              - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(case|def)\b
                end: \s*(:)((?=::)|(?!:))
                beginCaptures:
                  1: {name: keyword.control.switch.cgt}
                endCaptures:
                  1: {name: keyword.operator.cgt}
                patterns:
                  - include: '#core'
              - include: $self
          - include: $self
  ternary-expression:
    begin: (?!\?\.\s*[^[:digit:]])(\?)(?!\?)
    end: \s*(:)
    beginCaptures:
      1: {name: keyword.operator.ternary.cgt}
    endCaptures:
      1: {name: keyword.operator.ternary.cgt}
    patterns:
      - include: '#core'
  type-argument-brackets:
    patterns:
      - begin: \s*+(<)(?=((?:(?>[^<>]+)|<\g<-1>>)*)>)
        comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        end: \s*(>)
        name: meta.type-arguments.flowtype
        beginCaptures:
          1: {name: punctuation.flowtype}
        endCaptures:
          1: {name: punctuation.flowtype}
        patterns:
          - include: '#flowtype-parse-types'
          - include: '#comma'
  variable:
    patterns:
      - comment: e.g. CONSTANT
        match: \s*+(\#?)([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)(?!\p{Ll})
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.constant.cgt}
      - comment: e.g. dollar vars
        match: \s*+(\#?)(\\[-_\\\p{L}\p{M}\p{N}]*)
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.dollar.cgt}
      - comment: e.g. Class
        match: \s*+(\#?)\b([_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.class.cgt}
      - comment: e.g. obj.property
        match: (?<!(?<!\.\.)\.|\#)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*+(?=[\[\.]|[!?~]\.)
        name: variable.other.object.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.object.cgt}
      - comment: e.g. obj.property
        match: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        name: meta.property.object.cgt
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.property.cgt}
      - match: \s*+(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)
        captures:
          1: {name: keyword.operator.private.cgt}
          2: {name: variable.other.readwrite.cgt}
  variable-flowtype:
    patterns:
      - begin: (?<=^|,|\()\s*+(?=(\#?)([_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*)\s*\??\s*(:)((?=::)|(?!:)))
        comment: Assume this is a flow typed var
        end: \s*(?=,|\))
        beginCaptures:
          3: {name: punctuation.flowtype}
        patterns:
          - include: '#flowtype-variable'
      - begin: (?<=^|,|\()\s*+(?="[^"]"\s*(:))
        comment: Assume this is a flow typed var
        end: \s*(?>=|\))
        beginCaptures:
          3: {name: punctuation.flowtype}
        patterns:
          - include: '#flowtype-variable'
      - begin: (?<=^|,|\()\s*+(?='[^']'\s*(:))
        comment: Assume this is a flow typed var
        end: \s*(?>=|\))
        beginCaptures:
          3: {name: punctuation.flowtype}
        patterns:
          - include: '#flowtype-variable'
  with:
    patterns:
      - begin: (?<!(?<!\.\.)\.|\#)\s*+\b(with)\b\s*(await)?\b
        end: \s*(?<=[})])
        name: meta.with.cgt
        beginCaptures:
          1: {name: keyword.control.with.cgt}
          2: {name: keyword.control.flow.cgt}
        endCaptures:
          1: {name: meta.brace.round.cgt}
        patterns:
          - include: '#curly-brackets'
          - begin: \s*
            end: \s*(?=[{,])
            patterns:
              - match: (?<!(?<!\.\.)\.|\#)\s*+\b(as)\b
                name: keyword.control.with.cgt
              - include: '#core'
          - begin: \s*+(\()
            end: \s*(?=\))
            beginCaptures:
              1: {name: meta.brace.round.cgt}
            patterns:
              - match: (?<!(?<!\.\.)\.|\#)\s*+\b(as)\b
                name: keyword.control.with.cgt
              - include: '#core'
          - include: $self
limitLineLength: false
